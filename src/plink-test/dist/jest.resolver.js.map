{"version":3,"file":"jest.resolver.js","sourceRoot":"","sources":["jest.resolver.ts"],"names":[],"mappings":";;;;AAAA;GACG;AACH,kEAA6B;AAC7B,8DAA8B;AAC9B,6BAA6B;AAC7B,mGAA4F;AAwB5F,IAAI,YAAqE,CAAC;AAE1E,SAAgB,IAAI,CAAC,OAAe,EAAE,IAAqB;IACzD,IAAI,YAAY,IAAI,IAAI,EAAE;QACxB,YAAY,GAAG,IAAA,6CAAoB,GAAE,CAAC,YAAY,CAAC;KACpD;IACD,IAAI,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;IAC3B,IAAI,CAAC,mBAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;QACzD,MAAM,GAAG,GAAG,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACvC,IAAI,GAAG,EAAE;YACP,MAAM,GAAG,GAAG,mBAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;YACtD,OAAO,GAAG,mBAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;YACtC,sCAAsC;YACtC,wEAAwE;SACzE;KACF;IACD,IAAI;QACF,MAAM,IAAI,GAAG,iBAAO,CAAC,IAAI,CAAC,OAAO,EAAE;YACjC,OAAO;YACP,UAAU,EAAE,IAAI,CAAC,UAAU;YAC3B,gBAAgB,EAAE,IAAI;SACvB,CAAC,CAAC;QAGH,OAAO,IAAI,CAAC;KACb;IAAC,OAAO,CAAC,EAAE;QACV,IAAK,CAA2B,CAAC,IAAI,KAAK,kBAAkB,EAAE;YAC5D,OAAO,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;SAC5C;QACD,MAAM,CAAC,CAAC;KACT;AACH,CAAC;AA7BD,oBA6BC","sourcesContent":["/** Respect --preserve-symlink flag of Node.js\n */\nimport Path from 'node:path';\nimport resolve from 'resolve';\n// import chalk from 'chalk';\nimport {packageOfFileFactory} from '@wfh/plink/wfh/dist/package-mgr/package-info-gathering';\ntype PackageJSON = Record<string, any>;\n\ntype ResolverOptions = {\n  /** Directory to begin resolving from. */\n  basedir: string;\n  /** List of export conditions. */\n  conditions?: Array<string>;\n  /** Instance of default resolver. */\n  defaultResolver: (path: string, options: ResolverOptions) => string;\n  /** List of file extensions to search in order. */\n  extensions?: Array<string>;\n  /** List of directory names to be looked up for modules recursively. */\n  moduleDirectory?: Array<string>;\n  /** List of `require.paths` to use if nothing is found in `node_modules`. */\n  paths?: Array<string>;\n  /** Allows transforming parsed `package.json` contents. */\n  packageFilter?: (pkg: PackageJSON, file: string, dir: string) => PackageJSON;\n  /** Allows transforms a path within a package. */\n  pathFilter?: (pkg: PackageJSON, path: string, relativePath: string) => string;\n  /** Current root directory. */\n  rootDir?: string;\n};\n\nlet getPkgOfFile: ReturnType<typeof packageOfFileFactory>['getPkgOfFile'];\n\nexport function sync(request: string, opts: ResolverOptions) {\n  if (getPkgOfFile == null) {\n    getPkgOfFile = packageOfFileFactory().getPkgOfFile;\n  }\n  let basedir = opts.basedir;\n  if (!Path.isAbsolute(request) && !request.startsWith('.')) {\n    const pkg = getPkgOfFile(opts.basedir);\n    if (pkg) {\n      const rel = Path.relative(pkg.realPath, opts.basedir);\n      basedir = Path.resolve(pkg.path, rel);\n      // eslint-disable-next-line no-console\n      // console.log('resolve', chalk.yellow(request), opts.basedir, basedir);\n    }\n  }\n  try {\n    const file = resolve.sync(request, {\n      basedir,\n      extensions: opts.extensions,\n      preserveSymlinks: true\n    });\n\n\n    return file;\n  } catch (e) {\n    if ((e as NodeJS.ErrnoException).code === 'MODULE_NOT_FOUND') {\n      return opts.defaultResolver(request, opts);\n    }\n    throw e;\n  }\n}\n\n"]}