{"version":3,"file":"cache-service.js","sourceRoot":"","sources":["cache-service.ts"],"names":[],"mappings":"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","sourcesContent":["// import Path from 'path';\nimport {IncomingMessage, ServerResponse} from 'http';\n// import stream from 'stream';\nimport url from 'url';\n// import fs from 'fs-extra';\nimport * as rx from 'rxjs';\nimport * as op from 'rxjs/operators';\nimport _ from 'lodash';\nimport {Request, Response, NextFunction} from 'express';\nimport {ServerOptions, createProxyServer} from 'http-proxy';\nimport chalk from 'chalk';\nimport api from '__plink';\nimport {log4File, config} from '@wfh/plink';\nimport {createSlice, castByActionType} from '@wfh/redux-toolkit-observable/dist/tiny-redux-toolkit';\n// import {createReplayReadableFactory} from '@wfh/assets-processer/dist/utils';\nimport {httpProxyObservable, observeProxyResponse} from '@wfh/assets-processer/dist/http-proxy-observable';\nimport {ProxyCacheState, CacheData} from './types';\n\n\nconst httpProxyLog = log4File(__filename);\n\nexport function createProxyWithCache(proxyPath: string, serverOptions: ServerOptions, cacheRootDir: string,\n  opts: {manual: boolean; memCacheLength?: number} = {manual: false}) {\n  const defaultProxy = createProxyServer({\n    changeOrigin: true,\n    ws: false,\n    secure: false,\n    cookieDomainRewrite: {'*': ''},\n    followRedirects: true,\n    proxyTimeout: 20000,\n    timeout: 10000,\n    ...serverOptions\n  });\n  const initialState: ProxyCacheState = {\n    cacheDir: cacheRootDir,\n  };\n\n  const proxy$ = httpProxyObservable(defaultProxy);\n\n  if (!opts.manual) {\n    api.expressAppSet(app => {\n      app.use(proxyPath, (req, res, next) => {\n        const key = keyOfUri(req.method, req.url);\n        cacheController.actionDispatcher.hitCache({key, req, res, next});\n      });\n    });\n  }\n  const cacheController = createSlice({\n    initialState,\n    name: `HTTP-proxy-cache-${proxyPath}`,\n    debugActionOnly: config().cliOptions?.verbose,\n    reducers: {\n      configTransformer(s: ProxyCacheState, payload: {\n        remote?: ProxyCacheState['responseTransformer'];\n        cached?: ProxyCacheState['cacheTransformer'];\n      }) {\n        if (payload.remote)\n          s.responseTransformer = payload.remote;\n        if (payload.cached)\n          s.cacheTransformer = payload.cached;\n      },\n      hitCache(s: ProxyCacheState, payload: {\n        key: string; req: Request; res: Response; next: NextFunction;\n        /** override remote target */\n        target?: string;\n      }) {},\n\n      _requestRemoteDone(s: ProxyCacheState, payload: {\n        key: string; reqHost: string | undefined;\n        res: ServerResponse;\n        data: {headers: CacheData['headers']; readable: IncomingMessage};\n      }) {},\n\n      _loadFromStorage(\n        s: ProxyCacheState,\n        payload: {\n          key: string; req: Request; res: Response;\n          next: NextFunction;\n          target?: string;\n        }\n      ) {\n        // s.cacheByUri.set(payload.key, 'loading');\n      },\n\n      _requestRemote(s: ProxyCacheState, payload: {\n        key: string; req: Request; res: Response; next: NextFunction;\n        target?: string;\n      }) {\n        // s.cacheByUri.set(payload.key, 'requesting');\n      },\n      _savingFile(s: ProxyCacheState, payload: {\n        key: string;\n        res: ServerResponse;\n        data: CacheData;\n      }) {\n        // s.cacheByUri.set(payload.key, 'saving');\n      },\n      _done(s: ProxyCacheState, payload: {\n        key: string;\n        res: ServerResponse;\n        data: CacheData;\n      }) {\n        // s.cacheByUri.delete(payload.key);\n        // if (payload.data.statusCode !== 304) {\n        //   if (s.cacheByUri.size >= s.memCacheLength) {\n        //     // TODO: improve for LRU algorigthm\n        //     s.cacheByUri.delete(payload.key);\n        //     return;\n        //   }\n        //   s.cacheByUri.set(payload.key, payload.data);\n        // }\n      },\n      _clean(s: ProxyCacheState, key: string) {\n        // s.cacheByUri.delete(key);\n      }\n    }\n  });\n\n  cacheController.epic(action$ => {\n    const actions = castByActionType(cacheController.actions, action$);\n    // const dispatcher = cacheController.actionDispatcher;\n\n    // async function requestingRemote(\n    //   key: string, reqHost: string | undefined,\n    //   proxyRes: IncomingMessage,\n    //   res: ServerResponse,\n    //   headers: [string, string | string[]][]) {\n\n    //   httpProxyLog.debug('cache size:', cacheController.getState().cacheByUri.size);\n    //   const dir = Path.join(cacheController.getState().cacheDir, key);\n    //   const file = Path.join(dir, 'body');\n    //   const statusCode = proxyRes.statusCode || 200;\n    //   const {responseTransformer} = cacheController.getState();\n    //   if (statusCode === 304) {\n    //     dispatcher._done({key, res, data: {\n    //       statusCode, headers, body: createReplayReadableFactory(proxyRes)\n    //     }\n    //     });\n    //     httpProxyLog.warn('Version info is not recorded, due to response 304 from', res.req.url, ',\\n you can remove existing npm/cache cache to avoid 304');\n    //     return;\n    //   }\n    //   if (statusCode !== 200) {\n    //     httpProxyLog.error(`Response code is ${statusCode} for request:`, res.req.url);\n    //     dispatcher._done({key, res, data: {statusCode, headers, body: () => proxyRes}});\n    //     return;\n    //   }\n\n    //   if (responseTransformer == null) {\n    //     const doneMkdir = fs.mkdirp(dir);\n    //     const readableFac = createReplayReadableFactory(proxyRes, undefined,\n    //       {debugInfo: key, expectLen: parseInt(proxyRes.headers['content-length'] as string, 10)});\n    //     // dispatcher._done({key, data: {\n    //     //       statusCode, headers, body: () => proxyRes\n    //     //     }, res\n    //     //   });\n    //     dispatcher._savingFile({key, data: {\n    //       statusCode, headers, body: readableFac\n    //     }, res\n    //     });\n    //     await doneMkdir;\n    //     void fs.promises.writeFile(\n    //       Path.join(dir, 'header.json'),\n    //       JSON.stringify({statusCode, headers}, null, '  '),\n    //       'utf-8');\n\n    //     try {\n    //       await new Promise((resolve, reject) => readableFac()\n    //         .pipe(fs.createWriteStream(file))\n    //         .on('finish', resolve)\n    //         .on('error', reject));\n\n    //       dispatcher._done({key, data: {\n    //         statusCode, headers, body: readableFac\n    //       }, res\n    //       });\n\n    //       httpProxyLog.info(`response is written to (length: ${headers.find(item => item[0] === 'content-length')![1] as string})`,\n    //         Path.posix.relative(process.cwd(), file));\n    //     } catch (e) {\n    //       httpProxyLog.error('Failed to write cache file ' +\n    //         Path.posix.relative(process.cwd(), file), e);\n    //     }\n\n    //     return;\n    //   }\n    //   if (reqHost && !reqHost.startsWith('http')) {\n    //     reqHost = 'http://' + reqHost;\n    //   }\n\n    //   const {readable: transformed, length} = await responseTransformer(headers, reqHost, proxyRes);\n    //   const lengthHeaderIdx = headers.findIndex(row => row[0] === 'content-length');\n    //   if (lengthHeaderIdx >= 0)\n    //     headers[lengthHeaderIdx][1] = '' + length;\n\n    //   dispatcher._savingFile({key, res, data: {\n    //     statusCode, headers, body: transformed\n    //   }});\n\n    //   await fs.mkdirp(dir);\n    //   void fs.promises.writeFile(\n    //     Path.join(dir, 'header.json'),\n    //     JSON.stringify({statusCode, headers}, null, '  '),\n    //     'utf-8');\n    //   await new Promise((resolve, reject) => transformed()\n    //     .on('end', resolve)\n    //     .pipe(fs.createWriteStream(file))\n    //     .on('error', reject));\n\n    //   dispatcher._done({key, res, data: {\n    //     statusCode, headers, body: transformed\n    //   }});\n    //   httpProxyLog.info('write response to file', Path.posix.relative(process.cwd(), file), 'size', length);\n    // }\n\n    return rx.merge(\n      actions.hitCache.pipe(\n        op.mergeMap( ({payload}) => {\n          // const waitCacheAndSendRes = actions._done.pipe(\n          //   // In case it is of redirected request, HPM has done piping response (ignored \"manual reponse\" setting)\n          //   op.filter(action => action.payload.key === payload.key),\n          //   op.take(1),\n          //   op.mergeMap(({payload: {key, res, data}}) => {\n          //     if (res.writableEnded) {\n          //       throw new Error('Response is ended early, why?');\n          //     }\n          //     for (const entry of data.headers) {\n          //       res.setHeader(entry[0], entry[1]);\n          //     }\n          //     res.statusCode = data.statusCode;\n          //     const pipeEvent$ = new rx.Subject<'finish' | 'close'>();\n          //     res.on('finish', () => {\n          //       pipeEvent$.next('finish');\n          //     })\n          //       .on('close', () => {\n          //         pipeEvent$.next('close');\n          //       })\n          //       .on('error', err => pipeEvent$.error(err));\n\n          //     data.body().pipe(res);\n          //     httpProxyLog.info('pipe response of', payload.key);\n\n          //     return pipeEvent$.pipe(\n          //       op.filter(event => event === 'finish' || event === 'close'),\n          //       op.tap(event => {\n          //         if (event === 'close')\n          //           httpProxyLog.error('Response connection is closed early', key,\n          //             'expect content-lenth', data.headers['content-length']);\n          //       }),\n          //       op.take(1),\n          //       op.mapTo(key)\n          //       // op.timeout(120000),\n          //       // op.catchError(err => {\n          //       // httpProxyLog.error(err);\n          //       // if (!res.headersSent) {\n          //       // res.statusCode = 500;\n          //       // res.end();\n          //       // } else {\n          //       // res.end();\n          //       // }\n          //       // return rx.EMPTY;\n          //       // })\n          //     );\n          //   }),\n          //   op.tap(key => httpProxyLog.info(`replied: ${key}`))\n          // );\n          // const item = cacheController.getState().cacheByUri.get(payload.key);\n          // httpProxyLog.info('hitCache for ' + payload.key);\n\n          // let finished$: rx.Observable<unknown> | undefined;\n\n          // if (item == null) {\n          //   finished$ = rx.merge(\n          //     waitCacheAndSendRes,\n          //     rx.defer(() => {\n          //       dispatcher._loadFromStorage(payload);\n          //       return rx.EMPTY;\n          //     })\n          //   );\n          // } else if (item === 'loading' || item === 'requesting' || item === 'saving') {\n          //   finished$ = waitCacheAndSendRes;\n          // } else {\n          //   httpProxyLog.info('hit cached', payload.key);\n          //   const transformer = cacheController.getState().cacheTransformer;\n          //   if (transformer == null) {\n          //     for (const entry of item.headers) {\n          //       payload.res.setHeader(entry[0], entry[1]);\n          //     }\n          //     payload.res.status(item.statusCode);\n          //     finished$ = new rx.Observable<void>(sub => {\n          //       item.body()\n          //         .on('end', () => {sub.next(); sub.complete(); })\n          //         .pipe(payload.res);\n          //     });\n          //   } else {\n          //     finished$ = rx.from(transformer(item.headers, payload.req.headers.host, item.body())).pipe(\n          //       op.take(1),\n          //       op.mergeMap(({readable, length}) => {\n          //         const lengthHeaderIdx = item.headers.findIndex(row => row[0] === 'content-length');\n          //         if (lengthHeaderIdx >= 0)\n          //           item.headers[lengthHeaderIdx][1] = '' + length;\n          //         for (const entry of item.headers) {\n          //           payload.res.setHeader(entry[0], entry[1]);\n          //         }\n          //         payload.res.status(item.statusCode);\n          //         return stream.promises.pipeline(\n          //           readable(), payload.res\n          //         );\n          //       })\n          //     );\n          //   }\n          // }\n\n          return rx.timer(5000, 5000).pipe(\n            // op.takeUntil(finished$),\n            // op.map(idx => {\n            //   const item = cacheController.getState().cacheByUri.get(payload.key);\n            //   httpProxyLog.info(`${chalk.blue(payload.key)} [${typeof item === 'string' ? item : 'cached'}] has been processed for ${chalk.yellow((idx + 1) * 5 + 's')}`);\n            //   return item;\n            // }),\n            op.count(),\n            op.tap(() => httpProxyLog.info(`${chalk.green(payload.key)} is finished`)),\n            op.timeout(60000),\n            op.catchError((err) => {\n              httpProxyLog.error('Failed to write response', err);\n              return rx.EMPTY;\n            })\n          );\n        }, 5)\n      ),\n      actions._loadFromStorage.pipe(\n        // op.mergeMap(async ({payload}) => {\n        //   try {\n        //     const dir = Path.join(cacheController.getState().cacheDir, payload.key);\n        //     const hFile = Path.join(dir, 'header.json');\n        //     const bFile = Path.join(dir, 'body');\n        //     if (fs.existsSync(hFile)) {\n        //       httpProxyLog.info('load', payload.key);\n        //       const transformer = cacheController.getState().cacheTransformer;\n        //       if (transformer == null) {\n        //         const headersStr = await fs.promises.readFile(hFile, 'utf-8');\n        //         const {statusCode, headers} = JSON.parse(headersStr) as {statusCode: number; headers: [string, string | string[]][]};\n\n        //         dispatcher._done({key: payload.key, res: payload.res,\n        //           data: {\n        //             statusCode,\n        //             headers,\n        //             body: () => fs.createReadStream(bFile)\n        //           }});\n        //         return;\n        //       }\n\n        //       const headersStr = await fs.promises.readFile(hFile, 'utf-8');\n        //       const {statusCode, headers} = JSON.parse(headersStr) as {statusCode: number; headers: [string, string | string[]][]};\n        //       const {readable, length} = await transformer(headers, payload.req.headers.host, fs.createReadStream(bFile));\n        //       const lengthHeaderIdx = headers.findIndex(row => row[0] === 'content-length');\n        //       if (lengthHeaderIdx >= 0)\n        //         headers[lengthHeaderIdx][1] = '' + length;\n\n        //       dispatcher._done({key: payload.key,\n        //         res: payload.res,\n        //         data: {\n        //           statusCode,\n        //           headers,\n        //           body: readable\n        //         }});\n        //     } else {\n        //       httpProxyLog.info('No existing file for', payload.key);\n        //       dispatcher._requestRemote(payload);\n        //     }\n        //   } catch (ex) {\n        //     httpProxyLog.error('Failed to save cache for: ' + payload.key, ex);\n        //     dispatcher._clean(payload.key);\n        //   }\n        // })\n      ),\n      actions._requestRemote.pipe(\n        op.mergeMap(({payload}) => {\n          const proxyOpts: ServerOptions = {};\n          if (payload.target) {\n            proxyOpts.target = payload.target;\n            proxyOpts.ignorePath = true;\n          }\n          return rx.defer(() => {\n            // cacheController.getState().proxy.web(payload.req, payload.res, proxyOpts);\n            return observeProxyResponse(proxy$, payload.res);\n          }).pipe(\n            // op.mergeMap(({payload: [proxyRes, _req, res]}) => {\n            //   return requestingRemote(payload.key, payload.req.headers.host, proxyRes, res,\n            //     Object.entries(proxyRes.headers).filter(entry => entry[1] != null) as [string, string | string[]][]);\n            // }),\n            op.catchError(err => {\n              httpProxyLog.warn(`Retry \"${payload.req.url}\"`, err);\n              return rx.timer(1000).pipe(\n                op.mapTo(rx.throwError(err))\n              );\n            }),\n            op.retry(3)\n          );\n        })\n      ),\n      proxy$.proxyReq.pipe(\n        op.tap(({payload: [proxyReq, req, res, opts]}) => {\n          const target = opts.target as url.Url;\n          httpProxyLog.info('Request', target.hostname, target.pathname);\n        })\n      ),\n      proxy$.econnreset.pipe(\n        op.tap(({payload: [err]}) => {\n          httpProxyLog.info('econnreset', err);\n        })\n      )\n    ).pipe(\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      op.ignoreElements(),\n      op.catchError((err, src) => {\n        httpProxyLog.error('HTTP proxy cache error', err);\n        return src;\n      })\n    );\n  });\n\n  return cacheController;\n}\n\nexport function keyOfUri(method: string, path: string) {\n  const url = new URL('http://f.com' + path);\n  const key = method + url.pathname + (url.search ? '/' + _.trimStart(url.search, '?') : '');\n  return key;\n}\n"]}