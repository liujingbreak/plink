"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.test = exports.parse = exports.loop = exports.isNotLa = exports.choice = exports.scope = exports.cmp = exports.splitActionByType = void 0;
const rx = __importStar(require("rxjs"));
const op = __importStar(require("rxjs/operators"));
const lang_reactive_ops_1 = require("./lang-reactive-ops");
const childStepActions = {
    process(payload) { },
    sucess(result) { },
    failed(reason) { }
};
function createDispatcher(action$) {
    const dispatcher = {};
    for (const type of Object.keys(childStepActions)) {
        dispatcher[type] = (arg1) => {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            action$.next({ type: type, payload: arg1 });
        };
    }
    return dispatcher;
}
function splitActionByType(action$) {
    const source = action$.pipe(op.share());
    const actionByType = {};
    for (const type of Object.keys(childStepActions)) {
        Object.defineProperty(actionByType, type, {
            get() {
                return source.pipe(op.filter(action => action.type === type));
            }
        });
    }
    return actionByType;
}
exports.splitActionByType = splitActionByType;
function createStep(interceptor) {
    const source = new rx.Subject();
    const dispatcher = createDispatcher(source);
    const actions = interceptor ? source.pipe(op.observeOn(rx.queueScheduler), interceptor()) :
        source.pipe(op.observeOn(rx.queueScheduler));
    return { dispatcher, actions };
}
/**
 * simplest comparison step
 * @param expectStr
 * @returns
 */
function cmp(...expectStr) {
    return (mr) => {
        const { dispatcher, actions } = createStep();
        const actionByType = splitActionByType(actions);
        let index = 0;
        let startPosition = -1;
        if (expectStr.length === 1 && typeof expectStr[0] === 'string' && expectStr[0].length > 1) {
            // console.log('here');
            expectStr = expectStr[0].split('');
        }
        let last = expectStr.length - 1;
        actionByType.process.pipe(op.tap(({ payload: { d: input, i: offset } }) => {
            if (startPosition === -1)
                startPosition = offset;
            let expect = expectStr[index];
            // console.log('compare @' + offset, input, 'with', this.expect);
            if (input === expect) {
                if (index < last) {
                    index++;
                }
                else {
                    index = 0;
                    dispatcher.sucess({ start: startPosition, end: offset + 1 });
                }
            }
            else {
                dispatcher.failed([`at offset ${offset}, expect: ${expect + ''}, got: ${input + ''}`]);
            }
        })).subscribe();
        return { dispatcher, actions };
    };
}
exports.cmp = cmp;
/** scope step */
function scope(name, stepFactories, opts) {
    return (mr) => {
        let onSuccessResultTransformer;
        if (opts)
            onSuccessResultTransformer = opts.onSuccess;
        const { dispatcher, actions } = createStep();
        const actionByType = splitActionByType(actions);
        const steps = stepFactories.map((fac) => fac(mr));
        let currStepIdx = 0;
        const last = steps.length - 1;
        let startPosition = -1;
        let currPosition = -1;
        const stepResults = [];
        const subscribeStep = () => {
            const step = steps[currStepIdx];
            const childStepActions = splitActionByType(step.actions);
            rx.merge(rx.merge(childStepActions.sucess.pipe(op.map(({ payload }) => {
                stepResults.push(payload);
                if (currStepIdx < last) {
                    currStepIdx++;
                    subscribeStep();
                }
                else {
                    const result = {
                        name,
                        start: startPosition,
                        end: currPosition + 1,
                        children: stepResults
                    };
                    dispatcher.sucess(onSuccessResultTransformer ? onSuccessResultTransformer(result.children) : result);
                    return null;
                }
            })), childStepActions.failed.pipe(op.map(({ payload: reason }) => { dispatcher.failed([name, ...reason]); }))).pipe(op.take(1))).pipe(op.takeUntil(rx.merge(actionByType.sucess, actionByType.failed))).subscribe();
        };
        subscribeStep();
        actionByType.process.pipe(op.map(({ payload }) => {
            if (startPosition === -1)
                startPosition = payload.i;
            currPosition = payload.i;
            steps[currStepIdx].dispatcher.process(payload);
        })).pipe(op.takeUntil(rx.merge(actionByType.sucess, actionByType.failed))).subscribe();
        return { dispatcher, actions };
    };
}
exports.scope = scope;
/** Choice */
function choice(laNum = 2, ...choiceFactories) {
    return (mr) => {
        const { dispatcher, actions } = createStep();
        const failedChoiceResult = [];
        const choices = choiceFactories.map((fac, idx) => fac(mr));
        const actionByType = splitActionByType(actions);
        let currChoiceIdx = 0;
        let replayPos;
        actionByType.process.pipe(op.map(({ payload }) => {
            if (replayPos == null) {
                replayPos = payload.i;
                mr.mark(laNum);
            }
            choices[currChoiceIdx].dispatcher.process(payload);
        })).pipe(op.takeUntil(rx.merge(actionByType.sucess, actionByType.failed))).subscribe();
        const subscribeCurrentChoice = () => {
            const choiceActions = splitActionByType(choices[currChoiceIdx].actions);
            rx.merge().pipe(op.takeUntil(rx.merge(actionByType.sucess, actionByType.failed))).subscribe();
            choiceActions.sucess.pipe(op.tap(({ payload }) => {
                dispatcher.sucess(payload);
            }), op.take(1), op.takeUntil(rx.merge(actionByType.sucess, actionByType.failed))).subscribe();
            const last = choices.length - 1;
            choiceActions.failed.pipe(op.tap(({ payload }) => {
                failedChoiceResult.push(payload);
                if (currChoiceIdx < last) {
                    currChoiceIdx++;
                    subscribeCurrentChoice();
                    mr.replay(replayPos);
                }
                else {
                    dispatcher.failed(['None is matched: ' + failedChoiceResult.map(str => str.join(' - ')).join('; ')]);
                }
            }), op.take(1), op.takeUntil(rx.merge(actionByType.sucess, actionByType.failed))).subscribe();
        };
        subscribeCurrentChoice();
        return { dispatcher, actions };
    };
}
exports.choice = choice;
function isNotLa(step) {
    return (mr) => {
        const { dispatcher, actions } = createStep();
        const actionByType = splitActionByType(actions);
        const predicateStep = step(mr);
        const predActions = splitActionByType(predicateStep.actions);
        let startPos;
        let currPos;
        rx.merge(actionByType.process.pipe(op.take(1), op.map(({ payload: { d, i } }) => {
            startPos = i;
            mr.mark(Number.MAX_VALUE);
        })), actionByType.process.pipe(op.tap(({ payload }) => {
            currPos = payload.i;
            predicateStep.dispatcher.process(payload);
        })), predActions.failed.pipe(op.tap(() => {
            dispatcher.sucess({ start: startPos, end: currPos });
            mr.replay(startPos);
        }))).subscribe();
        return { dispatcher, actions };
    };
}
exports.isNotLa = isNotLa;
const defaultLoopOptions = { greedy: true, laNum: 2, minTimes: 0, maxTimes: Number.MAX_VALUE };
/** Loop */
function loop(factory, opts) {
    return (mr) => {
        const { dispatcher, actions } = createStep();
        let options;
        if (opts == null) {
            options = defaultLoopOptions;
        }
        else {
            options = Object.assign(Object.assign({}, defaultLoopOptions), opts);
        }
        const actionByType = splitActionByType(actions);
        let loopCount = 0;
        let currentLoopable;
        let markedPos;
        let startPosition = -1;
        let currPostion = -1;
        let loopResults = [];
        const markAtLoopableBegin = () => {
            actionByType.process.pipe(op.take(1), op.map(({ payload }) => {
                markedPos = payload.i;
                mr.mark(options.laNum);
            })).subscribe();
        };
        markAtLoopableBegin();
        const createNewLoopable = () => {
            currentLoopable = factory(mr);
            const childStepActions = splitActionByType(currentLoopable.actions);
            rx.merge(rx.merge(childStepActions.sucess.pipe(op.map(loopResult => {
                loopResults.push(loopResult.payload);
                loopCount++;
                if (loopCount < options.maxTimes) {
                    markAtLoopableBegin();
                    createNewLoopable();
                }
                else {
                    const result = {
                        start: startPosition,
                        end: currPostion + 1,
                        children: loopResults
                    };
                    dispatcher.sucess(result);
                }
            })), childStepActions.failed.pipe(op.map(({ payload: reason }) => {
                if (loopCount > options.minTimes) {
                    const result = {
                        start: startPosition,
                        end: markedPos,
                        children: loopResults
                    };
                    dispatcher.sucess(result);
                    mr.replay(markedPos);
                }
                else {
                    dispatcher.failed(reason);
                }
            }))).pipe(op.take(1))).pipe(op.takeUntil(rx.merge(actionByType.sucess, actionByType.failed))).subscribe();
        };
        createNewLoopable();
        actionByType.process.pipe(op.map(({ payload }) => {
            if (startPosition === -1) {
                startPosition = payload.i;
            }
            currPostion = payload.i;
            currentLoopable.dispatcher.process(payload);
        })).pipe(op.takeUntil(rx.merge(actionByType.sucess, actionByType.failed))).subscribe();
        return { dispatcher, actions };
    };
}
exports.loop = loop;
function parse(stateMachine, debug = false) {
    return (input$) => {
        return rx.defer(() => {
            const mark$ = new rx.Subject();
            const replay$ = new rx.Subject();
            const mr = {
                mark(laNum) {
                    mark$.next(laNum);
                },
                replay(pos) {
                    replay$.next(pos);
                }
            };
            const rootStep = stateMachine(mr);
            const actionByType = splitActionByType(rootStep.actions);
            return rx.merge(rx.merge(actionByType.sucess, actionByType.failed)
                .pipe(op.take(1)), debug ? rootStep.actions.pipe(
            // eslint-disable-next-line no-console
            op.tap(action => console.log('::', action)), op.ignoreElements()) : rx.EMPTY, 
            // input$ must be the last one being subscribed in merge list, otherwise other subscription night don't have change to 
            // observe emitted result after input$.pipe() has completed
            input$.pipe((0, lang_reactive_ops_1.cacheAndReplay)(mark$, replay$), op.map(({ value, idx }, totalIndex) => {
                if (debug) {
                    // eslint-disable-next-line no-console
                    console.log(`[${totalIndex}] offset:${idx}, value: ${'' + value}`);
                }
                rootStep.dispatcher.process({ d: value, i: idx });
            }), op.takeUntil(rx.merge(actionByType.sucess, actionByType.failed)), op.ignoreElements()));
        });
    };
}
exports.parse = parse;
function test() {
    rx.from('abcxdefdef1'.split('')).pipe(parse(scope('hellow', [
        cmp('ab'),
        choice(2, cmp('1x'), cmp('cx')),
        loop(scope('loop de', [cmp('def')])),
        cmp('1')
    ]), true), 
    // eslint-disable-next-line no-console
    op.tap(r => console.log('---> ', JSON.stringify(r, null, '  ')))).subscribe();
}
exports.test = test;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGFuZy1yZWNvZ2FuaXplci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImxhbmctcmVjb2dhbml6ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHlDQUEyQjtBQUMzQixtREFBcUM7QUFDckMsMkRBQW1EO0FBT25ELE1BQU0sZ0JBQWdCLEdBQUc7SUFDdkIsT0FBTyxDQUFDLE9BQTRCLElBQUcsQ0FBQztJQUN4QyxNQUFNLENBQXlCLE1BQVMsSUFBRyxDQUFDO0lBQzVDLE1BQU0sQ0FBQyxNQUFnQixJQUFHLENBQUM7Q0FDNUIsQ0FBQztBQW9CRixTQUFTLGdCQUFnQixDQUFDLE9BQTJCO0lBQ25ELE1BQU0sVUFBVSxHQUFHLEVBQTBFLENBQUM7SUFDOUYsS0FBSyxNQUFNLElBQUksSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUU7UUFDaEQsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBUyxFQUFFLEVBQUU7WUFDL0IsbUVBQW1FO1lBQ25FLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBQyxJQUFJLEVBQUUsSUFBcUMsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFDLENBQUMsQ0FBQztRQUM3RSxDQUFDLENBQUM7S0FDSDtJQUNELE9BQU8sVUFBVSxDQUFDO0FBQ3BCLENBQUM7QUFFRCxTQUFnQixpQkFBaUIsQ0FBQyxPQUE4QjtJQUM5RCxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0lBQ3hDLE1BQU0sWUFBWSxHQUFHLEVBQWtCLENBQUM7SUFDeEMsS0FBSyxNQUFNLElBQUksSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUU7UUFDaEQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxZQUFZLEVBQUUsSUFBSSxFQUFFO1lBQ3hDLEdBQUc7Z0JBQ0QsT0FBTyxNQUFNLENBQUMs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LENBQUMsQ0FDakUsQ0FBQyxTQUFTLEVBQUUsQ0FBQztBQUNoQixDQUFDO0FBWkQsb0JBWUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyByeCBmcm9tICdyeGpzJztcbmltcG9ydCAqIGFzIG9wIGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7Y2FjaGVBbmRSZXBsYXl9IGZyb20gJy4vbGFuZy1yZWFjdGl2ZS1vcHMnO1xuXG5pbnRlcmZhY2UgUG9zaXRpb25JbmZvIHtcbiAgc3RhcnQ6IG51bWJlcjtcbiAgZW5kOiBudW1iZXI7XG59XG5cbmNvbnN0IGNoaWxkU3RlcEFjdGlvbnMgPSB7XG4gIHByb2Nlc3MocGF5bG9hZDoge2Q6IGFueTsgaTogbnVtYmVyfSkge30sXG4gIHN1Y2VzczxSIGV4dGVuZHMgUG9zaXRpb25JbmZvPihyZXN1bHQ6IFIpIHt9LFxuICBmYWlsZWQocmVhc29uOiBzdHJpbmdbXSkge31cbn07XG5cbnR5cGUgTWFya0FuZFJlcGxheSA9IHtcbiAgbWFyayhsYU51bTogbnVtYmVyKTogdm9pZDtcbiAgcmVwbGF5KHBvc2l0aW9uOiBudW1iZXIpOiB2b2lkO1xufTtcblxudHlwZSBBY3Rpb24gPSB7XG4gIHR5cGU6IGtleW9mIHR5cGVvZiBjaGlsZFN0ZXBBY3Rpb25zO1xuICBwYXlsb2FkOiBQYXJhbWV0ZXJzPCh0eXBlb2YgY2hpbGRTdGVwQWN0aW9ucylba2V5b2YgdHlwZW9mIGNoaWxkU3RlcEFjdGlvbnNdPjtcbn07XG5cbnR5cGUgQWN0aW9uQnlUeXBlID0ge1xuICBbSyBpbiBrZXlvZiB0eXBlb2YgY2hpbGRTdGVwQWN0aW9uc106IHJ4Lk9ic2VydmFibGU8XG4gICAgKHR5cGVvZiBjaGlsZFN0ZXBBY3Rpb25zKVtLXSBleHRlbmRzIChwYXlsb2FkOiBpbmZlciBQKSA9PiB2b2lkID9cbiAgICAgIHtwYXlsb2FkOiBQOyB0eXBlOiBLfSA6XG4gICAgICB1bmtub3duXG4gICAgPlxufTtcblxuZnVuY3Rpb24gY3JlYXRlRGlzcGF0Y2hlcihhY3Rpb24kOiByeC5TdWJqZWN0PEFjdGlvbj4pIHtcbiAgY29uc3QgZGlzcGF0Y2hlciA9IHt9IGFzIHtbSyBpbiBrZXlvZiB0eXBlb2YgY2hpbGRTdGVwQWN0aW9uc106ICh0eXBlb2YgY2hpbGRTdGVwQWN0aW9ucylbS119O1xuICBmb3IgKGNvbnN0IHR5cGUgb2YgT2JqZWN0LmtleXMoY2hpbGRTdGVwQWN0aW9ucykpIHtcbiAgICBkaXNwYXRjaGVyW3R5cGVdID0gKGFyZzE6IGFueSkgPT4ge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgYWN0aW9uJC5uZXh0KHt0eXBlOiB0eXBlIGFzIGtleW9mIHR5cGVvZiBjaGlsZFN0ZXBBY3Rpb25zLCBwYXlsb2FkOiBhcmcxfSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZGlzcGF0Y2hlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0QWN0aW9uQnlUeXBlKGFjdGlvbiQ6IHJ4Lk9ic2VydmFibGU8QWN0aW9uPik6IEFjdGlvbkJ5VHlwZSB7XG4gIGNvbnN0IHNvdXJjZSA9IGFjdGlvbiQucGlwZShvcC5zaGFyZSgpKTtcbiAgY29uc3QgYWN0aW9uQnlUeXBlID0ge30gYXMgQWN0aW9uQnlUeXBlO1xuICBmb3IgKGNvbnN0IHR5cGUgb2YgT2JqZWN0LmtleXMoY2hpbGRTdGVwQWN0aW9ucykpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYWN0aW9uQnlUeXBlLCB0eXBlLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UucGlwZShvcC5maWx0ZXIoYWN0aW9uID0+IGFjdGlvbi50eXBlID09PSB0eXBlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGFjdGlvbkJ5VHlwZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3RlcDxUPihpbnRlcmNlcHRvcj86ICgpID0+IHJ4Lk9wZXJhdG9yRnVuY3Rpb248QWN0aW9uLCBBY3Rpb24+KSB7XG4gIGNvbnN0IHNvdXJjZSA9IG5ldyByeC5TdWJqZWN0PEFjdGlvbj4oKTtcbiAgY29uc3QgZGlzcGF0Y2hlciA9IGNyZWF0ZURpc3BhdGNoZXIoc291cmNlKTtcbiAgY29uc3QgYWN0aW9ucyA9IGludGVyY2VwdG9yID8gc291cmNlLnBpcGUob3Aub2JzZXJ2ZU9uKHJ4LnF1ZXVlU2NoZWR1bGVyKSwgaW50ZXJjZXB0b3IoKSkgOlxuICAgICAgc291cmNlLnBpcGUob3Aub2JzZXJ2ZU9uKHJ4LnF1ZXVlU2NoZWR1bGVyKSk7XG4gIHJldHVybiB7ZGlzcGF0Y2hlciwgYWN0aW9uc307XG59XG5cbnR5cGUgU3RlcEZhY3RvcnkgPSAobXI6IE1hcmtBbmRSZXBsYXkpID0+IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZVN0ZXA+O1xuXG4vKipcbiAqIHNpbXBsZXN0IGNvbXBhcmlzb24gc3RlcFxuICogQHBhcmFtIGV4cGVjdFN0ciBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gY21wPFQ+KC4uLmV4cGVjdFN0cjogVFtdKSB7XG4gIHJldHVybiAobXI6IE1hcmtBbmRSZXBsYXkpID0+IHtcbiAgICBjb25zdCB7ZGlzcGF0Y2hlciwgYWN0aW9uc30gPSBjcmVhdGVTdGVwKCk7XG4gICAgY29uc3QgYWN0aW9uQnlUeXBlID0gc3BsaXRBY3Rpb25CeVR5cGUoYWN0aW9ucyk7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBsZXQgc3RhcnRQb3NpdGlvbiA9IC0xO1xuICAgIGlmIChleHBlY3RTdHIubGVuZ3RoID09PSAxICYmIHR5cGVvZiBleHBlY3RTdHJbMF0gPT09ICdzdHJpbmcnICYmIChleHBlY3RTdHJbMF0gYXMgdW5rbm93biBhcyBzdHJpbmcpLmxlbmd0aCA+IDEgKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnaGVyZScpO1xuICAgICAgZXhwZWN0U3RyID0gKGV4cGVjdFN0clswXSBhcyB1bmtub3duIGFzIHN0cmluZykuc3BsaXQoJycpIGFzIHVua25vd24gYXMgVFtdO1xuICAgIH1cblxuICAgIGxldCBsYXN0ID0gZXhwZWN0U3RyLmxlbmd0aCAtIDE7XG4gICAgYWN0aW9uQnlUeXBlLnByb2Nlc3MucGlwZShcbiAgICAgIG9wLnRhcCgoe3BheWxvYWQ6IHtkOiBpbnB1dCwgaTogb2Zmc2V0fX0pID0+IHtcbiAgICAgICAgaWYgKHN0YXJ0UG9zaXRpb24gPT09IC0xKVxuICAgICAgICAgIHN0YXJ0UG9zaXRpb24gPSBvZmZzZXQ7XG4gICAgICAgIGxldCBleHBlY3QgPSBleHBlY3RTdHJbaW5kZXhdO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnY29tcGFyZSBAJyArIG9mZnNldCwgaW5wdXQsICd3aXRoJywgdGhpcy5leHBlY3QpO1xuICAgICAgICBpZiAoaW5wdXQgPT09IGV4cGVjdCkge1xuICAgICAgICAgIGlmIChpbmRleCA8IGxhc3QpIHtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIuc3VjZXNzKHtzdGFydDogc3RhcnRQb3NpdGlvbiwgZW5kOiBvZmZzZXQgKyAxfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpc3BhdGNoZXIuZmFpbGVkKFtgYXQgb2Zmc2V0ICR7b2Zmc2V0fSwgZXhwZWN0OiAke2V4cGVjdCArICcnfSwgZ290OiAke2lucHV0ICsgJyd9YF0pO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICkuc3Vic2NyaWJlKCk7XG4gICAgcmV0dXJuIHtkaXNwYXRjaGVyLCBhY3Rpb25zfTtcbiAgfTtcbn1cblxudHlwZSBTY29wZVJlc3VsdCA9IFBvc2l0aW9uSW5mbyAmIHtuYW1lOiBzdHJpbmc7IGNoaWxkcmVuOiBQb3NpdGlvbkluZm9bXX07XG4vKiogc2NvcGUgc3RlcCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjb3BlPFQ+KG5hbWU6IHN0cmluZywgc3RlcEZhY3RvcmllczogKFN0ZXBGYWN0b3J5KVtdLFxuICBvcHRzPzoge29uU3VjY2VzcyhjaGlsZHJlbjogUG9zaXRpb25JbmZvW10pOiBhbnl9KTogU3RlcEZhY3Rvcnkge1xuICByZXR1cm4gKG1yOiBNYXJrQW5kUmVwbGF5KSA9PiB7XG4gICAgbGV0IG9uU3VjY2Vzc1Jlc3VsdFRyYW5zZm9ybWVyOiB1bmRlZmluZWQgfCAoKGNoaWxkcmVuOiBQb3NpdGlvbkluZm9bXSkgPT4gYW55KTtcbiAgICBpZiAob3B0cylcbiAgICAgIG9uU3VjY2Vzc1Jlc3VsdFRyYW5zZm9ybWVyID0gb3B0cy5vblN1Y2Nlc3M7XG4gICAgY29uc3Qge2Rpc3BhdGNoZXIsIGFjdGlvbnN9ID0gY3JlYXRlU3RlcCgpO1xuICAgIGNvbnN0IGFjdGlvbkJ5VHlwZSA9IHNwbGl0QWN0aW9uQnlUeXBlKGFjdGlvbnMpO1xuICAgIGNvbnN0IHN0ZXBzID0gc3RlcEZhY3Rvcmllcy5tYXAoKGZhYykgPT4gZmFjKG1yKSk7XG4gICAgbGV0IGN1cnJTdGVwSWR4ID0gMDtcbiAgICBjb25zdCBsYXN0ID0gc3RlcHMubGVuZ3RoIC0gMTtcbiAgICBsZXQgc3RhcnRQb3NpdGlvbiA9IC0xO1xuICAgIGxldCBjdXJyUG9zaXRpb24gPSAtMTtcbiAgICBjb25zdCBzdGVwUmVzdWx0cyA9IFtdIGFzIFBvc2l0aW9uSW5mb1tdO1xuXG4gICAgY29uc3Qgc3Vic2NyaWJlU3RlcCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHN0ZXAgPSBzdGVwc1tjdXJyU3RlcElkeF07XG4gICAgICBjb25zdCBjaGlsZFN0ZXBBY3Rpb25zID0gc3BsaXRBY3Rpb25CeVR5cGUoc3RlcC5hY3Rpb25zKTtcbiAgICAgIHJ4Lm1lcmdlKFxuICAgICAgICByeC5tZXJnZShcbiAgICAgICAgICBjaGlsZFN0ZXBBY3Rpb25zLnN1Y2Vzcy5waXBlKFxuICAgICAgICAgICAgb3AubWFwKCh7cGF5bG9hZH0pID0+IHtcbiAgICAgICAgICAgICAgc3RlcFJlc3VsdHMucHVzaChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgaWYgKGN1cnJTdGVwSWR4IDwgbGFzdCkge1xuICAgICAgICAgICAgICAgIGN1cnJTdGVwSWR4Kys7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlU3RlcCgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdDogU2NvcGVSZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICBlbmQ6IGN1cnJQb3NpdGlvbiArIDEsXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogc3RlcFJlc3VsdHNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoZXIuc3VjZXNzKG9uU3VjY2Vzc1Jlc3VsdFRyYW5zZm9ybWVyID8gb25TdWNjZXNzUmVzdWx0VHJhbnNmb3JtZXIocmVzdWx0LmNoaWxkcmVuKSA6IHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKSxcbiAgICAgICAgICBjaGlsZFN0ZXBBY3Rpb25zLmZhaWxlZC5waXBlKFxuICAgICAgICAgICAgb3AubWFwKCh7cGF5bG9hZDogcmVhc29ufSkgPT4ge2Rpc3BhdGNoZXIuZmFpbGVkKFtuYW1lLCAuLi5yZWFzb25dKTsgfSlcbiAgICAgICAgICApXG4gICAgICAgICkucGlwZShvcC50YWtlKDEpKVxuICAgICAgKS5waXBlKFxuICAgICAgICBvcC50YWtlVW50aWwocngubWVyZ2UoYWN0aW9uQnlUeXBlLnN1Y2VzcywgYWN0aW9uQnlUeXBlLmZhaWxlZCkpXG4gICAgICApLnN1YnNjcmliZSgpO1xuICAgIH07XG5cbiAgICBzdWJzY3JpYmVTdGVwKCk7XG5cbiAgICBhY3Rpb25CeVR5cGUucHJvY2Vzcy5waXBlKFxuICAgICAgb3AubWFwKCh7cGF5bG9hZH0pID0+IHtcbiAgICAgICAgaWYgKHN0YXJ0UG9zaXRpb24gPT09IC0xKVxuICAgICAgICAgIHN0YXJ0UG9zaXRpb24gPSBwYXlsb2FkLmk7XG4gICAgICAgIGN1cnJQb3NpdGlvbiA9IHBheWxvYWQuaTtcbiAgICAgICAgc3RlcHNbY3VyclN0ZXBJZHhdLmRpc3BhdGNoZXIucHJvY2VzcyhwYXlsb2FkKTtcbiAgICAgIH0pXG4gICAgKS5waXBlKFxuICAgICAgb3AudGFrZVVudGlsKHJ4Lm1lcmdlKGFjdGlvbkJ5VHlwZS5zdWNlc3MsIGFjdGlvbkJ5VHlwZS5mYWlsZWQpKVxuICAgICkuc3Vic2NyaWJlKCk7XG5cbiAgICByZXR1cm4ge2Rpc3BhdGNoZXIsIGFjdGlvbnN9O1xuICB9O1xufVxuXG5cbi8qKiBDaG9pY2UgKi9cbmV4cG9ydCBmdW5jdGlvbiBjaG9pY2UobGFOdW0gPSAyLCAuLi5jaG9pY2VGYWN0b3JpZXM6IChTdGVwRmFjdG9yeSlbXSkge1xuICByZXR1cm4gKG1yOiBNYXJrQW5kUmVwbGF5KSA9PiB7XG4gICAgY29uc3Qge2Rpc3BhdGNoZXIsIGFjdGlvbnN9ID0gY3JlYXRlU3RlcCgpO1xuICAgIGNvbnN0IGZhaWxlZENob2ljZVJlc3VsdCA9IFtdIGFzIHN0cmluZ1tdW107XG4gICAgY29uc3QgY2hvaWNlcyA9IGNob2ljZUZhY3Rvcmllcy5tYXAoKGZhYywgaWR4KSA9PiBmYWMobXIpKTtcbiAgICBjb25zdCBhY3Rpb25CeVR5cGUgPSBzcGxpdEFjdGlvbkJ5VHlwZShhY3Rpb25zKTtcbiAgICBsZXQgY3VyckNob2ljZUlkeCA9IDA7XG4gICAgbGV0IHJlcGxheVBvczogbnVtYmVyO1xuXG4gICAgYWN0aW9uQnlUeXBlLnByb2Nlc3MucGlwZShcbiAgICAgIG9wLm1hcCgoe3BheWxvYWR9KSA9PiB7XG4gICAgICAgIGlmIChyZXBsYXlQb3MgPT0gbnVsbCkge1xuICAgICAgICAgIHJlcGxheVBvcyA9IHBheWxvYWQuaTtcbiAgICAgICAgICBtci5tYXJrKGxhTnVtKTtcbiAgICAgICAgfVxuICAgICAgICBjaG9pY2VzW2N1cnJDaG9pY2VJZHhdLmRpc3BhdGNoZXIucHJvY2VzcyhwYXlsb2FkKTtcbiAgICAgIH0pXG4gICAgKS5waXBlKFxuICAgICAgb3AudGFrZVVudGlsKHJ4Lm1lcmdlKGFjdGlvbkJ5VHlwZS5zdWNlc3MsIGFjdGlvbkJ5VHlwZS5mYWlsZWQpKVxuICAgICkuc3Vic2NyaWJlKCk7XG5cbiAgICBjb25zdCBzdWJzY3JpYmVDdXJyZW50Q2hvaWNlID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2hvaWNlQWN0aW9ucyA9IHNwbGl0QWN0aW9uQnlUeXBlKGNob2ljZXNbY3VyckNob2ljZUlkeF0uYWN0aW9ucyk7XG5cbiAgICAgIHJ4Lm1lcmdlKFxuICAgICAgKS5waXBlKFxuICAgICAgICBvcC50YWtlVW50aWwocngubWVyZ2UoYWN0aW9uQnlUeXBlLnN1Y2VzcywgYWN0aW9uQnlUeXBlLmZhaWxlZCkpXG4gICAgICApLnN1YnNjcmliZSgpO1xuXG4gICAgICBjaG9pY2VBY3Rpb25zLnN1Y2Vzcy5waXBlKFxuICAgICAgICBvcC50YXAoKHtwYXlsb2FkfSkgPT4ge1xuICAgICAgICAgIGRpc3BhdGNoZXIuc3VjZXNzKHBheWxvYWQpO1xuICAgICAgICB9KSxcbiAgICAgICAgb3AudGFrZSgxKSxcbiAgICAgICAgb3AudGFrZVVudGlsKHJ4Lm1lcmdlKGFjdGlvbkJ5VHlwZS5zdWNlc3MsIGFjdGlvbkJ5VHlwZS5mYWlsZWQpKVxuICAgICAgKS5zdWJzY3JpYmUoKTtcblxuICAgICAgY29uc3QgbGFzdCA9IGNob2ljZXMubGVuZ3RoIC0gMTtcbiAgICAgIGNob2ljZUFjdGlvbnMuZmFpbGVkLnBpcGUoXG4gICAgICAgIG9wLnRhcCgoe3BheWxvYWR9KSA9PiB7XG4gICAgICAgICAgZmFpbGVkQ2hvaWNlUmVzdWx0LnB1c2gocGF5bG9hZCk7XG4gICAgICAgICAgaWYgKGN1cnJDaG9pY2VJZHggPCBsYXN0KSB7XG4gICAgICAgICAgICBjdXJyQ2hvaWNlSWR4Kys7XG4gICAgICAgICAgICBzdWJzY3JpYmVDdXJyZW50Q2hvaWNlKCk7XG4gICAgICAgICAgICBtci5yZXBsYXkocmVwbGF5UG9zKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5mYWlsZWQoWydOb25lIGlzIG1hdGNoZWQ6ICcgKyBmYWlsZWRDaG9pY2VSZXN1bHQubWFwKHN0ciA9PiBzdHIuam9pbignIC0gJykpLmpvaW4oJzsgJyldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBvcC50YWtlKDEpLFxuICAgICAgICBvcC50YWtlVW50aWwocngubWVyZ2UoYWN0aW9uQnlUeXBlLnN1Y2VzcywgYWN0aW9uQnlUeXBlLmZhaWxlZCkpXG4gICAgICApLnN1YnNjcmliZSgpO1xuICAgIH07XG5cbiAgICBzdWJzY3JpYmVDdXJyZW50Q2hvaWNlKCk7XG4gICAgcmV0dXJuIHtkaXNwYXRjaGVyLCBhY3Rpb25zfTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTm90TGEoc3RlcDogU3RlcEZhY3RvcnkpIHtcbiAgcmV0dXJuIChtcjogTWFya0FuZFJlcGxheSkgPT4ge1xuICAgIGNvbnN0IHtkaXNwYXRjaGVyLCBhY3Rpb25zfSA9IGNyZWF0ZVN0ZXAoKTtcbiAgICBjb25zdCBhY3Rpb25CeVR5cGUgPSBzcGxpdEFjdGlvbkJ5VHlwZShhY3Rpb25zKTtcbiAgICBjb25zdCBwcmVkaWNhdGVTdGVwID0gc3RlcChtcik7XG4gICAgY29uc3QgcHJlZEFjdGlvbnMgPSBzcGxpdEFjdGlvbkJ5VHlwZShwcmVkaWNhdGVTdGVwLmFjdGlvbnMpO1xuICAgIGxldCBzdGFydFBvczogbnVtYmVyO1xuICAgIGxldCBjdXJyUG9zOiBudW1iZXI7XG5cbiAgICByeC5tZXJnZShcbiAgICAgIGFjdGlvbkJ5VHlwZS5wcm9jZXNzLnBpcGUoXG4gICAgICAgIG9wLnRha2UoMSksXG4gICAgICAgIG9wLm1hcCgoe3BheWxvYWQ6IHtkLCBpfX0pID0+IHtcbiAgICAgICAgICBzdGFydFBvcyA9IGk7XG4gICAgICAgICAgbXIubWFyayhOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICBhY3Rpb25CeVR5cGUucHJvY2Vzcy5waXBlKFxuICAgICAgICBvcC50YXAoKHtwYXlsb2FkfSkgPT4ge1xuICAgICAgICAgIGN1cnJQb3MgPSBwYXlsb2FkLmk7XG4gICAgICAgICAgcHJlZGljYXRlU3RlcC5kaXNwYXRjaGVyLnByb2Nlc3MocGF5bG9hZCk7XG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgcHJlZEFjdGlvbnMuZmFpbGVkLnBpcGUoXG4gICAgICAgIG9wLnRhcCgoKSA9PiB7XG4gICAgICAgICAgZGlzcGF0Y2hlci5zdWNlc3Moe3N0YXJ0OiBzdGFydFBvcywgZW5kOiBjdXJyUG9zfSk7XG4gICAgICAgICAgbXIucmVwbGF5KHN0YXJ0UG9zKTtcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApLnN1YnNjcmliZSgpO1xuICAgIHJldHVybiB7ZGlzcGF0Y2hlciwgYWN0aW9uc307XG4gIH07XG59XG5cbmludGVyZmFjZSBMb29wT3B0aW9ucyB7XG4gIGxhTnVtPzogbnVtYmVyO1xuICAvKiogZGVmYXVsdCBpcyB0cnVlICovXG4gIGdyZWVkeT86IGJvb2xlYW47XG4gIG1pblRpbWVzPzogbnVtYmVyO1xuICBtYXhUaW1lcz86IG51bWJlcjtcbn1cblxuY29uc3QgZGVmYXVsdExvb3BPcHRpb25zID0ge2dyZWVkeTogdHJ1ZSwgbGFOdW06IDIsIG1pblRpbWVzOiAwLCBtYXhUaW1lczogTnVtYmVyLk1BWF9WQUxVRX07XG5cbi8qKiBMb29wICovXG5leHBvcnQgZnVuY3Rpb24gbG9vcChmYWN0b3J5OiBTdGVwRmFjdG9yeSwgb3B0cz86IExvb3BPcHRpb25zKSB7XG4gIHJldHVybiAobXI6IE1hcmtBbmRSZXBsYXkpID0+IHtcbiAgICBjb25zdCB7ZGlzcGF0Y2hlciwgYWN0aW9uc30gPSBjcmVhdGVTdGVwKCk7XG4gICAgbGV0IG9wdGlvbnM6IFJlcXVpcmVkPExvb3BPcHRpb25zPjtcbiAgICBpZiAob3B0cyA9PSBudWxsKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdExvb3BPcHRpb25zO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0gey4uLmRlZmF1bHRMb29wT3B0aW9ucywgLi4ub3B0c307XG4gICAgfVxuICAgIGNvbnN0IGFjdGlvbkJ5VHlwZSA9IHNwbGl0QWN0aW9uQnlUeXBlKGFjdGlvbnMpO1xuICAgIGxldCBsb29wQ291bnQgPSAwO1xuICAgIGxldCBjdXJyZW50TG9vcGFibGU6IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZVN0ZXA+O1xuICAgIGxldCBtYXJrZWRQb3M6IG51bWJlcjtcbiAgICBsZXQgc3RhcnRQb3NpdGlvbiA9IC0xO1xuICAgIGxldCBjdXJyUG9zdGlvbiA9IC0xO1xuICAgIGxldCBsb29wUmVzdWx0cyA9IFtdIGFzIFBvc2l0aW9uSW5mb1tdO1xuXG4gICAgY29uc3QgbWFya0F0TG9vcGFibGVCZWdpbiA9ICgpID0+IHtcbiAgICAgIGFjdGlvbkJ5VHlwZS5wcm9jZXNzLnBpcGUoXG4gICAgICAgIG9wLnRha2UoMSksXG4gICAgICAgIG9wLm1hcCgoe3BheWxvYWR9KSA9PiB7XG4gICAgICAgICAgbWFya2VkUG9zID0gcGF5bG9hZC5pO1xuICAgICAgICAgIG1yLm1hcmsob3B0aW9ucy5sYU51bSk7XG4gICAgICAgIH0pXG4gICAgICApLnN1YnNjcmliZSgpO1xuICAgIH07XG5cbiAgICBtYXJrQXRMb29wYWJsZUJlZ2luKCk7XG5cbiAgICBjb25zdCBjcmVhdGVOZXdMb29wYWJsZSA9ICgpID0+IHtcbiAgICAgIGN1cnJlbnRMb29wYWJsZSA9IGZhY3RvcnkobXIpO1xuICAgICAgY29uc3QgY2hpbGRTdGVwQWN0aW9ucyA9IHNwbGl0QWN0aW9uQnlUeXBlKGN1cnJlbnRMb29wYWJsZS5hY3Rpb25zKTtcbiAgICAgIHJ4Lm1lcmdlKFxuICAgICAgICByeC5tZXJnZShcbiAgICAgICAgICBjaGlsZFN0ZXBBY3Rpb25zLnN1Y2Vzcy5waXBlKFxuICAgICAgICAgICAgb3AubWFwKGxvb3BSZXN1bHQgPT4ge1xuICAgICAgICAgICAgICBsb29wUmVzdWx0cy5wdXNoKGxvb3BSZXN1bHQucGF5bG9hZCk7XG4gICAgICAgICAgICAgIGxvb3BDb3VudCsrO1xuICAgICAgICAgICAgICBpZiAobG9vcENvdW50IDwgb3B0aW9ucy5tYXhUaW1lcykge1xuICAgICAgICAgICAgICAgIG1hcmtBdExvb3BhYmxlQmVnaW4oKTtcbiAgICAgICAgICAgICAgICBjcmVhdGVOZXdMb29wYWJsZSgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdDogUG9zaXRpb25JbmZvID0ge1xuICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICBlbmQ6IGN1cnJQb3N0aW9uICsgMSxcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBsb29wUmVzdWx0c1xuICAgICAgICAgICAgICAgIH0gYXMgUG9zaXRpb25JbmZvO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoZXIuc3VjZXNzKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKSxcbiAgICAgICAgICBjaGlsZFN0ZXBBY3Rpb25zLmZhaWxlZC5waXBlKFxuICAgICAgICAgICAgb3AubWFwKCh7cGF5bG9hZDogcmVhc29ufSkgPT4ge1xuICAgICAgICAgICAgICBpZiAobG9vcENvdW50ID4gb3B0aW9ucy5taW5UaW1lcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdDogUG9zaXRpb25JbmZvID0ge1xuICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICBlbmQ6IG1hcmtlZFBvcyxcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBsb29wUmVzdWx0c1xuICAgICAgICAgICAgICAgIH0gYXMgUG9zaXRpb25JbmZvO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoZXIuc3VjZXNzKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgbXIucmVwbGF5KG1hcmtlZFBvcyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hlci5mYWlsZWQocmVhc29uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgICkucGlwZShvcC50YWtlKDEpKVxuICAgICAgKS5waXBlKFxuICAgICAgICBvcC50YWtlVW50aWwocngubWVyZ2UoYWN0aW9uQnlUeXBlLnN1Y2VzcywgYWN0aW9uQnlUeXBlLmZhaWxlZCkpXG4gICAgICApLnN1YnNjcmliZSgpO1xuICAgIH07XG5cbiAgICBjcmVhdGVOZXdMb29wYWJsZSgpO1xuXG4gICAgYWN0aW9uQnlUeXBlLnByb2Nlc3MucGlwZShcbiAgICAgIG9wLm1hcCgoe3BheWxvYWR9KSA9PiB7XG4gICAgICAgIGlmIChzdGFydFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgICAgIHN0YXJ0UG9zaXRpb24gPSBwYXlsb2FkLmk7XG4gICAgICAgIH1cbiAgICAgICAgY3VyclBvc3Rpb24gPSBwYXlsb2FkLmk7XG4gICAgICAgIGN1cnJlbnRMb29wYWJsZS5kaXNwYXRjaGVyLnByb2Nlc3MocGF5bG9hZCk7XG4gICAgICB9KVxuICAgICkucGlwZShcbiAgICAgIG9wLnRha2VVbnRpbChyeC5tZXJnZShhY3Rpb25CeVR5cGUuc3VjZXNzLCBhY3Rpb25CeVR5cGUuZmFpbGVkKSlcbiAgICApLnN1YnNjcmliZSgpO1xuICAgIHJldHVybiB7ZGlzcGF0Y2hlciwgYWN0aW9uc307XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZTxUPihzdGF0ZU1hY2hpbmU6IFN0ZXBGYWN0b3J5LCBkZWJ1ZyA9IGZhbHNlKSB7XG4gIHJldHVybiAoaW5wdXQkOiByeC5PYnNlcnZhYmxlPFQ+KSA9PiB7XG4gICAgcmV0dXJuIHJ4LmRlZmVyKCgpID0+IHtcbiAgICAgIGNvbnN0IG1hcmskID0gbmV3IHJ4LlN1YmplY3Q8bnVtYmVyPigpO1xuICAgICAgY29uc3QgcmVwbGF5JCA9IG5ldyByeC5TdWJqZWN0PG51bWJlcj4oKTtcbiAgICAgIGNvbnN0IG1yOiBNYXJrQW5kUmVwbGF5ID0ge1xuICAgICAgICBtYXJrKGxhTnVtOiBudW1iZXIpIHtcbiAgICAgICAgICBtYXJrJC5uZXh0KGxhTnVtKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVwbGF5KHBvczogbnVtYmVyKSB7XG4gICAgICAgICAgcmVwbGF5JC5uZXh0KHBvcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJvb3RTdGVwID0gc3RhdGVNYWNoaW5lKG1yKTtcbiAgICAgIGNvbnN0IGFjdGlvbkJ5VHlwZSA9IHNwbGl0QWN0aW9uQnlUeXBlKHJvb3RTdGVwLmFjdGlvbnMpO1xuXG4gICAgICByZXR1cm4gcngubWVyZ2UoXG4gICAgICAgIHJ4Lm1lcmdlKGFjdGlvbkJ5VHlwZS5zdWNlc3MsIGFjdGlvbkJ5VHlwZS5mYWlsZWQpXG4gICAgICAgICAgLnBpcGUoXG4gICAgICAgICAgICBvcC50YWtlKDEpXG4gICAgICAgICksXG5cbiAgICAgICAgZGVidWcgPyByb290U3RlcC5hY3Rpb25zLnBpcGUoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICBvcC50YXAoYWN0aW9uID0+IGNvbnNvbGUubG9nKCc6OicsIGFjdGlvbikpLFxuICAgICAgICAgIG9wLmlnbm9yZUVsZW1lbnRzKClcbiAgICAgICAgKSA6IHJ4LkVNUFRZLFxuXG4gICAgICAgIC8vIGlucHV0JCBtdXN0IGJlIHRoZSBsYXN0IG9uZSBiZWluZyBzdWJzY3JpYmVkIGluIG1lcmdlIGxpc3QsIG90aGVyd2lzZSBvdGhlciBzdWJzY3JpcHRpb24gbmlnaHQgZG9uJ3QgaGF2ZSBjaGFuZ2UgdG8gXG4gICAgICAgIC8vIG9ic2VydmUgZW1pdHRlZCByZXN1bHQgYWZ0ZXIgaW5wdXQkLnBpcGUoKSBoYXMgY29tcGxldGVkXG4gICAgICAgIGlucHV0JC5waXBlKFxuICAgICAgICAgIGNhY2hlQW5kUmVwbGF5KG1hcmskLCByZXBsYXkkKSxcbiAgICAgICAgICBvcC5tYXAoKHt2YWx1ZSwgaWR4fSwgdG90YWxJbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHt0b3RhbEluZGV4fV0gb2Zmc2V0OiR7aWR4fSwgdmFsdWU6ICR7JycgKyB2YWx1ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvb3RTdGVwLmRpc3BhdGNoZXIucHJvY2Vzcyh7ZDogdmFsdWUsIGk6IGlkeH0pO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIG9wLnRha2VVbnRpbChyeC5tZXJnZShhY3Rpb25CeVR5cGUuc3VjZXNzLCBhY3Rpb25CeVR5cGUuZmFpbGVkKSksXG4gICAgICAgICAgb3AuaWdub3JlRWxlbWVudHMoKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0pO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVzdCgpIHtcbiAgcnguZnJvbSgnYWJjeGRlZmRlZjEnLnNwbGl0KCcnKSkucGlwZShcbiAgICBwYXJzZShzY29wZSgnaGVsbG93JywgW1xuICAgICAgICBjbXAoJ2FiJyksXG4gICAgICAgIGNob2ljZSgyLCBjbXAoJzF4JyksIGNtcCgnY3gnKSksXG4gICAgICAgIGxvb3Aoc2NvcGUoJ2xvb3AgZGUnLCBbY21wKCdkZWYnKV0pKSxcbiAgICAgICAgY21wKCcxJylcbiAgICAgIF0pLCB0cnVlXG4gICAgKSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIG9wLnRhcChyID0+IGNvbnNvbGUubG9nKCctLS0+ICcsIEpTT04uc3RyaW5naWZ5KHIsIG51bGwsICcgICcpKSlcbiAgKS5zdWJzY3JpYmUoKTtcbn1cbiJdfQ==