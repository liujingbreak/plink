"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.test = exports.parse = exports.loop = exports.choice = exports.scope = exports.cmp = exports.splitActionByType = void 0;
const rx = __importStar(require("rxjs"));
const op = __importStar(require("rxjs/operators"));
const lang_reactive_ops_1 = require("./lang-reactive-ops");
const childStepActions = {
    mark(laNum) { },
    replay(position) { },
    // unmark() {},
    process(payload) { },
    sucess(result) { },
    failed(reason) { }
};
function createDispatcher(action$) {
    const dispatcher = {};
    for (const type of Object.keys(childStepActions)) {
        dispatcher[type] = (arg1) => {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            action$.next({ type: type, payload: arg1 });
        };
    }
    return dispatcher;
}
function splitActionByType(action$) {
    let sourceSub;
    let subscriberCnt = 0;
    const split$ = action$.pipe(
    // op.tap(action => console.log(action)),
    op.map(action => dispatchByType[action.type].next(action)));
    const dispatchByType = {};
    const actionByType = {};
    for (const type of Object.keys(childStepActions)) {
        const dispatcher = dispatchByType[type] = new rx.Subject();
        // eslint-disable-next-line no-loop-func
        actionByType[type] = rx.defer(() => {
            if (subscriberCnt++ === 0) {
                sourceSub = split$.subscribe();
            }
            return dispatcher;
        }).pipe(
        // eslint-disable-next-line no-loop-func
        op.finalize(() => {
            if (--subscriberCnt === 0) {
                sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
            }
        }));
    }
    return actionByType;
}
exports.splitActionByType = splitActionByType;
function createStep(interceptor) {
    const source = new rx.Subject();
    const dispatcher = createDispatcher(source);
    const actions = interceptor ? source.pipe(op.observeOn(rx.queueScheduler), interceptor()) :
        source.pipe(op.observeOn(rx.queueScheduler));
    return { dispatcher, actions };
}
/**
 * simplest comparison step
 * @param expectStr
 * @returns
 */
function cmp(...expectStr) {
    return () => {
        const { dispatcher, actions } = createStep();
        const actionByType = splitActionByType(actions);
        let index = 0;
        let startPosition = -1;
        if (expectStr.length === 1 && typeof expectStr[0] === 'string' && expectStr[0].length > 1) {
            // console.log('here');
            expectStr = expectStr[0].split('');
        }
        let last = expectStr.length - 1;
        actionByType.process.pipe(op.tap(({ payload: { d: input, i: offset } }) => {
            if (startPosition === -1)
                startPosition = offset;
            let expect = expectStr[index];
            // console.log('compare @' + offset, input, 'with', this.expect);
            if (input === expect) {
                if (index < last) {
                    index++;
                }
                else {
                    index = 0;
                    dispatcher.sucess({ start: startPosition, end: offset + 1 });
                }
            }
            else {
                dispatcher.failed([`at offset ${offset}, expect: ${expect + ''}, got: ${input + ''}`]);
            }
        })).subscribe();
        return { dispatcher, actions };
    };
}
exports.cmp = cmp;
/** scope step */
function scope(name, stepFactories, opts) {
    return () => {
        let onSuccessResultTransformer;
        if (opts)
            onSuccessResultTransformer = opts.onSuccess;
        const { dispatcher, actions } = createStep();
        const actionByType = splitActionByType(actions);
        const steps = stepFactories.map((fac) => fac());
        let currStepIdx = 0;
        const last = steps.length - 1;
        let startPosition = -1;
        let currPosition = -1;
        const stepResults = [];
        const subscribeStep = () => {
            const step = steps[currStepIdx];
            const childStepActions = splitActionByType(step.actions);
            rx.merge(rx.merge(childStepActions.sucess.pipe(op.map(({ payload }) => {
                stepResults.push(payload);
                if (currStepIdx < last) {
                    currStepIdx++;
                    subscribeStep();
                }
                else {
                    const result = {
                        name,
                        start: startPosition,
                        end: currPosition + 1,
                        children: stepResults
                    };
                    dispatcher.sucess(onSuccessResultTransformer ? onSuccessResultTransformer(result.children) : result);
                    return null;
                }
            })), childStepActions.failed.pipe(op.map(({ payload: reason }) => { dispatcher.failed([name, ...reason]); }))).pipe(op.take(1)), childStepActions.mark.pipe(op.tap(act => dispatcher.mark(act.payload))), childStepActions.replay.pipe(op.tap(act => dispatcher.replay(act.payload)))
            // childStepActions.unmark.pipe(op.tap(act => this.dispatcher.unmark()))
            ).pipe(op.takeUntil(rx.merge(actionByType.sucess, actionByType.failed))).subscribe();
        };
        subscribeStep();
        actionByType.process.pipe(op.map(({ payload }) => {
            if (startPosition === -1)
                startPosition = payload.i;
            currPosition = payload.i;
            steps[currStepIdx].dispatcher.process(payload);
        })).pipe(op.takeUntil(rx.merge(actionByType.sucess, actionByType.failed))).subscribe();
        return { dispatcher, actions };
    };
}
exports.scope = scope;
/** Choice */
function choice(laNum = 2, ...choiceFactories) {
    return () => {
        const { dispatcher, actions } = createStep();
        const failedChoiceResult = [];
        const choices = choiceFactories.map((fac, idx) => fac());
        const actionByType = splitActionByType(actions);
        let currChoiceIdx = 0;
        let replayPos;
        actionByType.process.pipe(op.map(({ payload }) => {
            if (replayPos == null) {
                replayPos = payload.i;
            }
            if (currChoiceIdx === 0) {
                dispatcher.mark(laNum);
            }
            choices[currChoiceIdx].dispatcher.process(payload);
        })).pipe(op.takeUntil(rx.merge(actionByType.sucess, actionByType.failed))).subscribe();
        const subscribeCurrentChoice = () => {
            const choiceActions = splitActionByType(choices[currChoiceIdx].actions);
            rx.merge(choiceActions.mark.pipe(op.tap(act => dispatcher.mark(act.payload))), choiceActions.replay.pipe(op.tap(act => dispatcher.replay(act.payload)))
            // choiceActions.unmark.pipe(op.tap(act => this.dispatcher.unmark()))
            ).pipe(op.takeUntil(rx.merge(actionByType.sucess, actionByType.failed))).subscribe();
            choiceActions.sucess.pipe(op.tap(({ payload }) => {
                // this.dispatcher.unmark();
                dispatcher.sucess(payload);
            }), op.take(1), op.takeUntil(rx.merge(actionByType.sucess, actionByType.failed))).subscribe();
            const last = choices.length - 1;
            choiceActions.failed.pipe(op.tap(({ payload }) => {
                failedChoiceResult.push(payload);
                if (currChoiceIdx < last) {
                    currChoiceIdx++;
                    subscribeCurrentChoice();
                    dispatcher.replay(replayPos);
                }
                else {
                    dispatcher.failed(['None is matched: ' + failedChoiceResult.map(str => str.join(' - ')).join('; ')]);
                }
            }), op.take(1), op.takeUntil(rx.merge(actionByType.sucess, actionByType.failed))).subscribe();
        };
        subscribeCurrentChoice();
        return { dispatcher, actions };
    };
}
exports.choice = choice;
const defaultLoopOptions = { greedy: true, laNum: 2, minTimes: 0, maxTimes: Number.MAX_VALUE };
/** Loop */
function loop(factory, opts) {
    return () => {
        const { dispatcher, actions } = createStep();
        let options;
        if (opts == null) {
            options = defaultLoopOptions;
        }
        else {
            options = Object.assign(Object.assign({}, defaultLoopOptions), opts);
        }
        const actionByType = splitActionByType(actions);
        let loopCount = 0;
        let currentLoopable;
        let markedPos;
        let startPosition = -1;
        let currPostion = -1;
        let loopResults = [];
        const markAtLoopableBegin = () => {
            actionByType.process.pipe(op.take(1), op.map(({ payload }) => {
                markedPos = payload.i;
                dispatcher.mark(options.laNum);
            })).subscribe();
        };
        markAtLoopableBegin();
        const createNewLoopable = () => {
            currentLoopable = factory();
            const childStepActions = splitActionByType(currentLoopable.actions);
            rx.merge(rx.merge(childStepActions.sucess.pipe(op.map(loopResult => {
                loopResults.push(loopResult.payload);
                loopCount++;
                if (loopCount < options.maxTimes) {
                    markAtLoopableBegin();
                    createNewLoopable();
                }
                else {
                    const result = {
                        start: startPosition,
                        end: currPostion + 1,
                        children: loopResults
                    };
                    dispatcher.sucess(result);
                }
            })), childStepActions.failed.pipe(op.map(({ payload: reason }) => {
                if (loopCount > options.minTimes) {
                    dispatcher.replay(markedPos);
                    const result = {
                        start: startPosition,
                        end: markedPos,
                        children: loopResults
                    };
                    dispatcher.sucess(result);
                }
                else {
                    dispatcher.failed(reason);
                }
            }))).pipe(op.take(1)), childStepActions.mark.pipe(op.tap(act => dispatcher.mark(act.payload))), childStepActions.replay.pipe(op.tap(act => dispatcher.replay(act.payload)))).pipe(op.takeUntil(rx.merge(actionByType.sucess, actionByType.failed))).subscribe();
        };
        createNewLoopable();
        actionByType.process.pipe(op.map(({ payload }) => {
            if (startPosition === -1) {
                startPosition = payload.i;
            }
            currPostion = payload.i;
            currentLoopable.dispatcher.process(payload);
        })).pipe(op.takeUntil(rx.merge(actionByType.sucess, actionByType.failed))).subscribe();
        return { dispatcher, actions };
    };
}
exports.loop = loop;
function parse(stateMachine, debug = false) {
    return (input$) => {
        return rx.defer(() => {
            const rootStep = stateMachine();
            const actionByType = splitActionByType(rootStep.actions);
            return rx.merge(rx.merge(actionByType.sucess, actionByType.failed)
                .pipe(op.take(1)), debug ? rootStep.actions.pipe(
            // eslint-disable-next-line no-console
            op.tap(action => console.log('::', action)), op.ignoreElements()) : rx.EMPTY, 
            // input$ must be the last one being subscribed in merge list, otherwise other subscription night don't have change to 
            // observe emitted result after input$.pipe() has completed
            input$.pipe((0, lang_reactive_ops_1.cacheAndReplay)(actionByType.mark.pipe(op.map(act => act.payload)), actionByType.replay.pipe(op.map(act => act.payload))), op.map(({ value, idx }, totalIndex) => {
                if (debug) {
                    // eslint-disable-next-line no-console
                    console.log(`[${totalIndex}] offset:${idx}, value: ${'' + value}`);
                }
                rootStep.dispatcher.process({ d: value, i: idx });
            }), op.takeUntil(rx.merge(actionByType.sucess, actionByType.failed)), op.ignoreElements()));
        });
    };
}
exports.parse = parse;
function test() {
    rx.from('abcxdefdef1'.split('')).pipe(parse(scope('hellow', [
        cmp('ab'),
        choice(2, cmp('1x'), cmp('cx')),
        loop(scope('loop de', [cmp('def')])),
        cmp('1')
    ]), true), 
    // eslint-disable-next-line no-console
    op.tap(r => console.log('---> ', JSON.stringify(r, null, '  ')))).subscribe();
}
exports.test = test;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGFuZy1yZWNvZ2FuaXplci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImxhbmctcmVjb2dhbml6ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHlDQUEyQjtBQUMzQixtREFBcUM7QUFDckMsMkRBQW1EO0FBT25ELE1BQU0sZ0JBQWdCLEdBQUc7SUFDdkIsSUFBSSxDQUFDLEtBQWEsSUFBRyxDQUFDO0lBQ3RCLE1BQU0sQ0FBQyxRQUFnQixJQUFHLENBQUM7SUFDM0IsZUFBZTtJQUNmLE9BQU8sQ0FBQyxPQUE0QixJQUFHLENBQUM7SUFDeEMsTUFBTSxDQUF5QixNQUFTLElBQUcsQ0FBQztJQUM1QyxNQUFNLENBQUMsTUFBZ0IsSUFBRyxDQUFDO0NBQzVCLENBQUM7QUFlRixTQUFTLGdCQUFnQixDQUFDLE9BQTJCO0lBQ25ELE1BQU0sVUFBVSxHQUFHLEVBQTBFLENBQUM7SUFDOUYsS0FBSyxNQUFNLElBQUksSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUU7UUFDaEQsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBUyxFQUFFLEVBQUU7WUFDL0IsbUVBQW1FO1lBQ25FLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBQyxJQUFJLEVBQUUsSUFBcUMsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFDLENBQUMsQ0FBQztRQUM3RSxDQUFDLENBQUM7S0FDSDtJQUNELE9BQU8sVUFBVSxDQUFDO0FBQ3BCLENBQUM7QUFFRCxTQUFnQixpQkFBaUIsQ0FBQyxPQUE4QjtJQUM5RCxJQUFJLFNBQXNDLENBQUM7SUFDM0MsSUFBSSxhQUFhLEdBQUcsQ0FBQyxDQUFDO0lBRXRCLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxJQUFJO0lBQ3pCLHlDQUF5QztJQUN6QyxFQUFFLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxJQUFJ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RyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUNqRSxDQUFDLFNBQVMsRUFBRSxDQUFDO0FBQ2hCLENBQUM7QUFaRCxvQkFZQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHJ4IGZyb20gJ3J4anMnO1xuaW1wb3J0ICogYXMgb3AgZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtjYWNoZUFuZFJlcGxheX0gZnJvbSAnLi9sYW5nLXJlYWN0aXZlLW9wcyc7XG5cbmludGVyZmFjZSBQb3NpdGlvbkluZm8ge1xuICBzdGFydDogbnVtYmVyO1xuICBlbmQ6IG51bWJlcjtcbn1cblxuY29uc3QgY2hpbGRTdGVwQWN0aW9ucyA9IHtcbiAgbWFyayhsYU51bTogbnVtYmVyKSB7fSxcbiAgcmVwbGF5KHBvc2l0aW9uOiBudW1iZXIpIHt9LFxuICAvLyB1bm1hcmsoKSB7fSxcbiAgcHJvY2VzcyhwYXlsb2FkOiB7ZDogYW55OyBpOiBudW1iZXJ9KSB7fSxcbiAgc3VjZXNzPFIgZXh0ZW5kcyBQb3NpdGlvbkluZm8+KHJlc3VsdDogUikge30sXG4gIGZhaWxlZChyZWFzb246IHN0cmluZ1tdKSB7fVxufTtcblxudHlwZSBBY3Rpb24gPSB7XG4gIHR5cGU6IGtleW9mIHR5cGVvZiBjaGlsZFN0ZXBBY3Rpb25zO1xuICBwYXlsb2FkOiBQYXJhbWV0ZXJzPCh0eXBlb2YgY2hpbGRTdGVwQWN0aW9ucylba2V5b2YgdHlwZW9mIGNoaWxkU3RlcEFjdGlvbnNdPjtcbn07XG5cbnR5cGUgQWN0aW9uQnlUeXBlID0ge1xuICBbSyBpbiBrZXlvZiB0eXBlb2YgY2hpbGRTdGVwQWN0aW9uc106IHJ4Lk9ic2VydmFibGU8XG4gICAgKHR5cGVvZiBjaGlsZFN0ZXBBY3Rpb25zKVtLXSBleHRlbmRzIChwYXlsb2FkOiBpbmZlciBQKSA9PiB2b2lkID9cbiAgICAgIHtwYXlsb2FkOiBQOyB0eXBlOiBLfSA6XG4gICAgICB1bmtub3duXG4gICAgPlxufTtcblxuZnVuY3Rpb24gY3JlYXRlRGlzcGF0Y2hlcihhY3Rpb24kOiByeC5TdWJqZWN0PEFjdGlvbj4pIHtcbiAgY29uc3QgZGlzcGF0Y2hlciA9IHt9IGFzIHtbSyBpbiBrZXlvZiB0eXBlb2YgY2hpbGRTdGVwQWN0aW9uc106ICh0eXBlb2YgY2hpbGRTdGVwQWN0aW9ucylbS119O1xuICBmb3IgKGNvbnN0IHR5cGUgb2YgT2JqZWN0LmtleXMoY2hpbGRTdGVwQWN0aW9ucykpIHtcbiAgICBkaXNwYXRjaGVyW3R5cGVdID0gKGFyZzE6IGFueSkgPT4ge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgYWN0aW9uJC5uZXh0KHt0eXBlOiB0eXBlIGFzIGtleW9mIHR5cGVvZiBjaGlsZFN0ZXBBY3Rpb25zLCBwYXlsb2FkOiBhcmcxfSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZGlzcGF0Y2hlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0QWN0aW9uQnlUeXBlKGFjdGlvbiQ6IHJ4Lk9ic2VydmFibGU8QWN0aW9uPikge1xuICBsZXQgc291cmNlU3ViOiByeC5TdWJzY3JpcHRpb24gfCB1bmRlZmluZWQ7XG4gIGxldCBzdWJzY3JpYmVyQ250ID0gMDtcblxuICBjb25zdCBzcGxpdCQgPSBhY3Rpb24kLnBpcGUoXG4gICAgLy8gb3AudGFwKGFjdGlvbiA9PiBjb25zb2xlLmxvZyhhY3Rpb24pKSxcbiAgICBvcC5tYXAoYWN0aW9uID0+IGRpc3BhdGNoQnlUeXBlW2FjdGlvbi50eXBlXSEubmV4dChhY3Rpb24pKVxuICApO1xuXG4gIGNvbnN0IGRpc3BhdGNoQnlUeXBlOiB7W0sgaW4ga2V5b2YgdHlwZW9mIGNoaWxkU3RlcEFjdGlvbnNdPzogcnguU3ViamVjdDxhbnk+fSA9IHt9O1xuICBjb25zdCBhY3Rpb25CeVR5cGU6IFBhcnRpYWw8QWN0aW9uQnlUeXBlPiA9IHt9O1xuXG4gIGZvciAoY29uc3QgdHlwZSBvZiBPYmplY3Qua2V5cyhjaGlsZFN0ZXBBY3Rpb25zKSkge1xuICAgIGNvbnN0IGRpc3BhdGNoZXIgPSBkaXNwYXRjaEJ5VHlwZVt0eXBlXSA9IG5ldyByeC5TdWJqZWN0KCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvb3AtZnVuY1xuICAgIGFjdGlvbkJ5VHlwZVt0eXBlXSA9IHJ4LmRlZmVyKCgpID0+IHtcbiAgICAgIGlmIChzdWJzY3JpYmVyQ250KysgPT09IDApIHtcbiAgICAgICAgc291cmNlU3ViID0gc3BsaXQkLnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRpc3BhdGNoZXI7XG4gICAgfSkucGlwZShcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgIG9wLmZpbmFsaXplKCgpID0+IHtcbiAgICAgICAgaWYgKC0tc3Vic2NyaWJlckNudCA9PT0gMCkge1xuICAgICAgICAgIHNvdXJjZVN1Yj8udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIHJldHVybiBhY3Rpb25CeVR5cGUgYXMgQWN0aW9uQnlUeXBlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTdGVwPFQ+KGludGVyY2VwdG9yPzogKCkgPT4gcnguT3BlcmF0b3JGdW5jdGlvbjxBY3Rpb24sIEFjdGlvbj4pIHtcbiAgY29uc3Qgc291cmNlID0gbmV3IHJ4LlN1YmplY3Q8QWN0aW9uPigpO1xuICBjb25zdCBkaXNwYXRjaGVyID0gY3JlYXRlRGlzcGF0Y2hlcihzb3VyY2UpO1xuICBjb25zdCBhY3Rpb25zID0gaW50ZXJjZXB0b3IgPyBzb3VyY2UucGlwZShvcC5vYnNlcnZlT24ocngucXVldWVTY2hlZHVsZXIpLCBpbnRlcmNlcHRvcigpKSA6XG4gICAgICBzb3VyY2UucGlwZShvcC5vYnNlcnZlT24ocngucXVldWVTY2hlZHVsZXIpKTtcbiAgcmV0dXJuIHtkaXNwYXRjaGVyLCBhY3Rpb25zfTtcbn1cblxudHlwZSBTdGVwRmFjdG9yeSA9ICgpID0+IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZVN0ZXA+O1xuXG4vKipcbiAqIHNpbXBsZXN0IGNvbXBhcmlzb24gc3RlcFxuICogQHBhcmFtIGV4cGVjdFN0ciBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gY21wPFQ+KC4uLmV4cGVjdFN0cjogVFtdKSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgY29uc3Qge2Rpc3BhdGNoZXIsIGFjdGlvbnN9ID0gY3JlYXRlU3RlcCgpO1xuICAgIGNvbnN0IGFjdGlvbkJ5VHlwZSA9IHNwbGl0QWN0aW9uQnlUeXBlKGFjdGlvbnMpO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgbGV0IHN0YXJ0UG9zaXRpb24gPSAtMTtcbiAgICBpZiAoZXhwZWN0U3RyLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZXhwZWN0U3RyWzBdID09PSAnc3RyaW5nJyAmJiAoZXhwZWN0U3RyWzBdIGFzIHVua25vd24gYXMgc3RyaW5nKS5sZW5ndGggPiAxICkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ2hlcmUnKTtcbiAgICAgIGV4cGVjdFN0ciA9IChleHBlY3RTdHJbMF0gYXMgdW5rbm93biBhcyBzdHJpbmcpLnNwbGl0KCcnKSBhcyB1bmtub3duIGFzIFRbXTtcbiAgICB9XG5cbiAgICBsZXQgbGFzdCA9IGV4cGVjdFN0ci5sZW5ndGggLSAxO1xuICAgIGFjdGlvbkJ5VHlwZS5wcm9jZXNzLnBpcGUoXG4gICAgICBvcC50YXAoKHtwYXlsb2FkOiB7ZDogaW5wdXQsIGk6IG9mZnNldH19KSA9PiB7XG4gICAgICAgIGlmIChzdGFydFBvc2l0aW9uID09PSAtMSlcbiAgICAgICAgICBzdGFydFBvc2l0aW9uID0gb2Zmc2V0O1xuICAgICAgICBsZXQgZXhwZWN0ID0gZXhwZWN0U3RyW2luZGV4XTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2NvbXBhcmUgQCcgKyBvZmZzZXQsIGlucHV0LCAnd2l0aCcsIHRoaXMuZXhwZWN0KTtcbiAgICAgICAgaWYgKGlucHV0ID09PSBleHBlY3QpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPCBsYXN0KSB7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAgICBkaXNwYXRjaGVyLnN1Y2Vzcyh7c3RhcnQ6IHN0YXJ0UG9zaXRpb24sIGVuZDogb2Zmc2V0ICsgMX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaXNwYXRjaGVyLmZhaWxlZChbYGF0IG9mZnNldCAke29mZnNldH0sIGV4cGVjdDogJHtleHBlY3QgKyAnJ30sIGdvdDogJHtpbnB1dCArICcnfWBdKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApLnN1YnNjcmliZSgpO1xuICAgIHJldHVybiB7ZGlzcGF0Y2hlciwgYWN0aW9uc307XG4gIH07XG59XG5cbnR5cGUgU2NvcGVSZXN1bHQgPSBQb3NpdGlvbkluZm8gJiB7bmFtZTogc3RyaW5nOyBjaGlsZHJlbjogUG9zaXRpb25JbmZvW119O1xuLyoqIHNjb3BlIHN0ZXAgKi9cbmV4cG9ydCBmdW5jdGlvbiBzY29wZTxUPihuYW1lOiBzdHJpbmcsIHN0ZXBGYWN0b3JpZXM6IChTdGVwRmFjdG9yeSlbXSxcbiAgb3B0cz86IHtvblN1Y2Nlc3MoY2hpbGRyZW46IFBvc2l0aW9uSW5mb1tdKTogYW55fSk6IFN0ZXBGYWN0b3J5IHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsZXQgb25TdWNjZXNzUmVzdWx0VHJhbnNmb3JtZXI6IHVuZGVmaW5lZCB8ICgoY2hpbGRyZW46IFBvc2l0aW9uSW5mb1tdKSA9PiBhbnkpO1xuICAgIGlmIChvcHRzKVxuICAgICAgb25TdWNjZXNzUmVzdWx0VHJhbnNmb3JtZXIgPSBvcHRzLm9uU3VjY2VzcztcbiAgICBjb25zdCB7ZGlzcGF0Y2hlciwgYWN0aW9uc30gPSBjcmVhdGVTdGVwKCk7XG4gICAgY29uc3QgYWN0aW9uQnlUeXBlID0gc3BsaXRBY3Rpb25CeVR5cGUoYWN0aW9ucyk7XG4gICAgY29uc3Qgc3RlcHMgPSBzdGVwRmFjdG9yaWVzLm1hcCgoZmFjKSA9PiBmYWMoKSk7XG4gICAgbGV0IGN1cnJTdGVwSWR4ID0gMDtcbiAgICBjb25zdCBsYXN0ID0gc3RlcHMubGVuZ3RoIC0gMTtcbiAgICBsZXQgc3RhcnRQb3NpdGlvbiA9IC0xO1xuICAgIGxldCBjdXJyUG9zaXRpb24gPSAtMTtcbiAgICBjb25zdCBzdGVwUmVzdWx0cyA9IFtdIGFzIFBvc2l0aW9uSW5mb1tdO1xuXG4gICAgY29uc3Qgc3Vic2NyaWJlU3RlcCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHN0ZXAgPSBzdGVwc1tjdXJyU3RlcElkeF07XG4gICAgICBjb25zdCBjaGlsZFN0ZXBBY3Rpb25zID0gc3BsaXRBY3Rpb25CeVR5cGUoc3RlcC5hY3Rpb25zKTtcbiAgICAgIHJ4Lm1lcmdlKFxuICAgICAgICByeC5tZXJnZShcbiAgICAgICAgICBjaGlsZFN0ZXBBY3Rpb25zLnN1Y2Vzcy5waXBlKFxuICAgICAgICAgICAgb3AubWFwKCh7cGF5bG9hZH0pID0+IHtcbiAgICAgICAgICAgICAgc3RlcFJlc3VsdHMucHVzaChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgaWYgKGN1cnJTdGVwSWR4IDwgbGFzdCkge1xuICAgICAgICAgICAgICAgIGN1cnJTdGVwSWR4Kys7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlU3RlcCgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdDogU2NvcGVSZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICBlbmQ6IGN1cnJQb3NpdGlvbiArIDEsXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogc3RlcFJlc3VsdHNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoZXIuc3VjZXNzKG9uU3VjY2Vzc1Jlc3VsdFRyYW5zZm9ybWVyID8gb25TdWNjZXNzUmVzdWx0VHJhbnNmb3JtZXIocmVzdWx0LmNoaWxkcmVuKSA6IHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKSxcbiAgICAgICAgICBjaGlsZFN0ZXBBY3Rpb25zLmZhaWxlZC5waXBlKFxuICAgICAgICAgICAgb3AubWFwKCh7cGF5bG9hZDogcmVhc29ufSkgPT4ge2Rpc3BhdGNoZXIuZmFpbGVkKFtuYW1lLCAuLi5yZWFzb25dKTsgfSlcbiAgICAgICAgICApXG4gICAgICAgICkucGlwZShvcC50YWtlKDEpKSxcbiAgICAgICAgY2hpbGRTdGVwQWN0aW9ucy5tYXJrLnBpcGUob3AudGFwKGFjdCA9PiBkaXNwYXRjaGVyLm1hcmsoYWN0LnBheWxvYWQpKSksXG4gICAgICAgIGNoaWxkU3RlcEFjdGlvbnMucmVwbGF5LnBpcGUob3AudGFwKGFjdCA9PiBkaXNwYXRjaGVyLnJlcGxheShhY3QucGF5bG9hZCkpKVxuICAgICAgICAvLyBjaGlsZFN0ZXBBY3Rpb25zLnVubWFyay5waXBlKG9wLnRhcChhY3QgPT4gdGhpcy5kaXNwYXRjaGVyLnVubWFyaygpKSlcbiAgICAgICkucGlwZShcbiAgICAgICAgb3AudGFrZVVudGlsKHJ4Lm1lcmdlKGFjdGlvbkJ5VHlwZS5zdWNlc3MsIGFjdGlvbkJ5VHlwZS5mYWlsZWQpKVxuICAgICAgKS5zdWJzY3JpYmUoKTtcbiAgICB9O1xuXG4gICAgc3Vic2NyaWJlU3RlcCgpO1xuXG4gICAgYWN0aW9uQnlUeXBlLnByb2Nlc3MucGlwZShcbiAgICAgIG9wLm1hcCgoe3BheWxvYWR9KSA9PiB7XG4gICAgICAgIGlmIChzdGFydFBvc2l0aW9uID09PSAtMSlcbiAgICAgICAgICBzdGFydFBvc2l0aW9uID0gcGF5bG9hZC5pO1xuICAgICAgICBjdXJyUG9zaXRpb24gPSBwYXlsb2FkLmk7XG4gICAgICAgIHN0ZXBzW2N1cnJTdGVwSWR4XS5kaXNwYXRjaGVyLnByb2Nlc3MocGF5bG9hZCk7XG4gICAgICB9KVxuICAgICkucGlwZShcbiAgICAgIG9wLnRha2VVbnRpbChyeC5tZXJnZShhY3Rpb25CeVR5cGUuc3VjZXNzLCBhY3Rpb25CeVR5cGUuZmFpbGVkKSlcbiAgICApLnN1YnNjcmliZSgpO1xuXG4gICAgcmV0dXJuIHtkaXNwYXRjaGVyLCBhY3Rpb25zfTtcbiAgfTtcbn1cblxuXG4vKiogQ2hvaWNlICovXG5leHBvcnQgZnVuY3Rpb24gY2hvaWNlKGxhTnVtID0gMiwgLi4uY2hvaWNlRmFjdG9yaWVzOiAoU3RlcEZhY3RvcnkpW10pIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb25zdCB7ZGlzcGF0Y2hlciwgYWN0aW9uc30gPSBjcmVhdGVTdGVwKCk7XG4gICAgY29uc3QgZmFpbGVkQ2hvaWNlUmVzdWx0ID0gW10gYXMgc3RyaW5nW11bXTtcbiAgICBjb25zdCBjaG9pY2VzID0gY2hvaWNlRmFjdG9yaWVzLm1hcCgoZmFjLCBpZHgpID0+IGZhYygpKTtcbiAgICBjb25zdCBhY3Rpb25CeVR5cGUgPSBzcGxpdEFjdGlvbkJ5VHlwZShhY3Rpb25zKTtcbiAgICBsZXQgY3VyckNob2ljZUlkeCA9IDA7XG4gICAgbGV0IHJlcGxheVBvczogbnVtYmVyO1xuXG4gICAgYWN0aW9uQnlUeXBlLnByb2Nlc3MucGlwZShcbiAgICAgIG9wLm1hcCgoe3BheWxvYWR9KSA9PiB7XG4gICAgICAgIGlmIChyZXBsYXlQb3MgPT0gbnVsbCkge1xuICAgICAgICAgIHJlcGxheVBvcyA9IHBheWxvYWQuaTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyckNob2ljZUlkeCA9PT0gMCkge1xuICAgICAgICAgIGRpc3BhdGNoZXIubWFyayhsYU51bSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hvaWNlc1tjdXJyQ2hvaWNlSWR4XS5kaXNwYXRjaGVyLnByb2Nlc3MocGF5bG9hZCk7XG4gICAgICB9KVxuICAgICkucGlwZShcbiAgICAgIG9wLnRha2VVbnRpbChyeC5tZXJnZShhY3Rpb25CeVR5cGUuc3VjZXNzLCBhY3Rpb25CeVR5cGUuZmFpbGVkKSlcbiAgICApLnN1YnNjcmliZSgpO1xuXG4gICAgY29uc3Qgc3Vic2NyaWJlQ3VycmVudENob2ljZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNob2ljZUFjdGlvbnMgPSBzcGxpdEFjdGlvbkJ5VHlwZShjaG9pY2VzW2N1cnJDaG9pY2VJZHhdLmFjdGlvbnMpO1xuXG4gICAgICByeC5tZXJnZShcbiAgICAgICAgY2hvaWNlQWN0aW9ucy5tYXJrLnBpcGUob3AudGFwKGFjdCA9PiBkaXNwYXRjaGVyLm1hcmsoYWN0LnBheWxvYWQpKSksXG4gICAgICAgIGNob2ljZUFjdGlvbnMucmVwbGF5LnBpcGUob3AudGFwKGFjdCA9PiBkaXNwYXRjaGVyLnJlcGxheShhY3QucGF5bG9hZCkpKVxuICAgICAgICAvLyBjaG9pY2VBY3Rpb25zLnVubWFyay5waXBlKG9wLnRhcChhY3QgPT4gdGhpcy5kaXNwYXRjaGVyLnVubWFyaygpKSlcbiAgICAgICkucGlwZShcbiAgICAgICAgb3AudGFrZVVudGlsKHJ4Lm1lcmdlKGFjdGlvbkJ5VHlwZS5zdWNlc3MsIGFjdGlvbkJ5VHlwZS5mYWlsZWQpKVxuICAgICAgKS5zdWJzY3JpYmUoKTtcblxuICAgICAgY2hvaWNlQWN0aW9ucy5zdWNlc3MucGlwZShcbiAgICAgICAgb3AudGFwKCh7cGF5bG9hZH0pID0+IHtcbiAgICAgICAgICAvLyB0aGlzLmRpc3BhdGNoZXIudW5tYXJrKCk7XG4gICAgICAgICAgZGlzcGF0Y2hlci5zdWNlc3MocGF5bG9hZCk7XG4gICAgICAgIH0pLFxuICAgICAgICBvcC50YWtlKDEpLFxuICAgICAgICBvcC50YWtlVW50aWwocngubWVyZ2UoYWN0aW9uQnlUeXBlLnN1Y2VzcywgYWN0aW9uQnlUeXBlLmZhaWxlZCkpXG4gICAgICApLnN1YnNjcmliZSgpO1xuXG4gICAgICBjb25zdCBsYXN0ID0gY2hvaWNlcy5sZW5ndGggLSAxO1xuICAgICAgY2hvaWNlQWN0aW9ucy5mYWlsZWQucGlwZShcbiAgICAgICAgb3AudGFwKCh7cGF5bG9hZH0pID0+IHtcbiAgICAgICAgICBmYWlsZWRDaG9pY2VSZXN1bHQucHVzaChwYXlsb2FkKTtcbiAgICAgICAgICBpZiAoY3VyckNob2ljZUlkeCA8IGxhc3QpIHtcbiAgICAgICAgICAgIGN1cnJDaG9pY2VJZHgrKztcbiAgICAgICAgICAgIHN1YnNjcmliZUN1cnJlbnRDaG9pY2UoKTtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIucmVwbGF5KHJlcGxheVBvcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIuZmFpbGVkKFsnTm9uZSBpcyBtYXRjaGVkOiAnICsgZmFpbGVkQ2hvaWNlUmVzdWx0Lm1hcChzdHIgPT4gc3RyLmpvaW4oJyAtICcpKS5qb2luKCc7ICcpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgb3AudGFrZSgxKSxcbiAgICAgICAgb3AudGFrZVVudGlsKHJ4Lm1lcmdlKGFjdGlvbkJ5VHlwZS5zdWNlc3MsIGFjdGlvbkJ5VHlwZS5mYWlsZWQpKVxuICAgICAgKS5zdWJzY3JpYmUoKTtcbiAgICB9O1xuXG4gICAgc3Vic2NyaWJlQ3VycmVudENob2ljZSgpO1xuICAgIHJldHVybiB7ZGlzcGF0Y2hlciwgYWN0aW9uc307XG4gIH07XG59XG5cbmludGVyZmFjZSBMb29wT3B0aW9ucyB7XG4gIC8vIGdyZWVkeT86IGJvb2xlYW47XG4gIGxhTnVtPzogbnVtYmVyO1xuICBtaW5UaW1lcz86IG51bWJlcjtcbiAgbWF4VGltZXM/OiBudW1iZXI7XG59XG5cbmNvbnN0IGRlZmF1bHRMb29wT3B0aW9ucyA9IHtncmVlZHk6IHRydWUsIGxhTnVtOiAyLCBtaW5UaW1lczogMCwgbWF4VGltZXM6IE51bWJlci5NQVhfVkFMVUV9O1xuXG4vKiogTG9vcCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvb3AoZmFjdG9yeTogU3RlcEZhY3RvcnksIG9wdHM/OiBMb29wT3B0aW9ucykge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGNvbnN0IHtkaXNwYXRjaGVyLCBhY3Rpb25zfSA9IGNyZWF0ZVN0ZXAoKTtcbiAgICBsZXQgb3B0aW9uczogUmVxdWlyZWQ8TG9vcE9wdGlvbnM+O1xuICAgIGlmIChvcHRzID09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0TG9vcE9wdGlvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSB7Li4uZGVmYXVsdExvb3BPcHRpb25zLCAuLi5vcHRzfTtcbiAgICB9XG4gICAgY29uc3QgYWN0aW9uQnlUeXBlID0gc3BsaXRBY3Rpb25CeVR5cGUoYWN0aW9ucyk7XG4gICAgbGV0IGxvb3BDb3VudCA9IDA7XG4gICAgbGV0IGN1cnJlbnRMb29wYWJsZTogUmV0dXJuVHlwZTx0eXBlb2YgY3JlYXRlU3RlcD47XG4gICAgbGV0IG1hcmtlZFBvczogbnVtYmVyO1xuICAgIGxldCBzdGFydFBvc2l0aW9uID0gLTE7XG4gICAgbGV0IGN1cnJQb3N0aW9uID0gLTE7XG4gICAgbGV0IGxvb3BSZXN1bHRzID0gW10gYXMgUG9zaXRpb25JbmZvW107XG5cbiAgICBjb25zdCBtYXJrQXRMb29wYWJsZUJlZ2luID0gKCkgPT4ge1xuICAgICAgYWN0aW9uQnlUeXBlLnByb2Nlc3MucGlwZShcbiAgICAgICAgb3AudGFrZSgxKSxcbiAgICAgICAgb3AubWFwKCh7cGF5bG9hZH0pID0+IHtcbiAgICAgICAgICBtYXJrZWRQb3MgPSBwYXlsb2FkLmk7XG4gICAgICAgICAgZGlzcGF0Y2hlci5tYXJrKG9wdGlvbnMubGFOdW0pO1xuICAgICAgICB9KVxuICAgICAgKS5zdWJzY3JpYmUoKTtcbiAgICB9O1xuXG4gICAgbWFya0F0TG9vcGFibGVCZWdpbigpO1xuXG4gICAgY29uc3QgY3JlYXRlTmV3TG9vcGFibGUgPSAoKSA9PiB7XG4gICAgICBjdXJyZW50TG9vcGFibGUgPSBmYWN0b3J5KCk7XG4gICAgICBjb25zdCBjaGlsZFN0ZXBBY3Rpb25zID0gc3BsaXRBY3Rpb25CeVR5cGUoY3VycmVudExvb3BhYmxlLmFjdGlvbnMpO1xuICAgICAgcngubWVyZ2UoXG4gICAgICAgIHJ4Lm1lcmdlKFxuICAgICAgICAgIGNoaWxkU3RlcEFjdGlvbnMuc3VjZXNzLnBpcGUoXG4gICAgICAgICAgICBvcC5tYXAobG9vcFJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgIGxvb3BSZXN1bHRzLnB1c2gobG9vcFJlc3VsdC5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgbG9vcENvdW50Kys7XG4gICAgICAgICAgICAgIGlmIChsb29wQ291bnQgPCBvcHRpb25zLm1heFRpbWVzKSB7XG4gICAgICAgICAgICAgICAgbWFya0F0TG9vcGFibGVCZWdpbigpO1xuICAgICAgICAgICAgICAgIGNyZWF0ZU5ld0xvb3BhYmxlKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0OiBQb3NpdGlvbkluZm8gPSB7XG4gICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnRQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgIGVuZDogY3VyclBvc3Rpb24gKyAxLFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IGxvb3BSZXN1bHRzXG4gICAgICAgICAgICAgICAgfSBhcyBQb3NpdGlvbkluZm87XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hlci5zdWNlc3MocmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApLFxuICAgICAgICAgIGNoaWxkU3RlcEFjdGlvbnMuZmFpbGVkLnBpcGUoXG4gICAgICAgICAgICBvcC5tYXAoKHtwYXlsb2FkOiByZWFzb259KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChsb29wQ291bnQgPiBvcHRpb25zLm1pblRpbWVzKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hlci5yZXBsYXkobWFya2VkUG9zKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQ6IFBvc2l0aW9uSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgZW5kOiBtYXJrZWRQb3MsXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogbG9vcFJlc3VsdHNcbiAgICAgICAgICAgICAgICB9IGFzIFBvc2l0aW9uSW5mbztcbiAgICAgICAgICAgICAgICBkaXNwYXRjaGVyLnN1Y2VzcyhyZXN1bHQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoZXIuZmFpbGVkKHJlYXNvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICApLnBpcGUob3AudGFrZSgxKSksXG4gICAgICAgIGNoaWxkU3RlcEFjdGlvbnMubWFyay5waXBlKG9wLnRhcChhY3QgPT4gZGlzcGF0Y2hlci5tYXJrKGFjdC5wYXlsb2FkKSkpLFxuICAgICAgICBjaGlsZFN0ZXBBY3Rpb25zLnJlcGxheS5waXBlKG9wLnRhcChhY3QgPT4gZGlzcGF0Y2hlci5yZXBsYXkoYWN0LnBheWxvYWQpKSlcbiAgICAgICkucGlwZShcbiAgICAgICAgb3AudGFrZVVudGlsKHJ4Lm1lcmdlKGFjdGlvbkJ5VHlwZS5zdWNlc3MsIGFjdGlvbkJ5VHlwZS5mYWlsZWQpKVxuICAgICAgKS5zdWJzY3JpYmUoKTtcbiAgICB9O1xuXG4gICAgY3JlYXRlTmV3TG9vcGFibGUoKTtcblxuICAgIGFjdGlvbkJ5VHlwZS5wcm9jZXNzLnBpcGUoXG4gICAgICBvcC5tYXAoKHtwYXlsb2FkfSkgPT4ge1xuICAgICAgICBpZiAoc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICBzdGFydFBvc2l0aW9uID0gcGF5bG9hZC5pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJQb3N0aW9uID0gcGF5bG9hZC5pO1xuICAgICAgICBjdXJyZW50TG9vcGFibGUuZGlzcGF0Y2hlci5wcm9jZXNzKHBheWxvYWQpO1xuICAgICAgfSlcbiAgICApLnBpcGUoXG4gICAgICBvcC50YWtlVW50aWwocngubWVyZ2UoYWN0aW9uQnlUeXBlLnN1Y2VzcywgYWN0aW9uQnlUeXBlLmZhaWxlZCkpXG4gICAgKS5zdWJzY3JpYmUoKTtcbiAgICByZXR1cm4ge2Rpc3BhdGNoZXIsIGFjdGlvbnN9O1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2U8VD4oc3RhdGVNYWNoaW5lOiBTdGVwRmFjdG9yeSwgZGVidWcgPSBmYWxzZSkge1xuICByZXR1cm4gKGlucHV0JDogcnguT2JzZXJ2YWJsZTxUPikgPT4ge1xuICAgIHJldHVybiByeC5kZWZlcigoKSA9PiB7XG4gICAgICBjb25zdCByb290U3RlcCA9IHN0YXRlTWFjaGluZSgpO1xuICAgICAgY29uc3QgYWN0aW9uQnlUeXBlID0gc3BsaXRBY3Rpb25CeVR5cGUocm9vdFN0ZXAuYWN0aW9ucyk7XG5cbiAgICAgIHJldHVybiByeC5tZXJnZShcbiAgICAgICAgcngubWVyZ2UoYWN0aW9uQnlUeXBlLnN1Y2VzcywgYWN0aW9uQnlUeXBlLmZhaWxlZClcbiAgICAgICAgICAucGlwZShcbiAgICAgICAgICAgIG9wLnRha2UoMSlcbiAgICAgICAgKSxcblxuICAgICAgICBkZWJ1ZyA/IHJvb3RTdGVwLmFjdGlvbnMucGlwZShcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgIG9wLnRhcChhY3Rpb24gPT4gY29uc29sZS5sb2coJzo6JywgYWN0aW9uKSksXG4gICAgICAgICAgb3AuaWdub3JlRWxlbWVudHMoKVxuICAgICAgICApIDogcnguRU1QVFksXG5cbiAgICAgICAgLy8gaW5wdXQkIG11c3QgYmUgdGhlIGxhc3Qgb25lIGJlaW5nIHN1YnNjcmliZWQgaW4gbWVyZ2UgbGlzdCwgb3RoZXJ3aXNlIG90aGVyIHN1YnNjcmlwdGlvbiBuaWdodCBkb24ndCBoYXZlIGNoYW5nZSB0byBcbiAgICAgICAgLy8gb2JzZXJ2ZSBlbWl0dGVkIHJlc3VsdCBhZnRlciBpbnB1dCQucGlwZSgpIGhhcyBjb21wbGV0ZWRcbiAgICAgICAgaW5wdXQkLnBpcGUoXG4gICAgICAgICAgY2FjaGVBbmRSZXBsYXkoYWN0aW9uQnlUeXBlLm1hcmsucGlwZShvcC5tYXAoYWN0ID0+IGFjdC5wYXlsb2FkKSksXG4gICAgICAgICAgICBhY3Rpb25CeVR5cGUucmVwbGF5LnBpcGUob3AubWFwKGFjdCA9PiBhY3QucGF5bG9hZCkpXG4gICAgICAgICAgKSxcbiAgICAgICAgICBvcC5tYXAoKHt2YWx1ZSwgaWR4fSwgdG90YWxJbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHt0b3RhbEluZGV4fV0gb2Zmc2V0OiR7aWR4fSwgdmFsdWU6ICR7JycgKyB2YWx1ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvb3RTdGVwLmRpc3BhdGNoZXIucHJvY2Vzcyh7ZDogdmFsdWUsIGk6IGlkeH0pO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIG9wLnRha2VVbnRpbChyeC5tZXJnZShhY3Rpb25CeVR5cGUuc3VjZXNzLCBhY3Rpb25CeVR5cGUuZmFpbGVkKSksXG4gICAgICAgICAgb3AuaWdub3JlRWxlbWVudHMoKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0pO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVzdCgpIHtcbiAgcnguZnJvbSgnYWJjeGRlZmRlZjEnLnNwbGl0KCcnKSkucGlwZShcbiAgICBwYXJzZShzY29wZSgnaGVsbG93JywgW1xuICAgICAgICBjbXAoJ2FiJyksXG4gICAgICAgIGNob2ljZSgyLCBjbXAoJzF4JyksIGNtcCgnY3gnKSksXG4gICAgICAgIGxvb3Aoc2NvcGUoJ2xvb3AgZGUnLCBbY21wKCdkZWYnKV0pKSxcbiAgICAgICAgY21wKCcxJylcbiAgICAgIF0pLCB0cnVlXG4gICAgKSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIG9wLnRhcChyID0+IGNvbnNvbGUubG9nKCctLS0+ICcsIEpTT04uc3RyaW5naWZ5KHIsIG51bGwsICcgICcpKSlcbiAgKS5zdWJzY3JpYmUoKTtcbn1cbiJdfQ==