"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.start = void 0;
/* eslint-disable no-console */
const net_1 = __importDefault(require("net"));
const plink_1 = require("@wfh/plink");
const log = (0, plink_1.log4File)(__filename);
function start(port, hostMap = new Map(), opts) {
    const server = net_1.default.createServer();
    server.on('connection', (clientToProxySocket) => {
        log.debug('Client Connected To Proxy', clientToProxySocket.remoteAddress +
            ':' + clientToProxySocket.remotePort);
        // We need only the data once, the starting packet
        clientToProxySocket.once('data', (data) => {
            const greeting = data.toString();
            log.info(greeting);
            let isTLSConnection = greeting.indexOf('CONNECT') !== -1;
            // Considering Port as 80 by default 
            let serverPort = 80;
            let serverAddress = '';
            let protocal = 'HTTP/1.1';
            if (isTLSConnection) {
                const match = /CONNECT +([^\s:]+)(?::(\S+))?(?: +(\S+))?/.exec(greeting);
                // Port changed to 443, parsing the host from CONNECT 
                serverPort = match[2] ? parseInt(match[2], 10) : 443;
                serverAddress = match[1];
                if (match[3])
                    protocal = match[3];
            }
            else {
                // Parsing HOST from HTTP
                const match = /Host: +([^\s:]+)(?::(\S+))?/.exec(greeting);
                if (match != null) {
                    serverAddress = match[1];
                    serverPort = match[2] ? parseInt(match[2], 10) : 80;
                }
            }
            log.info('proxy to:', serverAddress + ':' + serverPort);
            const mapped = serverAddress ? hostMap.get(serverAddress) : null;
            let proxyToServerSocket;
            if (mapped) {
                let splitted = mapped.split(':');
                serverAddress = splitted[0];
                if (splitted[1])
                    serverPort = parseInt(splitted[1], 10);
                log.info('mapped to', serverAddress, ':', serverPort);
            }
            else if (opts === null || opts === void 0 ? void 0 : opts.fallbackProxyHost) {
                proxyToServerSocket = net_1.default.connect({
                    host: opts.fallbackProxyHost,
                    port: opts.fallbackproxyPort
                }, () => {
                    log.debug('PROXY TO FORBACK proxy connection created', opts.fallbackProxyHost, ':', opts.fallbackproxyPort);
                    proxyToServerSocket.write(data);
                    // Piping the sockets
                    clientToProxySocket.pipe(proxyToServerSocket);
                    proxyToServerSocket.pipe(clientToProxySocket);
                });
            }
            proxyToServerSocket = net_1.default.connect({
                host: serverAddress,
                port: serverPort
            }, () => {
                log.debug('PROXY TO SERVER connection created', serverAddress, ':', serverPort);
                if (isTLSConnection) {
                    // Send Back OK to HTTPS CONNECT Request
                    clientToProxySocket.write(protocal + ' 200 OK\r\n\n');
                }
                else {
                    proxyToServerSocket.write(data);
                }
                // Piping the sockets
                clientToProxySocket.pipe(proxyToServerSocket);
                proxyToServerSocket.pipe(clientToProxySocket);
            });
            proxyToServerSocket.on('error', (err) => {
                log.warn('PROXY TO SERVER ERROR', serverAddress, ':', serverPort, err);
            });
            proxyToServerSocket.on('lookup', (err, addr, fam, host) => {
                if (err)
                    log.warn('lookup error', err);
                log.info('lookup', addr, host);
            });
            proxyToServerSocket.on('timeout', () => {
                log.info('PROXY TO SERVER timeout', serverAddress, ':', serverPort);
            });
        });
        clientToProxySocket.on('error', err => {
            log.warn('CLIENT TO PROXY ERROR', err);
        });
    });
    server.on('error', (err) => {
        log.info('SERVER ERROR');
        log.info(err);
    });
    server.on('close', () => {
        log.info('Client Disconnected');
    });
    server.listen(port, () => {
        log.info(`Server runnig at http://${(0, plink_1.config)().localIP}:` + port);
    });
    return () => {
        server.close();
    };
}
exports.start = start;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xpLWZvcndhcmQtcHJveHkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjbGktZm9yd2FyZC1wcm94eS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSwrQkFBK0I7QUFDL0IsOENBQXNCO0FBQ3RCLHNDQUE0QztBQUM1QyxNQUFNLEdBQUcsR0FBRyxJQUFBLGdCQUFRLEVBQUMsVUFBVSxDQUFDLENBQUM7QUFFakMsU0FBZ0IsS0FBSyxDQUFDLElBQVksRUFBRSxVQUErQixJQUFJLEdBQUcsRUFBRSxFQUMxRSxJQUlDO0lBQ0QsTUFBTSxNQUFNLEdBQUcsYUFBRyxDQUFDLFlBQVksRUFBRSxDQUFDO0lBRWxDLE1BQU0sQ0FBQyxFQUFFLENBQUMsWUFBWSxFQUFFLENBQUMsbUJBQW1CLEVBQUUsRUFBRTtRQUM5QyxHQUFHLENBQUMsS0FBSyxDQUFDLDJCQUEyQixFQUFFLG1CQUFtQixDQUFDLGFBQWE7WUFDL0QsR0FBRyxHQUFHLG1CQUFtQixDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQy9DLGtEQUFrRDtRQUNsRCxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsSUFBSSxFQUFFLEVBQUU7WUFDeEMsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ2pDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDbkIsSUFBSSxlQUFlLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUV6RCxxQ0FBcUM7WUFDckMsSUFBSSxVQUFVLEdBQUcsRUFBRSxDQUFDO1lBQ3BCLElBQUksYUFBYSxHQUFHLEVBQUUsQ0FBQztZQUN2QixJQUFJLFFBQVEsR0FBRyxVQUFVLENBQUM7WUFDMUIsSUFBSSxlQUFlLEVBQUU7Z0JBQ25CLE1BQU0sS0FBSyxHQUFHLDJDQUEyQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUUsQ0FBQztnQkFDMUUs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R0FBRyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUN6QixHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2hCLENBQUMsQ0FBQyxDQUFDO0lBRUgsTUFBTSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsR0FBRyxFQUFFO1FBQ3RCLEdBQUcsQ0FBQyxJQUFJLENBQUMscUJBQXFCLENBQUMsQ0FBQztJQUNsQyxDQUFDLENBQUMsQ0FBQztJQUVILE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRTtRQUN2QixHQUFHLENBQUMsSUFBSSxDQUFDLDJCQUEyQixJQUFBLGNBQU0sR0FBRSxDQUFDLE9BQU8sR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDO0lBQ2xFLENBQUMsQ0FBQyxDQUFDO0lBRUgsT0FBTyxHQUFHLEVBQUU7UUFDVixNQUFNLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDakIsQ0FBQyxDQUFDO0FBQ0osQ0FBQztBQS9HRCxzQkErR0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG5pbXBvcnQgbmV0IGZyb20gJ25ldCc7XG5pbXBvcnQge2xvZzRGaWxlLCBjb25maWd9IGZyb20gJ0B3ZmgvcGxpbmsnO1xuY29uc3QgbG9nID0gbG9nNEZpbGUoX19maWxlbmFtZSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFydChwb3J0OiBudW1iZXIsIGhvc3RNYXA6IE1hcDxzdHJpbmcsIHN0cmluZz4gPSBuZXcgTWFwKCksXG4gIG9wdHM/OiB7XG4gICAgLyoqIGlmIGhvc3QgaXMgbm90IGluIGhvc3RNYXAsIGZvcndhcmQgdG8gdGhpcyBwcm94eSAqL1xuICAgIGZhbGxiYWNrUHJveHlIb3N0OiBzdHJpbmc7XG4gICAgZmFsbGJhY2twcm94eVBvcnQ6IG51bWJlcjtcbiAgfSkge1xuICBjb25zdCBzZXJ2ZXIgPSBuZXQuY3JlYXRlU2VydmVyKCk7XG5cbiAgc2VydmVyLm9uKCdjb25uZWN0aW9uJywgKGNsaWVudFRvUHJveHlTb2NrZXQpID0+IHtcbiAgICBsb2cuZGVidWcoJ0NsaWVudCBDb25uZWN0ZWQgVG8gUHJveHknLCBjbGllbnRUb1Byb3h5U29ja2V0LnJlbW90ZUFkZHJlc3MgK1xuICAgICAgICAgICAgICc6JyArIGNsaWVudFRvUHJveHlTb2NrZXQucmVtb3RlUG9ydCk7XG4gICAgLy8gV2UgbmVlZCBvbmx5IHRoZSBkYXRhIG9uY2UsIHRoZSBzdGFydGluZyBwYWNrZXRcbiAgICBjbGllbnRUb1Byb3h5U29ja2V0Lm9uY2UoJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgY29uc3QgZ3JlZXRpbmcgPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICBsb2cuaW5mbyhncmVldGluZyk7XG4gICAgICBsZXQgaXNUTFNDb25uZWN0aW9uID0gZ3JlZXRpbmcuaW5kZXhPZignQ09OTkVDVCcpICE9PSAtMTtcblxuICAgICAgLy8gQ29uc2lkZXJpbmcgUG9ydCBhcyA4MCBieSBkZWZhdWx0IFxuICAgICAgbGV0IHNlcnZlclBvcnQgPSA4MDtcbiAgICAgIGxldCBzZXJ2ZXJBZGRyZXNzID0gJyc7XG4gICAgICBsZXQgcHJvdG9jYWwgPSAnSFRUUC8xLjEnO1xuICAgICAgaWYgKGlzVExTQ29ubmVjdGlvbikge1xuICAgICAgICBjb25zdCBtYXRjaCA9IC9DT05ORUNUICsoW15cXHM6XSspKD86OihcXFMrKSk/KD86ICsoXFxTKykpPy8uZXhlYyhncmVldGluZykhO1xuICAgICAgICAvLyBQb3J0IGNoYW5nZWQgdG8gNDQzLCBwYXJzaW5nIHRoZSBob3N0IGZyb20gQ09OTkVDVCBcbiAgICAgICAgc2VydmVyUG9ydCA9IG1hdGNoWzJdID8gcGFyc2VJbnQobWF0Y2hbMl0sIDEwKSA6IDQ0MztcbiAgICAgICAgc2VydmVyQWRkcmVzcyA9IG1hdGNoWzFdO1xuICAgICAgICBpZiAobWF0Y2hbM10pXG4gICAgICAgICAgcHJvdG9jYWwgPSBtYXRjaFszXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFBhcnNpbmcgSE9TVCBmcm9tIEhUVFBcbiAgICAgICAgY29uc3QgbWF0Y2ggPSAvSG9zdDogKyhbXlxcczpdKykoPzo6KFxcUyspKT8vLmV4ZWMoZ3JlZXRpbmcpO1xuICAgICAgICBpZiAobWF0Y2ggIT0gbnVsbCkge1xuICAgICAgICAgIHNlcnZlckFkZHJlc3MgPSBtYXRjaFsxXTtcbiAgICAgICAgICBzZXJ2ZXJQb3J0ID0gbWF0Y2hbMl0gPyBwYXJzZUludChtYXRjaFsyXSwgMTApIDogODA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxvZy5pbmZvKCdwcm94eSB0bzonLCBzZXJ2ZXJBZGRyZXNzICsgJzonICsgc2VydmVyUG9ydCk7XG4gICAgICBjb25zdCBtYXBwZWQgPSBzZXJ2ZXJBZGRyZXNzID8gaG9zdE1hcC5nZXQoc2VydmVyQWRkcmVzcykgOiBudWxsO1xuXG4gICAgICBsZXQgcHJveHlUb1NlcnZlclNvY2tldDogbmV0LlNvY2tldDtcblxuICAgICAgaWYgKG1hcHBlZCkge1xuICAgICAgICBsZXQgc3BsaXR0ZWQgPSBtYXBwZWQuc3BsaXQoJzonKTtcbiAgICAgICAgc2VydmVyQWRkcmVzcyA9IHNwbGl0dGVkWzBdO1xuICAgICAgICBpZiAoc3BsaXR0ZWRbMV0pXG4gICAgICAgICAgc2VydmVyUG9ydCA9IHBhcnNlSW50KHNwbGl0dGVkWzFdLCAxMCk7XG4gICAgICAgIGxvZy5pbmZvKCdtYXBwZWQgdG8nLCBzZXJ2ZXJBZGRyZXNzLCAnOicsIHNlcnZlclBvcnQpO1xuICAgICAgfSBlbHNlIGlmIChvcHRzPy5mYWxsYmFja1Byb3h5SG9zdCl7XG4gICAgICAgIHByb3h5VG9TZXJ2ZXJTb2NrZXQgPSBuZXQuY29ubmVjdCh7XG4gICAgICAgICAgaG9zdDogb3B0cy5mYWxsYmFja1Byb3h5SG9zdCxcbiAgICAgICAgICBwb3J0OiBvcHRzLmZhbGxiYWNrcHJveHlQb3J0XG4gICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICBsb2cuZGVidWcoJ1BST1hZIFRPIEZPUkJBQ0sgcHJveHkgY29ubmVjdGlvbiBjcmVhdGVkJywgb3B0cy5mYWxsYmFja1Byb3h5SG9zdCwgJzonLCBvcHRzLmZhbGxiYWNrcHJveHlQb3J0KTtcbiAgICAgICAgICBwcm94eVRvU2VydmVyU29ja2V0LndyaXRlKGRhdGEpO1xuICAgICAgICAgIC8vIFBpcGluZyB0aGUgc29ja2V0c1xuICAgICAgICAgIGNsaWVudFRvUHJveHlTb2NrZXQucGlwZShwcm94eVRvU2VydmVyU29ja2V0KTtcbiAgICAgICAgICBwcm94eVRvU2VydmVyU29ja2V0LnBpcGUoY2xpZW50VG9Qcm94eVNvY2tldCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBwcm94eVRvU2VydmVyU29ja2V0ID0gbmV0LmNvbm5lY3Qoe1xuICAgICAgICAgIGhvc3Q6IHNlcnZlckFkZHJlc3MsXG4gICAgICAgICAgcG9ydDogc2VydmVyUG9ydFxuICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgbG9nLmRlYnVnKCdQUk9YWSBUTyBTRVJWRVIgY29ubmVjdGlvbiBjcmVhdGVkJywgc2VydmVyQWRkcmVzcywgJzonLCBzZXJ2ZXJQb3J0KTtcblxuICAgICAgICAgIGlmIChpc1RMU0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIFNlbmQgQmFjayBPSyB0byBIVFRQUyBDT05ORUNUIFJlcXVlc3RcbiAgICAgICAgICAgIGNsaWVudFRvUHJveHlTb2NrZXQud3JpdGUocHJvdG9jYWwgKyAnIDIwMCBPS1xcclxcblxcbicpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm94eVRvU2VydmVyU29ja2V0LndyaXRlKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBQaXBpbmcgdGhlIHNvY2tldHNcbiAgICAgICAgICBjbGllbnRUb1Byb3h5U29ja2V0LnBpcGUocHJveHlUb1NlcnZlclNvY2tldCk7XG4gICAgICAgICAgcHJveHlUb1NlcnZlclNvY2tldC5waXBlKGNsaWVudFRvUHJveHlTb2NrZXQpO1xuICAgICAgICB9KTtcblxuICAgICAgcHJveHlUb1NlcnZlclNvY2tldCEub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICBsb2cud2FybignUFJPWFkgVE8gU0VSVkVSIEVSUk9SJywgc2VydmVyQWRkcmVzcywgJzonLCBzZXJ2ZXJQb3J0LCBlcnIpO1xuICAgICAgfSk7XG4gICAgICBwcm94eVRvU2VydmVyU29ja2V0IS5vbignbG9va3VwJywgKGVyciwgYWRkciwgZmFtLCBob3N0KSA9PiB7XG4gICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgbG9nLndhcm4oJ2xvb2t1cCBlcnJvcicsIGVycik7XG4gICAgICAgIGxvZy5pbmZvKCdsb29rdXAnLCBhZGRyLCBob3N0KTtcbiAgICAgIH0pO1xuICAgICAgcHJveHlUb1NlcnZlclNvY2tldCEub24oJ3RpbWVvdXQnLCAoKSA9PiB7XG4gICAgICAgIGxvZy5pbmZvKCdQUk9YWSBUTyBTRVJWRVIgdGltZW91dCcsIHNlcnZlckFkZHJlc3MsICc6Jywgc2VydmVyUG9ydCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGNsaWVudFRvUHJveHlTb2NrZXQub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgIGxvZy53YXJuKCdDTElFTlQgVE8gUFJPWFkgRVJST1InLCBlcnIpO1xuICAgIH0pO1xuICB9KTtcblxuICBzZXJ2ZXIub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgIGxvZy5pbmZvKCdTRVJWRVIgRVJST1InKTtcbiAgICBsb2cuaW5mbyhlcnIpO1xuICB9KTtcblxuICBzZXJ2ZXIub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgIGxvZy5pbmZvKCdDbGllbnQgRGlzY29ubmVjdGVkJyk7XG4gIH0pO1xuXG4gIHNlcnZlci5saXN0ZW4ocG9ydCwgKCkgPT4ge1xuICAgIGxvZy5pbmZvKGBTZXJ2ZXIgcnVubmlnIGF0IGh0dHA6Ly8ke2NvbmZpZygpLmxvY2FsSVB9OmAgKyBwb3J0KTtcbiAgfSk7XG5cbiAgcmV0dXJuICgpID0+IHtcbiAgICBzZXJ2ZXIuY2xvc2UoKTtcbiAgfTtcbn1cblxuIl19