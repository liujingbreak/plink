{"version":3,"file":"utils.js","sourceRoot":"","sources":["utils.ts"],"names":[],"mappings":"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","sourcesContent":["import zlib from 'zlib';\nimport {IncomingMessage} from 'http';\nimport {promises as streamPro, pipeline, Readable, Writable} from 'stream';\n\nexport async function readCompressedResponse(clientResponse: IncomingMessage, output: Writable) {\n  return new Promise<void>((resolve, reject) => {\n    const onError: (err: NodeJS.ErrnoException | null) => void = err => {\n      if (err)\n        return reject(err);\n      resolve();\n    };\n\n    switch (clientResponse.headers['content-encoding']) {\n      case 'br':\n        pipeline(clientResponse, zlib.createBrotliDecompress(), output, onError);\n        break;\n      // Or, just use zlib.createUnzip() to handle both of the following cases:\n      case 'gzip':\n        pipeline(clientResponse, zlib.createGunzip(), output, onError);\n        break;\n      case 'deflate':\n        pipeline(clientResponse, zlib.createInflate(), output, onError);\n        break;\n      default:\n        pipeline(clientResponse, output, onError);\n        break;\n    }\n  });\n}\n\nexport async function compressedIncomingMsgToBuffer(msg: IncomingMessage): Promise<Buffer> {\n  const data = [] as Buffer[];\n  const output = new Writable({\n    write(chunk: Buffer, _enc, cb) {\n      data.push(chunk);\n      cb();\n    },\n    final(cb) {\n      cb();\n    }\n  });\n  await readCompressedResponse(msg, output);\n  return Buffer.concat(data);\n}\n\n/** Make sure you remove \"content-length\" header so that Node.js will add \"tranfer-encoding: chunked\" */\nexport async function compressResponse(data: Buffer | string, response: Writable, contentEncoding?: string) {\n  const source = new Readable({read() {\n    this.push(data);\n    this.push(null);\n  }});\n\n  switch (contentEncoding) {\n    case 'br':\n      return streamPro.pipeline(source, zlib.createBrotliCompress(), response);\n    case 'gzip':\n      return streamPro.pipeline(source, zlib.createGzip(), response);\n    case 'deflate':\n      return streamPro.pipeline(source, zlib.createDeflate(), response);\n    default:\n      return streamPro.pipeline(source, response);\n  }\n}\n\n/** You set content-length header, this will disable \"tranfer-encoding: chunked\" mode */\nexport async function compressResWithContentLength(data: Buffer | string, response: Writable, contentEncoding?: string): Promise<{contentLength: number; write(): Promise<void>}> {\n  const chunks = [] as Buffer[];\n  let len = 0;\n  await new Promise<void>(resolve => {\n    const output = new Writable({\n      write(chunk, enc, cb) {\n        const buf = chunk as Buffer;\n        chunks.push(buf);\n        len += buf.length;\n        cb();\n      },\n      final(cb) {\n        cb();\n        resolve();\n      }\n    });\n    void compressResponse(data, output, contentEncoding);\n  });\n  return {\n    contentLength: len,\n    write() {\n      return streamPro.pipeline(new Readable({\n        read() {\n          this.push(chunks.shift());\n          if (chunks.length === 0)\n            this.push(null);\n        }\n      }), response);\n    }\n  };\n}\n"]}