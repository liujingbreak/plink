{"version":3,"file":"imap-msg-parser.js","sourceRoot":"","sources":["imap-msg-parser.ts"],"names":[],"mappings":"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","sourcesContent":["import { ParseGrammar, ParseLex, Token, LookAhead, mapChunks, mapChunksObs } from '@wfh/plink/wfh/dist/async-LLn-parser';\nimport { Subject, Observable, queueScheduler, from } from 'rxjs';\nimport {observeOn, map, takeWhile, concatMap, takeLast, share} from 'rxjs/operators';\nimport { connect as tslConnect, ConnectionOptions, TLSSocket } from 'tls';\n// import fs from 'fs';\n\n// let fileWritingIdx = 1;\n// import {Subscriber} from 'rxjs';\n\nexport enum ImapTokenType {\n  number = 1,\n  stringLit,\n  stringQuote,\n  '(',\n  ')',\n  atom, // ATOM or NIL\n  CRLF\n  // nil\n}\n\nexport interface StringLit extends Token<ImapTokenType.stringLit> {\n  data: Buffer;\n}\n\n\nconst R_BRACE = '}'.charCodeAt(0);\nconst CR = '\\r'.charCodeAt(0);\nconst LF = '\\n'.charCodeAt(0);\n\nconst parseLex: ParseLex<number, ImapTokenType> = async function(reply, sub) {\n  // const origWrite = reply._writeAndResolve;\n  // reply._writeAndResolve = function(bytes) {\n  //   fs.writeFileSync('imap-msg-parser.parseLex.log.txt', Buffer.from(Array.from(bytes)).toString('utf8'), {flag: 'a'});\n  //   origWrite.apply(this, arguments);\n  // };\n\n  let nextByte =  await reply.la();\n  while (nextByte != null) {\n    const next = String.fromCharCode(nextByte);\n    if (' ' === next) {\n      await reply.advance();\n      // skip space char\n    } else if (/[0-9]/.test(next)) {\n      reply.startToken(ImapTokenType.number);\n      await reply.advance();\n      nextByte = await reply.la();\n      while (nextByte != null && /[0-9.]/.test(String.fromCharCode(nextByte))) {\n        await reply.advance();\n        nextByte = await reply.la();\n      }\n      reply.emitToken();\n    } else if ('\\r' === next) {\n      reply.startToken(ImapTokenType.CRLF);\n      await reply.advance();\n      const b = await reply.la();\n      if (b != null && String.fromCharCode(b) === '\\n')\n        await reply.advance();\n      reply.emitToken();\n    } else if ('\\n' === next) {\n      reply.startToken(ImapTokenType.CRLF);\n      await reply.advance();\n      reply.emitToken();\n    } else if ('\"' === next) {\n      reply.startToken(ImapTokenType.stringQuote);\n      const openChar = await reply.advance();\n      while (true) {\n        const la = await reply.la();\n        if (la == null) {\n          return reply.throwError();\n        }\n        if (String.fromCharCode(la) === '\\\\') {\n          await reply.advance(2);\n        } else if (la === openChar) {\n          await reply.advance();\n          reply.emitToken();\n          break;\n        } else {\n          await reply.advance();\n        }\n      }\n    } else if ('{' === next) {\n      const next2 = await reply.la(2);\n      if (next2 != null && /\\d/.test(String.fromCharCode(next2))) {\n        await parseLiteralString(reply);\n      } else {\n        await parseAtom(reply);\n      }\n    } else if ('(' === next || ')' === next) {\n      reply.startToken(ImapTokenType[next]);\n      await reply.advance();\n      reply.emitToken();\n    } else {\n      await parseAtom(reply);\n    }\n    nextByte =  await reply.la();\n  }\n};\n\nasync function parseAtom(la: Parameters<ParseLex<number, ImapTokenType>>[0]) {\n  la.startToken(ImapTokenType.atom);\n  await la.advance();\n  let nextByte = await la.la();\n  while (nextByte != null && /[^\\s{[()\"]/.test(String.fromCharCode(nextByte))) {\n    await la.advance();\n    nextByte = await la.la();\n  }\n  la.emitToken();\n}\n\nasync function parseLiteralString(reply: Parameters<ParseLex<number, ImapTokenType>>[0]) {\n  const chunk = reply.startToken(ImapTokenType.stringLit, false);\n  await reply.advance();\n  let numStr = String.fromCharCode(await reply.advance());\n  let next = await reply.la();\n  while (next && next !== R_BRACE) {\n    numStr += String.fromCharCode(next);\n    await reply.advance();\n    next = await reply.la();\n  }\n  await reply.advance();\n  next = await reply.la();\n  if (next == null)\n    return reply.throwError();\n  while (next === CR || next === LF) {\n    await reply.advance();\n    next = await reply.la();\n  }\n\n  const numByte = parseInt(numStr, 10);\n  const buf = Buffer.alloc(numByte);\n\n  let i = 0;\n  // console.time('stringlit');\n  while (i < numByte) {\n    next = await reply.la();\n    if (next == null) {\n      return reply.throwError();\n    }\n    const char = await reply.advance();\n    buf.writeUInt8(char, i);\n    i++;\n  }\n  // console.timeEnd('stringlit');\n  (chunk as StringLit).data = buf;\n  reply.emitToken();\n}\n\nasync function parseLine(la: Parameters<(typeof parseLines)>[1]):\nPromise<Token<ImapTokenType>[] | undefined> {\n  let buf: Token<ImapTokenType>[] | undefined;\n  let word = await la.la();\n  while (true) {\n    if (word == null) {\n      return;\n    }\n    if (buf == null) buf = [];\n    if (word.type === ImapTokenType.CRLF) {\n      await la.advance();\n      return buf;\n    }\n    buf.push(word);\n    await la.advance();\n    word = await la.la();\n  }\n}\n\nasync function parseLines(lineSubject: Subject<Token<ImapTokenType>[]>, la: LookAhead<Token<ImapTokenType>, any>) {\n  let line: Token<ImapTokenType>[] | undefined;\n  do {\n    line = await parseLine(la);\n    if (line == null) {\n      lineSubject.complete();\n      break;\n    }\n    lineSubject.next(line);\n  } while (true);\n}\n\nexport function createServerDataHandler(): {input: (buf: Buffer | null) =>void, output: Observable<Token<ImapTokenType>[]>} {\n  const input = new Subject<Buffer | null>();\n\n  const parseServerReply: ParseGrammar<Subject<Token<ImapTokenType>[]>, ImapTokenType> = async (la) => {\n    const lineSubject = new Subject<Token<ImapTokenType>[]>();\n    parseLines(lineSubject, la);\n    return lineSubject;\n  };\n\n  // parser('IMAP', input, parseLex, null, parseServerReply);\n  const name = 'IMAP';\n\n  const output = input.pipe(\n    observeOn(queueScheduler),\n    takeWhile<Buffer>(data => data != null),\n    // tap(data => fs.writeFileSync('imap-msg-parser-log.txt', data.toString('utf8'), {flag: 'a'})),\n    mapChunks(name + '-lexer', parseLex),\n    map(chunk => {\n      const buf = Buffer.from(Uint8Array.from(chunk.values!));\n      (chunk as Token<ImapTokenType>).text = buf.toString('utf8');\n      delete chunk.values;\n      return chunk as Token<ImapTokenType>;\n    }),\n    map(token => [token]),\n    mapChunksObs(name + '-parser', (la) => from(parseServerReply(la))),\n    concatMap(lines => lines),\n    share()\n  );\n\n  return {\n    input: (data) => input.next(data),\n    output\n  };\n}\n\n/**\n * \n * @param lines createServerDataHandler().output\n * @param parseLine return null/undefined to continue to wait for next line, or it will stop waiting for next line.\n */\nexport function parseLinesOfTokens(lines: Observable<Token<ImapTokenType>[]>,\n  parseLine: (la: LookAhead<Token<ImapTokenType>>) => Promise<any | null | void>) {\n  return lines.pipe(\n    concatMap(line => {\n      const la = new LookAhead<Token<ImapTokenType>>('imap reply line');\n      la._write(line);\n      la._final();\n      return from(parseLine(la));\n    }),\n    // filter(res => res == null),\n    takeWhile(res => res == null, true),\n    takeLast(1)\n  ).toPromise();\n}\n\nexport async function connectImap(address: string) {\n  const handler = createServerDataHandler();\n  let socket: TLSSocket|undefined;\n  try {\n    socket = await new Promise<ReturnType<typeof tslConnect>>((resolve, reject) => {\n      const socket = tslConnect({\n        host: address, port: 993,\n        enableTrace: true\n      } as ConnectionOptions);\n\n      socket.on('secureConnect', () => {\n        // eslint-disable-next-line no-console\n        console.log('connected', socket.authorized ? 'authorized' : 'unauthorized');\n        resolve(socket);\n      })\n      .on('error', err => reject(err))\n      .on('timeout', () => reject(new Error('Timeout')));\n      socket.on('data', (data: Buffer) => handler.input(data));\n    });\n\n  } catch (ex) {\n    if (socket)\n      socket.end();\n    throw ex;\n  }\n  await new Promise(resolve => setTimeout(resolve, 3000));\n  handler.input(null);\n  socket.end();\n}\n"]}