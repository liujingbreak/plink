{"version":3,"file":"rfc822-parser.js","sourceRoot":"","sources":["rfc822-parser.ts"],"names":[],"mappings":";;;;AACA,2EAC6F;AAC7F,+BAA8C;AAC9C,8CAAqD;AAErD,gEAA0B;AAC1B,wDAAwB;AACxB,MAAM,GAAG,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC,SAAS,CAAC,qCAAqC,CAAC,CAAC;AAE/E,IAAY,eASX;AATD,WAAY,eAAe;IACzB,qDAAI,CAAA;IACJ,+CAAG,CAAA;IACH,+CAAG,CAAA;IACH,6DAAQ,CAAA;IACR,qDAAI,CAAA;IACJ,6DAAQ,CAAA;IACR,+DAAS,CAAA;IACT,mEAAW,CAAA;AACb,CAAC,EATW,eAAe,GAAf,uBAAe,KAAf,uBAAe,QAS1B;AAMD,MAAM,EAAE,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AAC9B,MAAM,EAAE,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AAC9B,MAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AACtC,MAAM,WAAW,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AACtC,MAAM,WAAW,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AACvC,MAAM,UAAU,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AACrC,MAAM,QAAQ,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AACnC,MAAM,EAAE,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AAC7B,MAAM,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AAC/B,MAAM,IAAI,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AAC/B,kCAAkC;AAElC,MAAM,QAAQ,GAAG,8BAA8B,CAAC;AAehD,MAAM,gBAAgB;IAKpB,YAAoB,UAAsB;QAAtB,eAAU,GAAV,UAAU,CAAY;QAFlC,qBAAgB,GAAG,KAAK,CAAC;QAOjC,eAAU,GAAsC,KAAK,EAAE,EAAE,EAAE,EAAE;YAC3D,IAAI,OAAO,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAC5B,OAAO,OAAO,IAAI,IAAI,EAAE;gBACtB,MAAM,GAAG,GAAG,MAAM,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;gBACzC,IAAI,IAAI,CAAC,gBAAgB,IAAI,MAAM,EAAE,CAAC,MAAM,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE;oBAC5D,2BAA2B;oBAC3B,EAAE,CAAC,UAAU,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;oBACpC,MAAM,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;oBACpB,EAAE,CAAC,SAAS,EAAE,CAAC;oBAEf,EAAE,CAAC,UAAU,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;oBACpC,MAAM,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;oBACpB,EAAE,CAAC,SAAS,EAAE,CAAC;oBACf,MAAM,IAAI,CAAC,kBAAkB,CAAC,EAAE,CAAC,CAAC;iBAEnC;qBAAM,IAAI,IAAI,CAAC,gBAAgB,IAAI,MAAM,EAAE,CAAC,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE;oBAC/D,EAAE,CAAC,UAAU,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC;oBAC3C,MAAM,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,uBAAuB;oBAC5C,EAAE,CAAC,SAAS,EAAE,CAAC;oBACf,MAAM;iBACP;qBAAM,IAAI,IAAI,CAAC,QAAQ,IAAI,MAAM,EAAE,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,EAAE;oBAC7D,EAAE,CAAC,UAAU,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;oBACxC,MAAM,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;oBACvC,EAAE,CAAC,SAAS,EAAE,CAAC;oBACf,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC;oBAC7B,wCAAwC;iBACzC;qBAAM,IAAI,MAAM,EAAE,CAAC,MAAM,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE;oBAClC,EAAE,CAAC,UAAU,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;oBACpC,MAAM,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;oBACpB,EAAE,CAAC,SAAS,EAAE,CAAC;iBAChB;qBAAM,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC,KAAK,EAAE,EAAE;oBACjC,EAAE,CAAC,UAAU,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;oBACpC,MAAM,EAAE,CAAC,OAAO,EAAE,CAAC;oBACnB,EAAE,CAAC,SAAS,EAAE,CAAC;iBAChB;qBAAM,IAAI,GAAG,KAAK,GAAG,IAAI,GAAG,KAAK,GAAG,EAAE;oBACrC,EAAE,CAAC,UAAU,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,CAAC;oBACpC,MAAM,EAAE,CAAC,OAAO,EAAE,CAAC;oBACnB,EAAE,CAAC,SAAS,EAAE,CAAC;oBACf,MAAM,cAAc,CAAC,EAAE,CAAC,CAAC;iBAC1B;qBAAM,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;oBACzB,MAAM,cAAc,CAAC,EAAE,CAAC,CAAC;iBAC1B;qBAAM,IAAI,GAAG,KAAK,GAAG,IAAI,GAAG,KAAK,IAAI,EAAE;oBACtC,MAAM,QAAQ,CAAC,EAAE,CAAC,CAAC;iBACpB;qBAAM;oBACL,MAAM,WAAW,CAAC,EAAE,CAAC,CAAC;iBACvB;gBACD,OAAO,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;aACzB;QACH,CAAC,CAAA;QAED,iBAAY,GAAqD,KAAK,EAAE,EAAE,EAAE,EAAE;YAC5E,IAAI,MAAM,GAAsB;gBAC9B,OAAO,EAAE,MAAM,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC;gBACpC,KAAK,EAAE,EAAE;aACV,CAAC;YAEF,oEAAoE;YAEpE,IAAI,EAAE,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACvB,OAAO,EAAE,IAAI,IAAI,EAAE;gBACjB,+BAA+B;gBAC/B,MAAM,EAAE,CAAC,iBAAiB,CAAC,CAAC,eAAe,CAAC,QAAQ,CAAC,EAAE,gBAAgB,CAAC,CAAC;gBACzE,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAE,CAAC,IAAI,KAAK,eAAe,CAAC,WAAW,EAAE;oBACzD,MAAM;iBACP;gBACD,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC;gBAChD,MAAM,QAAQ,GAAG,MAAM,EAAE,CAAC,OAAO,EAAmB,CAAC;gBACrD,MAAM,EAAE,CAAC,iBAAiB,CAAC,CAAC,eAAe,CAAC,IAAI,CAAC,EAAE,gBAAgB,CAAC,CAAC;gBAErE,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,WAAW,EAAE,QAAQ,CAAC,CAAC;gBACpD,2EAA2E;gBAC3E,EAAE,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;aACpB;YACD,OAAO,MAA2B,CAAC;QACrC,CAAC,CAAA;IA9ED,CAAC;IAgFO,eAAe,CAAC,MAAyB,EAC/C,WAAyC,EACzC,QAAuB;QACvB,MAAM,cAAc,GAAG,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,GAAG,KAAK,2BAA2B,CAAC,CAAC;QAC9F,MAAM,QAAQ,GAAG,cAAc,IAAI,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,QAAQ,CAAC;QAExE,IAAI,QAAQ,EAAE;YACZ,QAAQ,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,QAAQ,CAAC,CAAC;SACjE;QACD,MAAM,gBAAgB,GAAG,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,GAAG,KAAK,qBAAqB,CAAC,CAAC;QAC1F,IAAI,cAAkC,CAAC;QAEvC,IAAI,gBAAgB,IAAI,gBAAgB,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,YAAY,EAAE;YAClE,MAAM,CAAC,GAAG,2BAA2B,CAAC,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YACtE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;gBAC5B,cAAc,GAAG,cAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC9C,kBAAE,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;gBACxB,kBAAE,CAAC,aAAa,CAAC,cAAc,EAAE,QAAQ,CAAC,IAAI,CAAC,CAAC;gBAChD,GAAG,CAAC,IAAI,CAAC,cAAc,GAAG,aAAa,CAAC,CAAC;aAC1C;SACF;QAED,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC;YAChB,OAAO,EAAE,WAAW;YACpB,IAAI,EAAE,cAAc,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI;YAChD,IAAI,EAAE,cAAc,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,SAAS;SAClD,CAAC,CAAC;IACL,CAAC;IAEO,WAAW,CAAC,GAAW;QAC7B,MAAM,IAAI,GAAa,IAAI,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAE7C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;YAC1C,IAAI,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;SAC7B;QACD,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;IACvB,CAAC;IAEO,KAAK,CAAC,YAAY,CAAC,EAAmD;QAC5E,MAAM,OAAO,GAAqC,EAAE,CAAC;QACrD,IAAI,MAAM,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;QAE3B,OAAO,MAAM,IAAI,IAAI,EAAE;YACrB,IAAI,MAAM,CAAC,IAAI,KAAK,eAAe,CAAC,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAE,CAAC,IAAI,KAAK,eAAe,CAAC,GAAG,CAAC,EAAE;gBAC/G,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC;gBAExB,MAAM,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;gBACpB,MAAM,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBAEvB,IAAI,KAAK,GAAG,EAAc,CAAC;gBAC3B,MAAM,MAAM,GAAG,EAAC,GAAG,EAAE,KAAK,EAAC,CAAC;gBAC5B,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBACrB,IAAI,aAAa,GAAG,EAAE,CAAC;gBACvB,OAAO,MAAM,IAAI,IAAI,IAAI,MAAM,CAAC,IAAI,KAAK,eAAe,CAAC,IAAI,EAAE;oBAC7D,IAAI,MAAM,CAAC,IAAI,KAAK,eAAe,CAAC,GAAG,CAAC,EAAE;wBACxC,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;wBAC1B,aAAa,GAAG,EAAE,CAAC;wBACnB,MAAM,EAAE,CAAC,OAAO,EAAE,CAAC;wBACnB,MAAM,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;wBACvB,SAAS;qBACV;oBACD,aAAa,IAAI,CAAC,MAAM,EAAE,CAAC,OAAO,EAAE,CAAC,CAAC,IAAI,CAAC;oBAC3C,MAAM,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;iBACxB;gBACD,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;gBAC1B,IAAI,GAAG,CAAC,WAAW,EAAE,KAAK,cAAc,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,iBAAiB,EAAE;oBAC1E,IAAI,QAA4B,CAAC;oBACjC,KAAK,MAAM,SAAS,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;wBACtC,MAAM,CAAC,GAAG,2BAA2B,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;wBACtD,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;4BAC5B,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;4BAChB,MAAM;yBACP;qBACF;oBACD,IAAI,QAAQ,EAAE;wBACZ,IAAI,CAAC,WAAW,CAAC,IAAI,GAAG,QAAQ,CAAC,CAAC;qBACnC;iBACF;aAEF;iBAAM,IAAI,MAAM,EAAE,CAAC,UAAU,CAAkB,CAAC,eAAe,CAAC,IAAI,EAAE,eAAe,CAAC,IAAI,CAAC,EAAE,gBAAgB,CAAC,EAAE;gBAC/G,MAAM,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;gBACpB,IAAI,IAAI,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBACzB,OAAO,IAAI,IAAI,IAAI,CAAC,IAAI,KAAK,eAAe,CAAC,IAAI,EAAE;oBACjD,MAAM,EAAE,CAAC,OAAO,EAAE,CAAC;oBACnB,IAAI,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;iBACtB;gBACD,MAAM;aACP;iBAAM,IAAI,MAAM,EAAE,CAAC,UAAU,CAAC,CAAC,eAAe,CAAC,IAAI,CAAC,EAAE,gBAAgB,CAAC,EAAE;gBACxE,MAAM,EAAE,CAAC,OAAO,EAAE,CAAC;aACpB;iBAAM;gBACL,EAAE,CAAC,UAAU,CAAC,CAAC,MAAM,EAAE,CAAC,OAAO,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC;gBACzC,sBAAsB;aACvB;YACD,MAAM,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;SACxB;QACD,OAAO,OAAO,CAAC;IACjB,CAAC;IAED;;;OAGG;IACK,KAAK,CAAC,kBAAkB,CAAC,EAAgD;QAC/E,MAAM,EAAE,GAAG,EAAE,CAAC,UAAU,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC;QACpD,EAAE,CAAC,UAAU,GAAG,KAAK,CAAC;QACtB,MAAM,gBAAgB,GAAG,EAAE,CAAC,QAAQ,CAAC;QAErC,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC,IAAI,IAAI,EAAE;YAE9B,IAAI,MAAM,EAAE,CAAC,MAAM,CAAC,EAAE,EAAE,EAAE,EAAE,GAAG,IAAI,CAAC,QAAS,CAAC,EAAE;gBAC7C,EAA+B,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,gBAAgB,EAAE,EAAE,CAAC,QAAQ,GAAG,gBAAgB,CAAC,CAAC;gBAEvH,EAAE,CAAC,SAAS,EAAE,CAAC;gBAEf,EAAE,CAAC,UAAU,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;gBACpC,MAAM,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;gBACpB,EAAE,CAAC,SAAS,EAAE,CAAC;gBAEf,EAAE,CAAC,UAAU,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;gBACxC,MAAM,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,QAAS,CAAC,MAAM,CAAC,CAAC;gBACxC,EAAE,CAAC,SAAS,EAAE,CAAC;gBACf,MAAM;aACP;YACD,MAAM,EAAE,CAAC,OAAO,EAAE,CAAC;SACpB;IACH,CAAC;CAEF;AAED,KAAK,UAAU,QAAQ,CAAC,EAAgD;IACtE,EAAE,CAAC,UAAU,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;IACxC,MAAM,QAAQ,GAAG,MAAM,EAAE,CAAC,OAAO,EAAE,CAAC;IACpC,OAAO,IAAI,EAAE;QACX,MAAM,IAAI,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;QAC3B,IAAI,IAAI,IAAI,IAAI,EAAE;YAChB,OAAO,EAAE,CAAC,UAAU,EAAE,CAAC;SACxB;QACD,IAAI,IAAI,KAAK,UAAU,EAAE;YACvB,MAAM,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;SACrB;aAAM,IAAI,IAAI,KAAK,QAAQ,EAAE;YAC5B,MAAM,EAAE,CAAC,OAAO,EAAE,CAAC;YACnB,EAAE,CAAC,SAAS,EAAE,CAAC;YACf,MAAM;SACP;aAAM;YACL,MAAM,EAAE,CAAC,OAAO,EAAE,CAAC;SACpB;KACF;AACH,CAAC;AAED,KAAK,UAAU,cAAc,CAAC,EAAgD;IAC5E,GAAG;QACD,MAAM,IAAI,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;QAC3B,IAAI,IAAI,IAAI,IAAI;YAAE,OAAO;QACzB,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,EAAE;YACxC,MAAM,EAAE,CAAC,OAAO,EAAE,CAAC;SACpB;aAAM;YACL,MAAM;SACP;KACF,QAAQ,IAAI,EAAE;AACjB,CAAC;AAED,KAAK,UAAU,WAAW,CAAC,EAAgD;IACzE,EAAE,CAAC,UAAU,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;IACpC,MAAM,EAAE,CAAC,OAAO,EAAE,CAAC;IACnB,IAAI,IAAI,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;IACzB,IAAI,IAAI,GAAG,KAAK,CAAC;IACjB,OAAO,IAAI,IAAI,IAAI,EAAE;QACnB,QAAQ,IAAI,EAAE;YACZ,KAAK,UAAU,CAAC;YAChB,KAAK,QAAQ,CAAC;YACd,KAAK,WAAW,CAAC;YACjB,KAAK,WAAW;gBACd,IAAI,GAAG,IAAI,CAAC;gBACZ,EAAE,CAAC,SAAS,EAAE,CAAC;gBACf,MAAM;YACR,KAAK,EAAE;gBACL,oEAAoE;gBACpE,IAAI,CAAC,CAAC,MAAM,EAAE,CAAC,MAAM,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,CAAC,MAAM,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;oBAC9D,CAAC,CAAC,MAAM,EAAE,CAAC,MAAM,CAAC,EAAE,EAAE,EAAE,EAAE,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,CAAC,MAAM,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,EAAE;oBAChE,8EAA8E;oBAC9E,IAAI,GAAG,IAAI,CAAC;oBACZ,EAAE,CAAC,SAAS,EAAE,CAAC;oBACf,MAAM;iBACP;qBAAM;oBACL,MAAM,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;oBACpB,IAAI,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;oBACrB,MAAM;iBACP;YACH,KAAK,EAAE;gBACL,IAAI,CAAE,MAAM,EAAE,CAAC,MAAM,CAAC,EAAE,EAAE,EAAE,CAAC,IAAI,CAAE,MAAM,EAAE,CAAC,MAAM,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE;oBAC3D,IAAI,GAAG,IAAI,CAAC;oBACZ,EAAE,CAAC,SAAS,EAAE,CAAC;oBACf,MAAM;iBACP;qBAAM;oBACL,MAAM,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;oBACpB,IAAI,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;oBACrB,MAAM;iBACP;YACH;gBACE,MAAM,EAAE,CAAC,OAAO,EAAE,CAAC;gBACnB,IAAI,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;SACxB;QACD,IAAI,IAAI;YAAE,MAAM;KACjB;AACH,CAAC;AAED,0EAA0E;AAC1E,wCAAwC;AACxC,IAAI;AACJ,SAAS,gBAAgB,CAAI,EAAY,EAAE,IAAO;IAC/C,OAAO,EAAE,CAAC,IAAI,KAAK,IAAI,CAAC;AAC3B,CAAC;AAGD,SAAgB,KAAK,CAAC,QAAgB;IACpC,yEAAyE;IAEzE,MAAM,IAAI,GAAG,IAAI,gBAAgB,CAAC,QAAQ,CAAC,CAAC;IAE5C,MAAM,IAAI,GAAG,IAAA,SAAE,EAAC,QAAQ,CAAC,CAAC,IAAI,CAC5B,IAAA,qBAAS,EAAC,qBAAc,CAAC,EACzB,IAAA,4BAAS,EAA0B,cAAc,EAAE,CAAC,EAAE,EAAE,GAAG,EAAE,EAAE,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,EACzF,IAAA,eAAG,EAAC,KAAK,CAAC,EAAE;QACV,IAAI,KAAK,CAAC,MAAM;YACb,KAAgC,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,MAAO,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC;QAClG,OAAO,KAAK,CAAC,MAAM,CAAC;QACpB,OAAO,CAAC,KAA+B,CAAC,CAAC;IAC3C,CAAC,CAAC,EACF,IAAA,+BAAY,EAAC,eAAe,EAAE,EAAE,CAAC,EAAE,CAAC,IAAA,WAAI,EAAC,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC,CAAC,EAChE,IAAA,iBAAK,GAAE,CACR,CAAC,SAAS,EAAE,CAAC;IACd,OAAO,IAAI,CAAC;AACd,CAAC;AAlBD,sBAkBC","sourcesContent":["\nimport { ParseGrammar, ParseLex, Token,\n  mapChunks, mapChunksObs, LookAheadObservable } from '@wfh/plink/wfh/dist/async-LLn-parser';\nimport {queueScheduler, from, of} from 'rxjs';\nimport {observeOn, map, share} from 'rxjs/operators';\nimport _ from 'lodash';\nimport fs from 'fs-extra';\nimport Path from 'path';\nconst log = require('log4js').getLogger('@wfh/assets-processer.rfc822-parser');\n\nexport enum RCF822TokenType {\n  CRLF,\n  ':',\n  ';',\n  quoteStr,\n  ATOM,\n  BOUNDARY,\n  PART_BODY,\n  DOUBLE_DASH\n}\n\ninterface PartBodyToken extends Token<RCF822TokenType> {\n  data: Buffer;\n}\n\nconst CR = '\\r'.charCodeAt(0);\nconst LF = '\\n'.charCodeAt(0);\nconst BACK_SLASH = '\\\\'.charCodeAt(0);\nconst QUOTE_MARK1 = '\"'.charCodeAt(0);\nconst QUOTE_MARK2 = '\\''.charCodeAt(0);\nconst COLON_MARK = ':'.charCodeAt(0);\nconst SEMI_COL = ';'.charCodeAt(0);\nconst WS = ' '.charCodeAt(0);\nconst TAB = '\\t'.charCodeAt(0);\nconst DASH = '-'.charCodeAt(0);\n// const DASH = '-'.charCodeAt(0);\n\nconst TEMP_DIR = 'dist/assets-processer/rfc822';\nexport interface RCF822ParseResult {\n  headers: RCF822HeaderType[];\n  parts: {\n    headers: RCF822HeaderType[];\n    body?: Buffer;\n    file?: string;\n  }[];\n}\n\nexport interface RCF822HeaderType {\n  key: string;\n  value: string[];\n}\n\nclass RfcParserContext {\n  private boundary: number[] | undefined;\n\n  private multipartStarted = false;\n\n  constructor(private origBuffer: Uint8Array) {\n  }\n\n\n\n  parseLexer: ParseLex<number, RCF822TokenType> = async (la) => {\n    let chrCode = await la.la();\n    while (chrCode != null) {\n      const chr = String.fromCharCode(chrCode);\n      if (this.multipartStarted && await la.isNext(CR, LF, CR, LF)) {\n        // part header must be over\n        la.startToken(RCF822TokenType.CRLF);\n        await la.advance(2);\n        la.emitToken();\n\n        la.startToken(RCF822TokenType.CRLF);\n        await la.advance(2);\n        la.emitToken();\n        await this.parsePartBodyToken(la);\n\n      } else if (this.multipartStarted && await la.isNext(DASH, DASH)) {\n        la.startToken(RCF822TokenType.DOUBLE_DASH);\n        await la.advance(2); // end of whole message\n        la.emitToken();\n        break;\n      } else if (this.boundary && await la.isNext(...this.boundary)) {\n        la.startToken(RCF822TokenType.BOUNDARY);\n        await la.advance(this.boundary.length);\n        la.emitToken();\n        this.multipartStarted = true;\n        // console.log('multipartStarted true');\n      } else if (await la.isNext(CR, LF)) {\n        la.startToken(RCF822TokenType.CRLF);\n        await la.advance(2);\n        la.emitToken();\n      } else if ((await la.la()) === LF) {\n        la.startToken(RCF822TokenType.CRLF);\n        await la.advance();\n        la.emitToken();\n      } else if (chr === ':' || chr === ';') {\n        la.startToken(RCF822TokenType[chr]);\n        await la.advance();\n        la.emitToken();\n        await skipWhiteSpace(la);\n      } else if (/\\s/.test(chr)) {\n        await skipWhiteSpace(la);\n      } else if (chr === '\"' || chr === '\\'') {\n        await quoteStr(la);\n      } else {\n        await consumeAtom(la);\n      }\n      chrCode = await la.la();\n    }\n  }\n\n  parseGrammar: ParseGrammar<RCF822ParseResult, RCF822TokenType> = async (la) => {\n    let result: RCF822ParseResult = {\n      headers: await this.parseHeaders(la),\n      parts: []\n    };\n\n    // console.log('boundary:', String.fromCharCode(...this.boundary!));\n\n    let tk = await la.la();\n    while (tk != null) {\n      // console.log('tk:', tk.text);\n      await la.assertAdvanceWith([RCF822TokenType.BOUNDARY], compareTokenType);\n      if ((await la.la())!.type === RCF822TokenType.DOUBLE_DASH) {\n        break;\n      }\n      const partHeaders = await this.parseHeaders(la);\n      const partBody = await la.advance() as PartBodyToken;\n      await la.assertAdvanceWith([RCF822TokenType.CRLF], compareTokenType);\n\n      this.onParseEachPart(result, partHeaders, partBody);\n      // console.log('rfc token: ' + RCF822TokenType[(await la.advance()).type]);\n      tk = await la.la();\n    }\n    return result as RCF822ParseResult;\n  }\n\n  private onParseEachPart(result: RCF822ParseResult,\n    partHeaders: RCF822ParseResult['headers'],\n    partBody: PartBodyToken) {\n    const encodingHeader = partHeaders.find(header => header.key === 'Content-Transfer-Encoding');\n    const isBase64 = encodingHeader && encodingHeader.value[0] === 'base64';\n\n    if (isBase64) {\n      partBody.data = Buffer.from(partBody.data.toString(), 'base64');\n    }\n    const attachmentHeader = partHeaders.find(header => header.key === 'Content-Disposition');\n    let attachmentName: string | undefined;\n\n    if (attachmentHeader && attachmentHeader.value[0] === 'attachment') {\n      const m = /^([^=]*)=[\"]?([^\"]*)[\"]?$/.exec(attachmentHeader.value[1]);\n      if (m && m[1] === 'filename') {\n        attachmentName = Path.resolve(TEMP_DIR, m[2]);\n        fs.mkdirpSync(TEMP_DIR);\n        fs.writeFileSync(attachmentName, partBody.data);\n        log.info(attachmentName + ' is written');\n      }\n    }\n\n    result.parts.push({\n      headers: partHeaders,\n      body: attachmentName ? undefined : partBody.data,\n      file: attachmentName ? attachmentName : undefined\n    });\n  }\n\n  private setBoundary(str: string) {\n    const chrs: number[] = new Array(str.length);\n\n    for (let i = 0, l = str.length; i < l; i++) {\n      chrs[i] = str.charCodeAt(i);\n    }\n    this.boundary = chrs;\n  }\n\n  private async parseHeaders(la: Parameters<RfcParserContext['parseGrammar']>[0]) {\n    const headers: {key: string, value: string[]}[] = [];\n    let nextTk = await la.la();\n\n    while (nextTk != null) {\n      if (nextTk.type === RCF822TokenType.ATOM && (await la.la(2)) && (await la.la(2))!.type === RCF822TokenType[':']) {\n        const key = nextTk.text;\n\n        await la.advance(2);\n        nextTk = await la.la();\n\n        let value = [] as string[];\n        const header = {key, value};\n        headers.push(header);\n        let lastValueItem = '';\n        while (nextTk != null && nextTk.type !== RCF822TokenType.CRLF) {\n          if (nextTk.type === RCF822TokenType[';']) {\n            value.push(lastValueItem);\n            lastValueItem = '';\n            await la.advance();\n            nextTk = await la.la();\n            continue;\n          }\n          lastValueItem += (await la.advance()).text;\n          nextTk = await la.la();\n        }\n        value.push(lastValueItem);\n        if (key.toLowerCase() === 'content-type' && value[0] === 'multipart/mixed') {\n          let boundary: string | undefined;\n          for (const valueItem of value.slice(1)) {\n            const m = /^([^=]*)=[\"]?([^\"]*)[\"]?$/.exec(valueItem);\n            if (m && m[1] === 'boundary') {\n              boundary = m[2];\n              break;\n            }\n          }\n          if (boundary) {\n            this.setBoundary('--' + boundary);\n          }\n        }\n\n      } else if (await la.isNextWith<RCF822TokenType>([RCF822TokenType.CRLF, RCF822TokenType.CRLF], compareTokenType)) {\n        await la.advance(2);\n        let next = await la.la();\n        while (next && next.type === RCF822TokenType.CRLF) {\n          await la.advance();\n          next = await la.la();\n        }\n        break;\n      } else if (await la.isNextWith([RCF822TokenType.CRLF], compareTokenType)) {\n        await la.advance();\n      } else {\n        la.throwError((await la.advance()).text);\n        // await la.advance();\n      }\n      nextTk = await la.la();\n    }\n    return headers;\n  }\n\n  /**\n   * Generate tokens: PART_BODY CRLF BOUNDARY\n   * @param la \n   */\n  private async parsePartBodyToken(la: LookAheadObservable<number, RCF822TokenType>) {\n    const tk = la.startToken(RCF822TokenType.PART_BODY);\n    tk.trackValue = false;\n    const origBufferOffset = la.position;\n\n    while ((await la.la()) != null) {\n\n      if (await la.isNext(CR, LF, ...this.boundary!)) {\n        (tk as unknown as PartBodyToken).data = Buffer.from(this.origBuffer, origBufferOffset, la.position - origBufferOffset);\n\n        la.emitToken();\n\n        la.startToken(RCF822TokenType.CRLF);\n        await la.advance(2);\n        la.emitToken();\n\n        la.startToken(RCF822TokenType.BOUNDARY);\n        await la.advance(this.boundary!.length);\n        la.emitToken();\n        break;\n      }\n      await la.advance();\n    }\n  }\n\n}\n\nasync function quoteStr(la: LookAheadObservable<number, RCF822TokenType>) {\n  la.startToken(RCF822TokenType.quoteStr);\n  const openChar = await la.advance();\n  while (true) {\n    const next = await la.la();\n    if (next == null) {\n      return la.throwError();\n    }\n    if (next === BACK_SLASH) {\n      await la.advance(2);\n    } else if (next === openChar) {\n      await la.advance();\n      la.emitToken();\n      break;\n    } else {\n      await la.advance();\n    }\n  }\n}\n\nasync function skipWhiteSpace(la: LookAheadObservable<number, RCF822TokenType>) {\n  do {\n    const code = await la.la();\n    if (code == null) return;\n    if (/\\s/.test(String.fromCharCode(code))) {\n      await la.advance();\n    } else {\n      break;\n    }\n  } while (true);\n}\n\nasync function consumeAtom(la: LookAheadObservable<number, RCF822TokenType>) {\n  la.startToken(RCF822TokenType.ATOM);\n  await la.advance();\n  let code = await la.la();\n  let emit = false;\n  while (code != null) {\n    switch (code) {\n      case COLON_MARK:\n      case SEMI_COL:\n      case QUOTE_MARK1:\n      case QUOTE_MARK2:\n        emit = true;\n        la.emitToken();\n        break;\n      case CR:\n        // console.log((await la.la()), (await la.la(2)), (await la.la(3)));\n        if (!(await la.isNext(CR, LF, WS)) && !(await la.isNext(CR, WS)) &&\n          !(await la.isNext(CR, LF, TAB)) && !(await la.isNext(CR, TAB))) {\n          // console.log('emit: ', (await la.la()), (await la.la(2)), (await la.la(3)));\n          emit = true;\n          la.emitToken();\n          break;\n        } else {\n          await la.advance(3);\n          code = await la.la();\n          break;\n        }\n      case LF:\n        if (! await la.isNext(LF, WS) && ! await la.isNext(LF, TAB)) {\n          emit = true;\n          la.emitToken();\n          break;\n        } else {\n          await la.advance(2);\n          code = await la.la();\n          break;\n        }\n      default:\n        await la.advance();\n        code = await la.la();\n    }\n    if (emit) break;\n  }\n}\n\n// async function parseMultipart(la: Parameters<typeof parseGrammar>[0]) {\n//   while (await la.isNext(DASH, DASH))\n// }\nfunction compareTokenType<T>(tk: Token<T>, type: T) {\n   return tk.type === type;\n}\n\n\nexport function parse(readable: Buffer) {\n  // fs.writeFileSync('email-temp.txt', readable.toString('utf8'), 'utf8');\n\n  const pctx = new RfcParserContext(readable);\n\n  const done = of(readable).pipe(\n    observeOn(queueScheduler),\n    mapChunks<number, RCF822TokenType>('RCF822-lexer', (la, sub) => pctx.parseLexer(la, sub)),\n    map(chunk => {\n      if (chunk.values)\n        (chunk as Token<RCF822TokenType>).text = Buffer.from(Uint8Array.from(chunk.values!)).toString();\n      delete chunk.values;\n      return [chunk as Token<RCF822TokenType>];\n    }),\n    mapChunksObs('RCF822-parser', la => from(pctx.parseGrammar(la))),\n    share()\n  ).toPromise();\n  return done;\n}\n"]}