"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.connectImap = exports.parseLinesOfTokens = exports.createServerDataHandler = exports.ImapTokenType = void 0;
const async_LLn_parser_1 = require("@wfh/plink/wfh/dist/async-LLn-parser");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const tls_1 = require("tls");
// import fs from 'fs';
// let fileWritingIdx = 1;
// import {Subscriber} from 'rxjs';
var ImapTokenType;
(function (ImapTokenType) {
    ImapTokenType[ImapTokenType["number"] = 1] = "number";
    ImapTokenType[ImapTokenType["stringLit"] = 2] = "stringLit";
    ImapTokenType[ImapTokenType["stringQuote"] = 3] = "stringQuote";
    ImapTokenType[ImapTokenType["("] = 4] = "(";
    ImapTokenType[ImapTokenType[")"] = 5] = ")";
    ImapTokenType[ImapTokenType["atom"] = 6] = "atom";
    ImapTokenType[ImapTokenType["CRLF"] = 7] = "CRLF";
    // nil
})(ImapTokenType = exports.ImapTokenType || (exports.ImapTokenType = {}));
const R_BRACE = '}'.charCodeAt(0);
const CR = '\r'.charCodeAt(0);
const LF = '\n'.charCodeAt(0);
const parseLex = async function (reply, sub) {
    // const origWrite = reply._writeAndResolve;
    // reply._writeAndResolve = function(bytes) {
    //   fs.writeFileSync('imap-msg-parser.parseLex.log.txt', Buffer.from(Array.from(bytes)).toString('utf8'), {flag: 'a'});
    //   origWrite.apply(this, arguments);
    // };
    let nextByte = await reply.la();
    while (nextByte != null) {
        const next = String.fromCharCode(nextByte);
        if (' ' === next) {
            await reply.advance();
            // skip space char
        }
        else if (/[0-9]/.test(next)) {
            reply.startToken(ImapTokenType.number);
            await reply.advance();
            nextByte = await reply.la();
            while (nextByte != null && /[0-9.]/.test(String.fromCharCode(nextByte))) {
                await reply.advance();
                nextByte = await reply.la();
            }
            reply.emitToken();
        }
        else if ('\r' === next) {
            reply.startToken(ImapTokenType.CRLF);
            await reply.advance();
            const b = await reply.la();
            if (b != null && String.fromCharCode(b) === '\n')
                await reply.advance();
            reply.emitToken();
        }
        else if ('\n' === next) {
            reply.startToken(ImapTokenType.CRLF);
            await reply.advance();
            reply.emitToken();
        }
        else if ('"' === next) {
            reply.startToken(ImapTokenType.stringQuote);
            const openChar = await reply.advance();
            while (true) {
                const la = await reply.la();
                if (la == null) {
                    return reply.throwError();
                }
                if (String.fromCharCode(la) === '\\') {
                    await reply.advance(2);
                }
                else if (la === openChar) {
                    await reply.advance();
                    reply.emitToken();
                    break;
                }
                else {
                    await reply.advance();
                }
            }
        }
        else if ('{' === next) {
            const next2 = await reply.la(2);
            if (next2 != null && /\d/.test(String.fromCharCode(next2))) {
                await parseLiteralString(reply);
            }
            else {
                await parseAtom(reply);
            }
        }
        else if ('(' === next || ')' === next) {
            reply.startToken(ImapTokenType[next]);
            await reply.advance();
            reply.emitToken();
        }
        else {
            await parseAtom(reply);
        }
        nextByte = await reply.la();
    }
};
async function parseAtom(la) {
    la.startToken(ImapTokenType.atom);
    await la.advance();
    let nextByte = await la.la();
    while (nextByte != null && /[^\s{[()"]/.test(String.fromCharCode(nextByte))) {
        await la.advance();
        nextByte = await la.la();
    }
    la.emitToken();
}
async function parseLiteralString(reply) {
    const chunk = reply.startToken(ImapTokenType.stringLit, false);
    await reply.advance();
    let numStr = String.fromCharCode(await reply.advance());
    let next = await reply.la();
    while (next && next !== R_BRACE) {
        numStr += String.fromCharCode(next);
        await reply.advance();
        next = await reply.la();
    }
    await reply.advance();
    next = await reply.la();
    if (next == null)
        return reply.throwError();
    while (next === CR || next === LF) {
        await reply.advance();
        next = await reply.la();
    }
    const numByte = parseInt(numStr, 10);
    const buf = Buffer.alloc(numByte);
    let i = 0;
    // console.time('stringlit');
    while (i < numByte) {
        next = await reply.la();
        if (next == null) {
            return reply.throwError();
        }
        const char = await reply.advance();
        buf.writeUInt8(char, i);
        i++;
    }
    // console.timeEnd('stringlit');
    chunk.data = buf;
    reply.emitToken();
}
async function parseLine(la) {
    let buf;
    let word = await la.la();
    while (true) {
        if (word == null) {
            return;
        }
        if (buf == null)
            buf = [];
        if (word.type === ImapTokenType.CRLF) {
            await la.advance();
            return buf;
        }
        buf.push(word);
        await la.advance();
        word = await la.la();
    }
}
async function parseLines(lineSubject, la) {
    let line;
    do {
        line = await parseLine(la);
        if (line == null) {
            lineSubject.complete();
            break;
        }
        lineSubject.next(line);
    } while (true);
}
function createServerDataHandler() {
    const input = new rxjs_1.Subject();
    const parseServerReply = async (la) => {
        const lineSubject = new rxjs_1.Subject();
        parseLines(lineSubject, la);
        return lineSubject;
    };
    // parser('IMAP', input, parseLex, null, parseServerReply);
    const name = 'IMAP';
    const output = input.pipe((0, operators_1.observeOn)(rxjs_1.queueScheduler), (0, operators_1.takeWhile)(data => data != null), 
    // tap(data => fs.writeFileSync('imap-msg-parser-log.txt', data.toString('utf8'), {flag: 'a'})),
    (0, async_LLn_parser_1.mapChunks)(name + '-lexer', parseLex), (0, operators_1.map)(chunk => {
        const buf = Buffer.from(Uint8Array.from(chunk.values));
        chunk.text = buf.toString('utf8');
        delete chunk.values;
        return chunk;
    }), (0, operators_1.map)(token => [token]), (0, async_LLn_parser_1.mapChunksObs)(name + '-parser', (la) => (0, rxjs_1.from)(parseServerReply(la))), (0, operators_1.concatMap)(lines => lines), (0, operators_1.share)());
    return {
        input: (data) => input.next(data),
        output
    };
}
exports.createServerDataHandler = createServerDataHandler;
/**
 *
 * @param lines createServerDataHandler().output
 * @param parseLine return null/undefined to continue to wait for next line, or it will stop waiting for next line.
 */
function parseLinesOfTokens(lines, parseLine) {
    return lines.pipe((0, operators_1.concatMap)(line => {
        const la = new async_LLn_parser_1.LookAhead('imap reply line');
        la._write(line);
        la._final();
        return (0, rxjs_1.from)(parseLine(la));
    }), 
    // filter(res => res == null),
    (0, operators_1.takeWhile)(res => res == null, true), (0, operators_1.takeLast)(1)).toPromise();
}
exports.parseLinesOfTokens = parseLinesOfTokens;
async function connectImap(address) {
    const handler = createServerDataHandler();
    let socket;
    try {
        socket = await new Promise((resolve, reject) => {
            const socket = (0, tls_1.connect)({
                host: address, port: 993,
                enableTrace: true
            });
            socket.on('secureConnect', () => {
                // eslint-disable-next-line no-console
                console.log('connected', socket.authorized ? 'authorized' : 'unauthorized');
                resolve(socket);
            })
                .on('error', err => reject(err))
                .on('timeout', () => reject(new Error('Timeout')));
            socket.on('data', (data) => handler.input(data));
        });
    }
    catch (ex) {
        if (socket)
            socket.end();
        throw ex;
    }
    await new Promise(resolve => setTimeout(resolve, 3000));
    handler.input(null);
    socket.end();
}
exports.connectImap = connectImap;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW1hcC1tc2ctcGFyc2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiaW1hcC1tc2ctcGFyc2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDJFQUF5SDtBQUN6SCwrQkFBaUU7QUFDakUsOENBQXFGO0FBQ3JGLDZCQUEwRTtBQUMxRSx1QkFBdUI7QUFFdkIsMEJBQTBCO0FBQzFCLG1DQUFtQztBQUVuQyxJQUFZLGFBU1g7QUFURCxXQUFZLGFBQWE7SUFDdkIscURBQVUsQ0FBQTtJQUNWLDJEQUFTLENBQUE7SUFDVCwrREFBVyxDQUFBO0lBQ1gsMkNBQUcsQ0FBQTtJQUNILDJDQUFHLENBQUE7SUFDSCxpREFBSSxDQUFBO0lBQ0osaURBQUksQ0FBQTtJQUNKLE1BQU07QUFDUixDQUFDLEVBVFcsYUFBYSxHQUFiLHFCQUFhLEtBQWIscUJBQWEsUUFTeEI7QUFPRCxNQUFNLE9BQU8sR0FBRyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2xDLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDOUIsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUU5QixNQUFNLFFBQVEsR0FBb0MsS0FBSyxXQUFVLEtBQUssRUFBRSxHQUFHO0lBQ3pFLDRDQUE0QztJQUM1Qyw2Q0FBNkM7SUFDN0Msd0hBQXdIO0lBQ3hILHNDQUFzQztJQUN0QyxLQUFLO0lBRUwsSUFBSSxRQUFRLEdBQUksTUFBTSxLQUFLLENBQUMsRUFBRSxFQUFFLENBQUM7SUFDakMsT0FBTyxRQUFRLElBQUksSUFBSSxFQUFFO1FBQ3ZCLE1BQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDM0MsSUFBSSxHQUFHLEtBQUssSUFBSSxFQUFFO1lBQ2hCLE1BQU0sS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ3RCLGtCQUFr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QUU7Z0JBQzlCLHNDQUFzQztnQkFDdEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQztnQkFDNUUsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ2xCLENBQUMsQ0FBQztpQkFDRCxFQUFFLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2lCQUMvQixFQUFFLENBQUMsU0FBUyxFQUFFLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbkQsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFZLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUMzRCxDQUFDLENBQUMsQ0FBQztLQUVKO0lBQUMsT0FBTyxFQUFFLEVBQUU7UUFDWCxJQUFJLE1BQU07WUFDUixNQUFNLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDZixNQUFNLEVBQUUsQ0FBQztLQUNWO0lBQ0QsTUFBTSxJQUFJLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUN4RCxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3BCLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNmLENBQUM7QUE1QkQsa0NBNEJDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFyc2VHcmFtbWFyLCBQYXJzZUxleCwgVG9rZW4sIExvb2tBaGVhZCwgbWFwQ2h1bmtzLCBtYXBDaHVua3NPYnMgfSBmcm9tICdAd2ZoL3BsaW5rL3dmaC9kaXN0L2FzeW5jLUxMbi1wYXJzZXInO1xuaW1wb3J0IHsgU3ViamVjdCwgT2JzZXJ2YWJsZSwgcXVldWVTY2hlZHVsZXIsIGZyb20gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7b2JzZXJ2ZU9uLCBtYXAsIHRha2VXaGlsZSwgY29uY2F0TWFwLCB0YWtlTGFzdCwgc2hhcmV9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IGNvbm5lY3QgYXMgdHNsQ29ubmVjdCwgQ29ubmVjdGlvbk9wdGlvbnMsIFRMU1NvY2tldCB9IGZyb20gJ3Rscyc7XG4vLyBpbXBvcnQgZnMgZnJvbSAnZnMnO1xuXG4vLyBsZXQgZmlsZVdyaXRpbmdJZHggPSAxO1xuLy8gaW1wb3J0IHtTdWJzY3JpYmVyfSBmcm9tICdyeGpzJztcblxuZXhwb3J0IGVudW0gSW1hcFRva2VuVHlwZSB7XG4gIG51bWJlciA9IDEsXG4gIHN0cmluZ0xpdCxcbiAgc3RyaW5nUXVvdGUsXG4gICcoJyxcbiAgJyknLFxuICBhdG9tLCAvLyBBVE9NIG9yIE5JTFxuICBDUkxGXG4gIC8vIG5pbFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0cmluZ0xpdCBleHRlbmRzIFRva2VuPEltYXBUb2tlblR5cGUuc3RyaW5nTGl0PiB7XG4gIGRhdGE6IEJ1ZmZlcjtcbn1cblxuXG5jb25zdCBSX0JSQUNFID0gJ30nLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBDUiA9ICdcXHInLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBMRiA9ICdcXG4nLmNoYXJDb2RlQXQoMCk7XG5cbmNvbnN0IHBhcnNlTGV4OiBQYXJzZUxleDxudW1iZXIsIEltYXBUb2tlblR5cGU+ID0gYXN5bmMgZnVuY3Rpb24ocmVwbHksIHN1Yikge1xuICAvLyBjb25zdCBvcmlnV3JpdGUgPSByZXBseS5fd3JpdGVBbmRSZXNvbHZlO1xuICAvLyByZXBseS5fd3JpdGVBbmRSZXNvbHZlID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgLy8gICBmcy53cml0ZUZpbGVTeW5jKCdpbWFwLW1zZy1wYXJzZXIucGFyc2VMZXgubG9nLnR4dCcsIEJ1ZmZlci5mcm9tKEFycmF5LmZyb20oYnl0ZXMpKS50b1N0cmluZygndXRmOCcpLCB7ZmxhZzogJ2EnfSk7XG4gIC8vICAgb3JpZ1dyaXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIC8vIH07XG5cbiAgbGV0IG5leHRCeXRlID0gIGF3YWl0IHJlcGx5LmxhKCk7XG4gIHdoaWxlIChuZXh0Qnl0ZSAhPSBudWxsKSB7XG4gICAgY29uc3QgbmV4dCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dEJ5dGUpO1xuICAgIGlmICgnICcgPT09IG5leHQpIHtcbiAgICAgIGF3YWl0IHJlcGx5LmFkdmFuY2UoKTtcbiAgICAgIC8vIHNraXAgc3BhY2UgY2hhclxuICAgIH0gZWxzZSBpZiAoL1swLTldLy50ZXN0KG5leHQpKSB7XG4gICAgICByZXBseS5zdGFydFRva2VuKEltYXBUb2tlblR5cGUubnVtYmVyKTtcbiAgICAgIGF3YWl0IHJlcGx5LmFkdmFuY2UoKTtcbiAgICAgIG5leHRCeXRlID0gYXdhaXQgcmVwbHkubGEoKTtcbiAgICAgIHdoaWxlIChuZXh0Qnl0ZSAhPSBudWxsICYmIC9bMC05Ll0vLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Qnl0ZSkpKSB7XG4gICAgICAgIGF3YWl0IHJlcGx5LmFkdmFuY2UoKTtcbiAgICAgICAgbmV4dEJ5dGUgPSBhd2FpdCByZXBseS5sYSgpO1xuICAgICAgfVxuICAgICAgcmVwbHkuZW1pdFRva2VuKCk7XG4gICAgfSBlbHNlIGlmICgnXFxyJyA9PT0gbmV4dCkge1xuICAgICAgcmVwbHkuc3RhcnRUb2tlbihJbWFwVG9rZW5UeXBlLkNSTEYpO1xuICAgICAgYXdhaXQgcmVwbHkuYWR2YW5jZSgpO1xuICAgICAgY29uc3QgYiA9IGF3YWl0IHJlcGx5LmxhKCk7XG4gICAgICBpZiAoYiAhPSBudWxsICYmIFN0cmluZy5mcm9tQ2hhckNvZGUoYikgPT09ICdcXG4nKVxuICAgICAgICBhd2FpdCByZXBseS5hZHZhbmNlKCk7XG4gICAgICByZXBseS5lbWl0VG9rZW4oKTtcbiAgICB9IGVsc2UgaWYgKCdcXG4nID09PSBuZXh0KSB7XG4gICAgICByZXBseS5zdGFydFRva2VuKEltYXBUb2tlblR5cGUuQ1JMRik7XG4gICAgICBhd2FpdCByZXBseS5hZHZhbmNlKCk7XG4gICAgICByZXBseS5lbWl0VG9rZW4oKTtcbiAgICB9IGVsc2UgaWYgKCdcIicgPT09IG5leHQpIHtcbiAgICAgIHJlcGx5LnN0YXJ0VG9rZW4oSW1hcFRva2VuVHlwZS5zdHJpbmdRdW90ZSk7XG4gICAgICBjb25zdCBvcGVuQ2hhciA9IGF3YWl0IHJlcGx5LmFkdmFuY2UoKTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IGxhID0gYXdhaXQgcmVwbHkubGEoKTtcbiAgICAgICAgaWYgKGxhID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gcmVwbHkudGhyb3dFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChTdHJpbmcuZnJvbUNoYXJDb2RlKGxhKSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgYXdhaXQgcmVwbHkuYWR2YW5jZSgyKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYSA9PT0gb3BlbkNoYXIpIHtcbiAgICAgICAgICBhd2FpdCByZXBseS5hZHZhbmNlKCk7XG4gICAgICAgICAgcmVwbHkuZW1pdFRva2VuKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXdhaXQgcmVwbHkuYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgneycgPT09IG5leHQpIHtcbiAgICAgIGNvbnN0IG5leHQyID0gYXdhaXQgcmVwbHkubGEoMik7XG4gICAgICBpZiAobmV4dDIgIT0gbnVsbCAmJiAvXFxkLy50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dDIpKSkge1xuICAgICAgICBhd2FpdCBwYXJzZUxpdGVyYWxTdHJpbmcocmVwbHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgcGFyc2VBdG9tKHJlcGx5KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCcoJyA9PT0gbmV4dCB8fCAnKScgPT09IG5leHQpIHtcbiAgICAgIHJlcGx5LnN0YXJ0VG9rZW4oSW1hcFRva2VuVHlwZVtuZXh0XSk7XG4gICAgICBhd2FpdCByZXBseS5hZHZhbmNlKCk7XG4gICAgICByZXBseS5lbWl0VG9rZW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgcGFyc2VBdG9tKHJlcGx5KTtcbiAgICB9XG4gICAgbmV4dEJ5dGUgPSAgYXdhaXQgcmVwbHkubGEoKTtcbiAgfVxufTtcblxuYXN5bmMgZnVuY3Rpb24gcGFyc2VBdG9tKGxhOiBQYXJhbWV0ZXJzPFBhcnNlTGV4PG51bWJlciwgSW1hcFRva2VuVHlwZT4+WzBdKSB7XG4gIGxhLnN0YXJ0VG9rZW4oSW1hcFRva2VuVHlwZS5hdG9tKTtcbiAgYXdhaXQgbGEuYWR2YW5jZSgpO1xuICBsZXQgbmV4dEJ5dGUgPSBhd2FpdCBsYS5sYSgpO1xuICB3aGlsZSAobmV4dEJ5dGUgIT0gbnVsbCAmJiAvW15cXHN7WygpXCJdLy50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dEJ5dGUpKSkge1xuICAgIGF3YWl0IGxhLmFkdmFuY2UoKTtcbiAgICBuZXh0Qnl0ZSA9IGF3YWl0IGxhLmxhKCk7XG4gIH1cbiAgbGEuZW1pdFRva2VuKCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBhcnNlTGl0ZXJhbFN0cmluZyhyZXBseTogUGFyYW1ldGVyczxQYXJzZUxleDxudW1iZXIsIEltYXBUb2tlblR5cGU+PlswXSkge1xuICBjb25zdCBjaHVuayA9IHJlcGx5LnN0YXJ0VG9rZW4oSW1hcFRva2VuVHlwZS5zdHJpbmdMaXQsIGZhbHNlKTtcbiAgYXdhaXQgcmVwbHkuYWR2YW5jZSgpO1xuICBsZXQgbnVtU3RyID0gU3RyaW5nLmZyb21DaGFyQ29kZShhd2FpdCByZXBseS5hZHZhbmNlKCkpO1xuICBsZXQgbmV4dCA9IGF3YWl0IHJlcGx5LmxhKCk7XG4gIHdoaWxlIChuZXh0ICYmIG5leHQgIT09IFJfQlJBQ0UpIHtcbiAgICBudW1TdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0KTtcbiAgICBhd2FpdCByZXBseS5hZHZhbmNlKCk7XG4gICAgbmV4dCA9IGF3YWl0IHJlcGx5LmxhKCk7XG4gIH1cbiAgYXdhaXQgcmVwbHkuYWR2YW5jZSgpO1xuICBuZXh0ID0gYXdhaXQgcmVwbHkubGEoKTtcbiAgaWYgKG5leHQgPT0gbnVsbClcbiAgICByZXR1cm4gcmVwbHkudGhyb3dFcnJvcigpO1xuICB3aGlsZSAobmV4dCA9PT0gQ1IgfHwgbmV4dCA9PT0gTEYpIHtcbiAgICBhd2FpdCByZXBseS5hZHZhbmNlKCk7XG4gICAgbmV4dCA9IGF3YWl0IHJlcGx5LmxhKCk7XG4gIH1cblxuICBjb25zdCBudW1CeXRlID0gcGFyc2VJbnQobnVtU3RyLCAxMCk7XG4gIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvYyhudW1CeXRlKTtcblxuICBsZXQgaSA9IDA7XG4gIC8vIGNvbnNvbGUudGltZSgnc3RyaW5nbGl0Jyk7XG4gIHdoaWxlIChpIDwgbnVtQnl0ZSkge1xuICAgIG5leHQgPSBhd2FpdCByZXBseS5sYSgpO1xuICAgIGlmIChuZXh0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiByZXBseS50aHJvd0Vycm9yKCk7XG4gICAgfVxuICAgIGNvbnN0IGNoYXIgPSBhd2FpdCByZXBseS5hZHZhbmNlKCk7XG4gICAgYnVmLndyaXRlVUludDgoY2hhciwgaSk7XG4gICAgaSsrO1xuICB9XG4gIC8vIGNvbnNvbGUudGltZUVuZCgnc3RyaW5nbGl0Jyk7XG4gIChjaHVuayBhcyBTdHJpbmdMaXQpLmRhdGEgPSBidWY7XG4gIHJlcGx5LmVtaXRUb2tlbigpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBwYXJzZUxpbmUobGE6IFBhcmFtZXRlcnM8KHR5cGVvZiBwYXJzZUxpbmVzKT5bMV0pOlxuUHJvbWlzZTxUb2tlbjxJbWFwVG9rZW5UeXBlPltdIHwgdW5kZWZpbmVkPiB7XG4gIGxldCBidWY6IFRva2VuPEltYXBUb2tlblR5cGU+W10gfCB1bmRlZmluZWQ7XG4gIGxldCB3b3JkID0gYXdhaXQgbGEubGEoKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAod29yZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChidWYgPT0gbnVsbCkgYnVmID0gW107XG4gICAgaWYgKHdvcmQudHlwZSA9PT0gSW1hcFRva2VuVHlwZS5DUkxGKSB7XG4gICAgICBhd2FpdCBsYS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICBidWYucHVzaCh3b3JkKTtcbiAgICBhd2FpdCBsYS5hZHZhbmNlKCk7XG4gICAgd29yZCA9IGF3YWl0IGxhLmxhKCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcGFyc2VMaW5lcyhsaW5lU3ViamVjdDogU3ViamVjdDxUb2tlbjxJbWFwVG9rZW5UeXBlPltdPiwgbGE6IExvb2tBaGVhZDxUb2tlbjxJbWFwVG9rZW5UeXBlPiwgYW55Pikge1xuICBsZXQgbGluZTogVG9rZW48SW1hcFRva2VuVHlwZT5bXSB8IHVuZGVmaW5lZDtcbiAgZG8ge1xuICAgIGxpbmUgPSBhd2FpdCBwYXJzZUxpbmUobGEpO1xuICAgIGlmIChsaW5lID09IG51bGwpIHtcbiAgICAgIGxpbmVTdWJqZWN0LmNvbXBsZXRlKCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbGluZVN1YmplY3QubmV4dChsaW5lKTtcbiAgfSB3aGlsZSAodHJ1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZXJ2ZXJEYXRhSGFuZGxlcigpOiB7aW5wdXQ6IChidWY6IEJ1ZmZlciB8IG51bGwpID0+dm9pZCwgb3V0cHV0OiBPYnNlcnZhYmxlPFRva2VuPEltYXBUb2tlblR5cGU+W10+fSB7XG4gIGNvbnN0IGlucHV0ID0gbmV3IFN1YmplY3Q8QnVmZmVyIHwgbnVsbD4oKTtcblxuICBjb25zdCBwYXJzZVNlcnZlclJlcGx5OiBQYXJzZUdyYW1tYXI8U3ViamVjdDxUb2tlbjxJbWFwVG9rZW5UeXBlPltdPiwgSW1hcFRva2VuVHlwZT4gPSBhc3luYyAobGEpID0+IHtcbiAgICBjb25zdCBsaW5lU3ViamVjdCA9IG5ldyBTdWJqZWN0PFRva2VuPEltYXBUb2tlblR5cGU+W10+KCk7XG4gICAgcGFyc2VMaW5lcyhsaW5lU3ViamVjdCwgbGEpO1xuICAgIHJldHVybiBsaW5lU3ViamVjdDtcbiAgfTtcblxuICAvLyBwYXJzZXIoJ0lNQVAnLCBpbnB1dCwgcGFyc2VMZXgsIG51bGwsIHBhcnNlU2VydmVyUmVwbHkpO1xuICBjb25zdCBuYW1lID0gJ0lNQVAnO1xuXG4gIGNvbnN0IG91dHB1dCA9IGlucHV0LnBpcGUoXG4gICAgb2JzZXJ2ZU9uKHF1ZXVlU2NoZWR1bGVyKSxcbiAgICB0YWtlV2hpbGU8QnVmZmVyPihkYXRhID0+IGRhdGEgIT0gbnVsbCksXG4gICAgLy8gdGFwKGRhdGEgPT4gZnMud3JpdGVGaWxlU3luYygnaW1hcC1tc2ctcGFyc2VyLWxvZy50eHQnLCBkYXRhLnRvU3RyaW5nKCd1dGY4JyksIHtmbGFnOiAnYSd9KSksXG4gICAgbWFwQ2h1bmtzKG5hbWUgKyAnLWxleGVyJywgcGFyc2VMZXgpLFxuICAgIG1hcChjaHVuayA9PiB7XG4gICAgICBjb25zdCBidWYgPSBCdWZmZXIuZnJvbShVaW50OEFycmF5LmZyb20oY2h1bmsudmFsdWVzISkpO1xuICAgICAgKGNodW5rIGFzIFRva2VuPEltYXBUb2tlblR5cGU+KS50ZXh0ID0gYnVmLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgICBkZWxldGUgY2h1bmsudmFsdWVzO1xuICAgICAgcmV0dXJuIGNodW5rIGFzIFRva2VuPEltYXBUb2tlblR5cGU+O1xuICAgIH0pLFxuICAgIG1hcCh0b2tlbiA9PiBbdG9rZW5dKSxcbiAgICBtYXBDaHVua3NPYnMobmFtZSArICctcGFyc2VyJywgKGxhKSA9PiBmcm9tKHBhcnNlU2VydmVyUmVwbHkobGEpKSksXG4gICAgY29uY2F0TWFwKGxpbmVzID0+IGxpbmVzKSxcbiAgICBzaGFyZSgpXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICBpbnB1dDogKGRhdGEpID0+IGlucHV0Lm5leHQoZGF0YSksXG4gICAgb3V0cHV0XG4gIH07XG59XG5cbi8qKlxuICogXG4gKiBAcGFyYW0gbGluZXMgY3JlYXRlU2VydmVyRGF0YUhhbmRsZXIoKS5vdXRwdXRcbiAqIEBwYXJhbSBwYXJzZUxpbmUgcmV0dXJuIG51bGwvdW5kZWZpbmVkIHRvIGNvbnRpbnVlIHRvIHdhaXQgZm9yIG5leHQgbGluZSwgb3IgaXQgd2lsbCBzdG9wIHdhaXRpbmcgZm9yIG5leHQgbGluZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTGluZXNPZlRva2VucyhsaW5lczogT2JzZXJ2YWJsZTxUb2tlbjxJbWFwVG9rZW5UeXBlPltdPixcbiAgcGFyc2VMaW5lOiAobGE6IExvb2tBaGVhZDxUb2tlbjxJbWFwVG9rZW5UeXBlPj4pID0+IFByb21pc2U8YW55IHwgbnVsbCB8IHZvaWQ+KSB7XG4gIHJldHVybiBsaW5lcy5waXBlKFxuICAgIGNvbmNhdE1hcChsaW5lID0+IHtcbiAgICAgIGNvbnN0IGxhID0gbmV3IExvb2tBaGVhZDxUb2tlbjxJbWFwVG9rZW5UeXBlPj4oJ2ltYXAgcmVwbHkgbGluZScpO1xuICAgICAgbGEuX3dyaXRlKGxpbmUpO1xuICAgICAgbGEuX2ZpbmFsKCk7XG4gICAgICByZXR1cm4gZnJvbShwYXJzZUxpbmUobGEpKTtcbiAgICB9KSxcbiAgICAvLyBmaWx0ZXIocmVzID0+IHJlcyA9PSBudWxsKSxcbiAgICB0YWtlV2hpbGUocmVzID0+IHJlcyA9PSBudWxsLCB0cnVlKSxcbiAgICB0YWtlTGFzdCgxKVxuICApLnRvUHJvbWlzZSgpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29ubmVjdEltYXAoYWRkcmVzczogc3RyaW5nKSB7XG4gIGNvbnN0IGhhbmRsZXIgPSBjcmVhdGVTZXJ2ZXJEYXRhSGFuZGxlcigpO1xuICBsZXQgc29ja2V0OiBUTFNTb2NrZXR8dW5kZWZpbmVkO1xuICB0cnkge1xuICAgIHNvY2tldCA9IGF3YWl0IG5ldyBQcm9taXNlPFJldHVyblR5cGU8dHlwZW9mIHRzbENvbm5lY3Q+PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBzb2NrZXQgPSB0c2xDb25uZWN0KHtcbiAgICAgICAgaG9zdDogYWRkcmVzcywgcG9ydDogOTkzLFxuICAgICAgICBlbmFibGVUcmFjZTogdHJ1ZVxuICAgICAgfSBhcyBDb25uZWN0aW9uT3B0aW9ucyk7XG5cbiAgICAgIHNvY2tldC5vbignc2VjdXJlQ29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5sb2coJ2Nvbm5lY3RlZCcsIHNvY2tldC5hdXRob3JpemVkID8gJ2F1dGhvcml6ZWQnIDogJ3VuYXV0aG9yaXplZCcpO1xuICAgICAgICByZXNvbHZlKHNvY2tldCk7XG4gICAgICB9KVxuICAgICAgLm9uKCdlcnJvcicsIGVyciA9PiByZWplY3QoZXJyKSlcbiAgICAgIC5vbigndGltZW91dCcsICgpID0+IHJlamVjdChuZXcgRXJyb3IoJ1RpbWVvdXQnKSkpO1xuICAgICAgc29ja2V0Lm9uKCdkYXRhJywgKGRhdGE6IEJ1ZmZlcikgPT4gaGFuZGxlci5pbnB1dChkYXRhKSk7XG4gICAgfSk7XG5cbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBpZiAoc29ja2V0KVxuICAgICAgc29ja2V0LmVuZCgpO1xuICAgIHRocm93IGV4O1xuICB9XG4gIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDAwKSk7XG4gIGhhbmRsZXIuaW5wdXQobnVsbCk7XG4gIHNvY2tldC5lbmQoKTtcbn1cbiJdfQ==