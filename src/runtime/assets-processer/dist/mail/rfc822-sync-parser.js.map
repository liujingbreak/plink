{"version":3,"file":"rfc822-sync-parser.js","sourceRoot":"","sources":["rfc822-sync-parser.ts"],"names":[],"mappings":"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","sourcesContent":["\nimport { Lexer, Grammar, parser, Chunk } from '@wfh/plink/wfh/dist/LLn-parser';\nimport fs from 'fs-extra';\nimport Path from 'path';\nconst log = require('log4js').getLogger('@wfh/assets-processer.rfc822-sync-parser');\n\nexport enum RCF822TokenType {\n  CRLF,\n  ':',\n  ';',\n  quoteStr,\n  ATOM,\n  BOUNDARY,\n  PART_BODY,\n  DOUBLE_DASH\n}\n\ninterface PartBodyToken extends Chunk<number, RCF822TokenType> {\n  data: Buffer;\n}\n\ninterface Token extends Chunk<number, RCF822TokenType> {\n  text?: string;\n}\n\nconst CR = '\\r'.charCodeAt(0);\nconst LF = '\\n'.charCodeAt(0);\nconst BACK_SLASH = '\\\\'.charCodeAt(0);\nconst QUOTE_MARK1 = '\"'.charCodeAt(0);\nconst QUOTE_MARK2 = '\\''.charCodeAt(0);\nconst COLON_MARK = ':'.charCodeAt(0);\nconst SEMI_COL = ';'.charCodeAt(0);\nconst WS = ' '.charCodeAt(0);\nconst TAB = '\\t'.charCodeAt(0);\nconst DASH = '-'.charCodeAt(0);\n// const DASH = '-'.charCodeAt(0);\n\nconst TEMP_DIR = 'dist/assets-processer/rfc822';\nexport interface RCF822ParseResult {\n  headers: RCF822HeaderType[];\n  textBody?: string;\n  parts: {\n    headers: RCF822HeaderType[];\n    body?: Buffer;\n    file?: string;\n  }[];\n}\n\nexport interface RCF822HeaderType {\n  key: string;\n  value: string[];\n}\n\nclass RfcParserContext {\n  private boundary: number[] | undefined;\n  private multipartStarted = false;\n  private textBodyStarted = false;\n\n  constructor(private origBuffer: Uint8Array) {\n  }\n\n  parse() {\n    const ps = parser<number, RCF822TokenType, Token, RCF822ParseResult>(\n      'rfc822-messagee', (la, emitter) => this.parseLexer(la, emitter),\n      (la) => this.parseGrammar(la),\n      chunk => {\n        (chunk as Token).text = chunk.values ?\n          Buffer.from(Uint8Array.from(chunk.values)).toString() :\n          '';\n        return (chunk as Token);\n      });\n    ps.write(this.origBuffer);\n    ps.end();\n    try {\n      return ps.getResult();\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      log.error('Failed to parse:\\n' + Buffer.from(this.origBuffer).toString('utf8'));\n      throw err;\n    }\n  }\n\n  private parseLexer: Lexer<number, RCF822TokenType> = (la, emitter) => {\n    let chrCode = la.la();\n    if (chrCode == null) {\n      emitter.end();\n      return;\n    }\n    const chr = String.fromCharCode(chrCode);\n    if (this.multipartStarted && la.isNext(CR, LF, CR, LF)) {\n      // part header must be over\n      la.startChunk(RCF822TokenType.CRLF);\n      la.advance(2);\n      emitter.emit();\n\n      la.startChunk(RCF822TokenType.CRLF);\n      la.advance(2);\n      emitter.emit();\n      this.parsePartBodyToken(la, emitter);\n\n    } else if (this.multipartStarted && la.isNext(DASH, DASH)) {\n      la.startChunk(RCF822TokenType.DOUBLE_DASH);\n      la.advance(2); // end of whole message\n      emitter.emit();\n      return;\n    } else if (this.boundary && la.isNext(...this.boundary)) {\n      la.startChunk(RCF822TokenType.BOUNDARY);\n      la.advance(this.boundary.length);\n      emitter.emit();\n      this.multipartStarted = true;\n      // console.log('multipartStarted true');\n    } else if (this.textBodyStarted) {\n      while (la.la() != null && la.la() === CR || la.la() === LF) {\n        la.advance();\n      }\n      la.startChunk(RCF822TokenType.PART_BODY, false);\n      while (la.la() != null) {\n        la.advance();\n      }\n      emitter.emit();\n      return;\n    } else if (la.isNext(CR, LF)) {\n      la.startChunk(RCF822TokenType.CRLF);\n      la.advance(2);\n      emitter.emit();\n    } else if ((la.la()) === LF) {\n      la.startChunk(RCF822TokenType.CRLF);\n      la.advance();\n      emitter.emit();\n    } else if (chr === ':' || chr === ';') {\n      la.startChunk(RCF822TokenType[chr]);\n      la.advance();\n      emitter.emit();\n      skipWhiteSpace(la);\n    } else if (/\\s/.test(chr)) {\n      skipWhiteSpace(la);\n    } else if (chr === '\"' || chr === '\\'') {\n      quoteStr(la, emitter);\n    } else {\n      consumeAtom(la, emitter);\n    }\n    chrCode = la.la();\n  }\n\n  private parseGrammar: Grammar<Token, RCF822ParseResult> = (la) => {\n    let result: RCF822ParseResult = {\n      headers: this.parseHeaders(la),\n      parts: []\n    };\n\n    // console.log('boundary:', String.fromCharCode(...this.boundary!));\n\n    if (this.boundary == null) {\n      this.textBodyStarted = true;\n      const tk = la.la();\n      if (tk != null) {\n        la.advance();\n        result.textBody = Buffer.from(this.origBuffer.slice(tk!.pos, tk!.end)).toString('utf8');\n      }\n    } else {\n      let tk = la.la();\n      while (tk != null) {\n        // console.log('tk:', tk.text);\n        la.assertAdvanceWith([RCF822TokenType.BOUNDARY], compareTokenType);\n        if ((la.la())!.type === RCF822TokenType.DOUBLE_DASH) {\n          break;\n        }\n        const partHeaders = this.parseHeaders(la);\n        const partBody = la.advance() as PartBodyToken;\n        la.assertAdvanceWith([RCF822TokenType.CRLF], compareTokenType);\n\n        this.onParseEachPart(result, partHeaders, partBody);\n        // console.log('rfc token: ' + RCF822TokenType[(la.advance()).type]);\n        tk = la.la();\n      }\n    }\n    return result as RCF822ParseResult;\n  }\n\n  private onParseEachPart(result: RCF822ParseResult,\n    partHeaders: RCF822ParseResult['headers'],\n    partBody: PartBodyToken) {\n    const encodingHeader = partHeaders.find(header => header.key === 'Content-Transfer-Encoding');\n    const isBase64 = encodingHeader && encodingHeader.value[0] === 'base64';\n\n    if (isBase64) {\n      partBody.data = Buffer.from(partBody.data.toString(), 'base64');\n    }\n    const attachmentHeader = partHeaders.find(header => header.key === 'Content-Disposition');\n    let attachmentName: string | undefined;\n\n    if (attachmentHeader && attachmentHeader.value[0] === 'attachment') {\n      const m = /^([^=]*)=[\"]?([^\"]*)[\"]?$/.exec(attachmentHeader.value[1]);\n      if (m && m[1] === 'filename') {\n        attachmentName = Path.resolve(TEMP_DIR, m[2]);\n        fs.mkdirpSync(TEMP_DIR);\n        fs.writeFileSync(attachmentName, partBody.data);\n        log.info(attachmentName + ' is written');\n      }\n    }\n\n    result.parts.push({\n      headers: partHeaders,\n      body: attachmentName ? undefined : partBody.data,\n      file: attachmentName ? attachmentName : undefined\n    });\n  }\n\n  private setBoundary(str: string) {\n    const chrs: number[] = new Array(str.length);\n\n    for (let i = 0, l = str.length; i < l; i++) {\n      chrs[i] = str.charCodeAt(i);\n    }\n    this.boundary = chrs;\n  }\n\n  private parseHeaders(la: Parameters<RfcParserContext['parseGrammar']>[0]) {\n    const headers: {key: string, value: string[]}[] = [];\n    let nextTk = la.la();\n\n    while (nextTk != null) {\n      if (la.isNextWith([RCF822TokenType.ATOM, RCF822TokenType[':']], compareTokenType)) {\n        const key = nextTk.text!;\n\n        la.advance(2);\n        nextTk = la.la();\n\n        let value = [] as string[];\n        const header = {key, value};\n        headers.push(header);\n        let lastValueItem = '';\n        while (nextTk != null && nextTk.type !== RCF822TokenType.CRLF) {\n          if (nextTk.type === RCF822TokenType[';']) {\n            value.push(lastValueItem);\n            lastValueItem = '';\n            la.advance();\n            nextTk = la.la();\n            continue;\n          }\n          lastValueItem += (la.advance()).text;\n          nextTk = la.la();\n        }\n        value.push(lastValueItem);\n        if (key.toLowerCase() === 'content-type' && value[0] === 'multipart/mixed') {\n          let boundary: string | undefined;\n          for (const valueItem of value.slice(1)) {\n            const m = /^([^=]*)=[\"]?([^\"]*)[\"]?$/.exec(valueItem);\n            if (m && m[1] === 'boundary') {\n              boundary = m[2];\n              break;\n            }\n          }\n          if (boundary) {\n            this.setBoundary('--' + boundary);\n          }\n        }\n\n      } else if (la.isNextWith<RCF822TokenType>([RCF822TokenType.CRLF, RCF822TokenType.CRLF], compareTokenType)) {\n        la.advance(2);\n        let next = la.la();\n        while (next && next.type === RCF822TokenType.CRLF) {\n          la.advance();\n          next = la.la();\n        }\n        break;\n      } else if (la.isNextWith([RCF822TokenType.CRLF], compareTokenType)) {\n        la.advance();\n      } else {\n        la.throwError((la.advance()).text);\n        // la.advance();\n      }\n      nextTk = la.la();\n    }\n    return headers;\n  }\n\n  /**\n   * Generate tokens: PART_BODY CRLF BOUNDARY\n   * @param la \n   */\n  private parsePartBodyToken(la: Parameters<Lexer<number, RCF822TokenType>>[0],\n    emitter: Parameters<Lexer<number, RCF822TokenType>>[1]) {\n    const tk = la.startChunk(RCF822TokenType.PART_BODY);\n    tk.trackValue = false;\n    const origBufferOffset = la.position;\n\n    while ((la.la()) != null) {\n\n      if (la.isNext(CR, LF, ...this.boundary!)) {\n        (tk as unknown as PartBodyToken).data = Buffer.from(this.origBuffer.slice(origBufferOffset, la.position));\n\n        emitter.emit();\n\n        la.startChunk(RCF822TokenType.CRLF);\n        la.advance(2);\n        emitter.emit();\n\n        la.startChunk(RCF822TokenType.BOUNDARY);\n        la.advance(this.boundary!.length);\n        emitter.emit();\n        break;\n      }\n      la.advance();\n    }\n  }\n\n}\n\nfunction quoteStr(la: Parameters<Lexer<number, RCF822TokenType>>[0],\n  emitter: Parameters<Lexer<number, RCF822TokenType>>[1]) {\n  la.startChunk(RCF822TokenType.quoteStr);\n  const openChar = la.advance();\n  while (true) {\n    const next = la.la();\n    if (next == null) {\n      return la.throwError();\n    }\n    if (next === BACK_SLASH) {\n      la.advance(2);\n    } else if (next === openChar) {\n      la.advance();\n      emitter.emit();\n      break;\n    } else {\n      la.advance();\n    }\n  }\n}\n\nfunction skipWhiteSpace(la: Parameters<Lexer<number, RCF822TokenType>>[0]) {\n  do {\n    const code = la.la();\n    if (code == null) return;\n    if (/\\s/.test(String.fromCharCode(code))) {\n      la.advance();\n    } else {\n      break;\n    }\n  } while (true);\n}\n\nfunction consumeAtom(la: Parameters<Lexer<number, RCF822TokenType>>[0],\n  emitter: Parameters<Lexer<number, RCF822TokenType>>[1]) {\n  la.startChunk(RCF822TokenType.ATOM);\n  la.advance();\n  let code = la.la();\n  let emit = false;\n  while (code != null) {\n    switch (code) {\n      case COLON_MARK:\n      case SEMI_COL:\n      case QUOTE_MARK1:\n      case QUOTE_MARK2:\n        emit = true;\n        emitter.emit();\n        break;\n      case CR:\n        // console.log((la.la()), (la.la(2)), (la.la(3)));\n        if (!(la.isNext(CR, LF, WS)) && !(la.isNext(CR, WS)) &&\n          !(la.isNext(CR, LF, TAB)) && !(la.isNext(CR, TAB))) {\n          // console.log('emit: ', (la.la()), (la.la(2)), (la.la(3)));\n          emit = true;\n          emitter.emit();\n          break;\n        } else {\n          la.advance(3);\n          code = la.la();\n          break;\n        }\n      case LF:\n        if (! la.isNext(LF, WS) && ! la.isNext(LF, TAB)) {\n          emit = true;\n          emitter.emit();\n          break;\n        } else {\n          la.advance(2);\n          code = la.la();\n          break;\n        }\n      default:\n        la.advance();\n        code = la.la();\n    }\n    if (emit) break;\n  }\n}\n\n// function parseMultipart(la: Parameters<typeof parseGrammar>[0]) {\n//   while (la.isNext(DASH, DASH))\n// }\nfunction compareTokenType<T>(tk: Chunk<number, T>, type: T) {\n   return tk.type === type;\n}\n\n\nexport function parse(readable: Buffer): RCF822ParseResult {\n  const pctx = new RfcParserContext(readable);\n  return pctx.parse();\n}\n"]}