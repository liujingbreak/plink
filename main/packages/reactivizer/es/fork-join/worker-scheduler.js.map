{"version":3,"file":"worker-scheduler.js","sourceRoot":"","sources":["../../src/fork-join/worker-scheduler.ts"],"names":[],"mappings":"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","sourcesContent":["import type {Worker as NodeWorker} from 'node:worker_threads';\nimport * as algorithms from '@wfh/algorithms';\nimport * as rx from 'rxjs';\nimport {ReactorComposite, ActionMeta} from '..';\nimport {Broker, BrokerInput, BrokerEvent, brokerOutputTableFor, ThreadExpirationEvents} from './types';\n\nexport function applyScheduler(broker: Broker<any, any>, opts: {\n  maxNumOfWorker: number;\n  /** Default `false`, in which case the current thread (main) will also be assigned for tasks */\n  excludeCurrentThead?: boolean;\n  /** Once forked thread has become idle for specific milliseconds,\n  * let worker thread (or web worker) \"exit\" (unsubscribed from parent port),\n  * value of `undefined` stands for \"never expired\"\n  */\n  threadMaxIdleTime?: number;\n  workerFactory(): Worker | NodeWorker;\n}) {\n  let WORKER_NO_SEQ = 0;\n\n  const {r, o, i, outputTable} = broker as unknown as ReactorComposite<\n  BrokerInput,\n  BrokerEvent & ThreadExpirationEvents,\n  [],\n  typeof brokerOutputTableFor>;\n\n  let algo: typeof algorithms;\n  try {\n    algo = require('@wfh/algorithms') as typeof algorithms;\n  } catch (e) {\n    // Inside Plink\n    algo = require('../../packages/algorithms') as typeof algorithms;\n  }\n  const {RedBlackTree} = algo;\n  const workerRankTree = new RedBlackTree<number, number[]>();\n  const ranksByWorkerNo = new Map<number, [worker: Worker | NodeWorker | 'main', rank: number]>();\n\n  const {maxNumOfWorker} = opts;\n\n  r('assignWorker -> workerAssigned', outputTable.l.assignWorker.pipe(\n    rx.map(([m]) => {\n      if (ranksByWorkerNo.size < maxNumOfWorker) {\n        const newWorker = (ranksByWorkerNo.size === 0 && opts.excludeCurrentThead !== true) ? 'main' : opts.workerFactory();\n        ranksByWorkerNo.set(WORKER_NO_SEQ, [newWorker, 0]);\n        const tnode = workerRankTree.insert(1);\n        if (tnode.value) {\n          tnode.value.push(WORKER_NO_SEQ);\n        } else {\n          tnode.value = [WORKER_NO_SEQ];\n        }\n        i.dpf.workerAssigned(m, WORKER_NO_SEQ, newWorker);\n        WORKER_NO_SEQ++;\n      } else {\n        const treeNode = workerRankTree.minimum()!;\n        if (treeNode == null)\n          throw new Error('minimum node is null');\n        const workerNo = treeNode.value[0];\n        if (ranksByWorkerNo.get(workerNo) == null)\n          throw new Error('ranksByWorkerNo has null for ' + workerNo);\n        const [worker] = ranksByWorkerNo.get(workerNo)!;\n        i.dpf.workerAssigned(m, treeNode.value[0], worker);\n      }\n    })\n  ));\n\n  r('workerAssigned -> changeWorkerRank()', i.pt.workerAssigned.pipe(\n    rx.map(([m, workerNo]) => {\n      changeWorkerRank(m, workerNo, 1);\n    })\n  ));\n\n  r('newWorkerReady, workerOutputCtl.pt.stopWaiting... -> changeWorkerRank()',\n    outputTable.l.newWorkerReady.pipe(\n      rx.mergeMap(([m, workerNo, workerOutputCtl]) => rx.merge(\n        workerOutputCtl.pt.stopWaiting.pipe(\n          rx.tap(() => changeWorkerRank(m, workerNo, 1)),\n          broker.labelError('stopWaiting -> ...')\n        ),\n        rx.merge(workerOutputCtl.pt.wait, workerOutputCtl.pt.returned).pipe(\n          rx.tap(() => changeWorkerRank(m, workerNo, -1)),\n          broker.labelError('returned -> ...')\n        )\n      ))\n    ));\n\n  r('onWorkerExit', o.pt.onWorkerExit.pipe(\n    rx.tap(([, workerNo]) => {\n      if (ranksByWorkerNo.has(workerNo)) {\n        const [, rank] = ranksByWorkerNo.get(workerNo)!;\n        ranksByWorkerNo.delete(workerNo);\n        const tnode = workerRankTree.search(rank);\n        if (tnode) {\n          const idx = tnode.value.indexOf(workerNo);\n          if (idx >= 0) {\n            tnode.value.splice(idx, 1);\n          }\n        }\n      }\n    })\n  ));\n\n  r('letAllWorkerExit', i.at.letAllWorkerExit.pipe(\n    rx.exhaustMap(a => {\n      const num = ranksByWorkerNo.size;\n      for (const [worker] of ranksByWorkerNo.values()) {\n        if (worker !== 'main')\n          i.dpf.letWorkerExit(a, worker);\n      }\n      return rx.concat(\n        o.at.onWorkerExit.pipe(\n          rx.take(ranksByWorkerNo.get(0)![0] === 'main' ? num - 1 : num)\n        ),\n        new rx.Observable((sub) => {\n          o.dpf.onAllWorkerExit(a);\n          sub.complete();\n        })\n      );\n    })\n  ));\n\n  r('', o.subForTypes(['startExpirationTimer', 'clearExpirationTimer'] as const).groupControllerBy(({p: [workerNo]}) => workerNo).pipe(\n    rx.mergeMap(([grouped]) => grouped.pt.startExpirationTimer.pipe(\n      rx.switchMap(([m, workerNo]) => rx.timer(opts.threadMaxIdleTime!).pipe(\n        rx.takeUntil(grouped.at.clearExpirationTimer),\n        rx.tap(() => {\n          const [worker] = ranksByWorkerNo.get(workerNo)!;\n          if (worker !== 'main') {\n            i.dpf.letWorkerExit(m, worker);\n          }\n        })\n      ))\n    ))\n  ));\n\n  function changeWorkerRank(actionMeta: ActionMeta, workerNo: number, changeValue: number) {\n    const entry = ranksByWorkerNo.get(workerNo)!;\n    const [, rank] = entry;\n    const newRank = rank + changeValue;\n    entry[1] = newRank;\n\n    const node = workerRankTree.search(rank);\n    if (node) {\n      const idx = node.value.indexOf(workerNo);\n      node.value.splice(idx, 1);\n      if (node.value.length === 0)\n        workerRankTree.deleteNode(node);\n      const tnode = workerRankTree.insert(newRank);\n      if (tnode.value)\n        tnode.value.push(workerNo);\n      else\n        tnode.value = [workerNo];\n    }\n    if (opts.threadMaxIdleTime != null) {\n      if (newRank === 0)\n        o.dpf.startExpirationTimer(actionMeta, workerNo);\n      else\n        o.dpf.clearExpirationTimer(actionMeta, workerNo);\n    }\n  }\n\n  return ranksByWorkerNo;\n}\n\n"]}