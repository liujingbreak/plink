{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/fork-join/types.ts"],"names":[],"mappings":"AAKA,MAAM,CAAC,MAAM,oBAAoB,GAAG,CAAC,gBAAgB,EAAE,cAAc,EAAE,cAAc,EAAE,cAAc,CAAU,CAAC;AA6BhH,MAAM,CAAC,MAAM,mBAAmB,GAAG,CAAC,kBAAkB,EAAE,MAAM,CAAU,CAAC;AACzE,MAAM,CAAC,MAAM,oBAAoB,GAAG,CAAC,cAAc,EAAE,KAAK,EAAE,MAAM,CAAU,CAAC","sourcesContent":["import type {Worker as NodeWorker, MessagePort as NodeMessagePort} from 'worker_threads';\nimport * as rx from 'rxjs';\nimport {ReactorComposite} from '../epic';\nimport {Action, ActionFunctions} from '../control';\n\nexport const brokerOutputTableFor = ['newWorkerReady', 'workerInputs', 'assignWorker', 'portOfWorker'] as const;\nexport type Broker<W extends WorkerControl<any, any, any, any> = WorkerControl> = ReactorComposite<BrokerInput, BrokerEvent<W>, [], typeof brokerOutputTableFor>;\n\nexport type ForkWorkerInput = {\n  exit(): void;\n  onFork(targetAction: Action<any>, port: NodeMessagePort | MessagePort): void;\n  /** set actions which are supposed to be sent to parent main thread by \"messagePort.postMessage()\",\n   * consumer program should subscribe to `broker`'s outputTable.l.newWorkerReady to obtain lifted RxController\n   * to dispatch or observe actions directly to or from worker threads\n   */\n  setLiftUpActions(action$: rx.Observable<Action<any>>): void;\n};\n\nexport type ForkWorkerOutput = {\n  workerInited(workerNo: string | number, logPrefix: string, mainWorkerPort: MessagePort | NodeMessagePort | null): void;\n  // inited(workerNo: number): void;\n  fork(targetAction: Action<any>): void;\n  /** Informs broker that current step is waiting on forked function returns*/\n  wait(): void;\n  /** Informs broker that current function step is be awake and continue on other instructions */\n  stopWaiting(): void;\n  returned(): void;\n  log(...obj: any[]): void;\n  warn(...obj: any[]): void;\n\n  /** broker implementation should react to this event*/\n  forkByBroker(targetAction: Action<any>, messagePort: NodeMessagePort | MessagePort): void;\n};\n\nexport const workerInputTableFor = ['setLiftUpActions', 'exit'] as const;\nexport const workerOutputTableFor = ['workerInited', 'log', 'warn'] as const;\n\nexport type WorkerControl<\n  I extends ActionFunctions = Record<string, never>,\n  O extends ActionFunctions = Record<string, never>,\n  LI extends ReadonlyArray<keyof I> = readonly [],\n  LO extends ReadonlyArray<keyof O> = readonly []\n> = ReactorComposite<ForkWorkerInput & I, ForkWorkerOutput & O,\nReadonlyArray<typeof workerInputTableFor[number] | LI[number]>,\nReadonlyArray<typeof workerOutputTableFor[number] | LO[number]>\n>;\n\nexport type BrokerInput = {\n  ensureInitWorker(workerNo: number, worker: Worker | NodeWorker): void;\n  /** Send message to worker to stop all event listerners on it */\n  letWorkerExit(worker: Worker | NodeWorker): void;\n  /** Since Web worker doesn't have \"close\" event, there is no way currently this ca\n   * work in web browser\n   */\n  letAllWorkerExit(): void;\n  workerAssigned(worketNo: number, worker: Worker | NodeWorker | 'main'): void;\n};\n\nexport type BrokerEvent<W extends WorkerControl<any, any, any, any> = WorkerControl> = {\n  workerInited(workerNo: number, newPort: MessagePort | NodeMessagePort | null, action$FromWorker: W['o'], skipped: boolean): void;\n  newWorkerReady(workerNo: number, action$FromWorker: W['o'], workerInput: W['i']): void;\n  workerInputs(byWorkerNo: Map<number, W['i']>): void;\n  onWorkerError(workerNo: number, error: unknown, type?: string): void;\n  onWorkerExit(workerNo: number, exitCode: number): void;\n  onAllWorkerExit(): void;\n  assignWorker(): void;\n  portOfWorker(map: Map<Worker | NodeWorker, MessagePort | NodeMessagePort>): void;\n};\n"]}