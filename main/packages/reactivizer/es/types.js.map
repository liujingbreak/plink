{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"","sourcesContent":["import type {Worker as NodeWorker, MessagePort as NodeMessagePort} from 'worker_threads';\nimport {ReactorComposite} from './epic';\nimport {Action, ActionFunctions} from './control';\n\nexport type Broker<WA extends ActionFunctions = Record<string, never>> = ReactorComposite<BrokerInput, BrokerEvent & WA>;\n\nexport type ForkWorkerInput = {\n  exit(): void;\n  onFork(targetAction: Action<any>, port: NodeMessagePort): void;\n};\n\nexport type ForkWorkerOutput = {\n  // inited(workerNo: number): void;\n  fork(targetAction: Action<any>): void;\n  /** Informs broker that current step is waiting on forked function returns*/\n  wait(): void;\n  /** Informs broker that current function step is be awake and continue on other instructions */\n  stopWaiting(): void;\n  log(...obj: any[]): void;\n  warn(...obj: any[]): void;\n\n  /** broker implementation should react to this event*/\n  forkByBroker(targetAction: Action<any>, messagePort: NodeMessagePort): void;\n};\n\nexport type BrokerInput = {\n  onWorkerWait(workerNo: number): void;\n  onWorkerAwake(workerNo: number): void;\n  ensureInitWorker(workerNo: number, worker: Worker | NodeWorker): void;\n  /** Send message to worker to stop all event listerners on it */\n  letWorkerExit(worker: Worker | NodeWorker): void;\n  // fork: ForkWorkerOutput['fork'];\n  forkFromWorker(workerNo: number, targetAction: Action<any>, messagePort: NodeMessagePort): void;\n  workerAssigned(worketNo: number, worker: Worker | NodeWorker | 'main'): void;\n};\n\nexport type BrokerEvent = {\n  workerInited(workerNo: number, newPort: MessagePort | NodeMessagePort | null, skipped: boolean): void;\n  onWorkerError(workerNo: number, error: unknown): void;\n  onWorkerExit(workerNo: number, exitCode: number): void;\n  assignWorker(): void;\n  actionFromWorker(action: Action<ForkWorkerOutput>, workerNo: number): void;\n};\n"]}