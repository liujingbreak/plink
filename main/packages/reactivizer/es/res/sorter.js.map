{"version":3,"file":"sorter.js","sourceRoot":"","sources":["../../src/res/sorter.ts"],"names":[],"mappings":"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","sourcesContent":["import * as rx from 'rxjs';\r\nimport binarySearch from 'lodash/sortedIndex';\r\nimport {createWorkerControl, reativizeRecursiveFuncs, ForkTransferablePayload} from '../forkJoin-node-worker';\r\nimport {actionRelatedToPayload, CoreOptions} from '../control';\r\nimport {timeoutLog} from '../utils';\r\nimport {ForkWorkerInput, ForkWorkerOutput} from '../types';\r\n\r\nexport function createSorter(opts?: CoreOptions<ForkWorkerInput & ForkWorkerOutput>) {\r\n  const ctl = createWorkerControl(opts);\r\n\r\n  const sortActions = {\r\n    /**\r\n     * @param noForkThreshold if `len` is larger than this number, `sort` function should fork half of array to recursive call, otherwise it just go with Array.sort() directly in current worker/thread\r\n     */\r\n    async sort(buf: SharedArrayBuffer, offset = 0, len: number, noForkThreshold = 50): Promise<[number, number]> {\r\n      const arr = new Float32Array(buf, offset << 2, len);\r\n      if (arr.length > noForkThreshold) {\r\n        const leftPartOffset = offset;\r\n        const leftPartLen = arr.length >> 1;\r\n\r\n        const rightPartOffset = offset + leftPartLen;\r\n        const rightpartLen = arr.length - leftPartLen;\r\n\r\n        const sortAction = sorter.i.createAction('sort', buf, rightPartOffset, rightpartLen, noForkThreshold);\r\n        // o.dp.log('create fork sort action for half', rightPartOffset, rightpartLen, `action id: ${sortAction.i}`);\r\n        const forkDone = rx.lastValueFrom(rx.merge(\r\n          sorter.i.pt.sortResolved.pipe(\r\n            actionRelatedToPayload(sortAction.i),\r\n            rx.map(([, res]) => res),\r\n            // Wait for sortCompleted recieved, so that Jest test won't report console log after test exits\r\n            rx.takeUntil(sorter.i.pt.sortCompleted.pipe(\r\n              actionRelatedToPayload(sortAction.i)\r\n            )),\r\n            timeoutLog(6000, () => o.dp.warn(\r\n              'fork sort timeout', rightPartOffset, rightpartLen, 'action id:', sortAction.i))\r\n          )\r\n        ));\r\n        o.dp.fork(sortAction);\r\n\r\n        // o.dp.log('sort another half in current worker', leftPartOffset, leftPartLen);\r\n        await sortActions.sort(buf, leftPartOffset, leftPartLen, noForkThreshold);\r\n        o.dp.wait();\r\n        await forkDone;\r\n        o.dp.stopWaiting();\r\n        const mergeRes = await sortActions.merge(buf, leftPartOffset, leftPartLen, rightPartOffset, rightpartLen, noForkThreshold);\r\n        const mergedBuf = mergeRes?.content;\r\n        if (mergedBuf != null) {\r\n          const mergedArr = new Float32Array(mergedBuf);\r\n          let i = 0;\r\n          for (const v of mergedArr) {\r\n            arr[i++] = v;\r\n          }\r\n        }\r\n        // o.dp.log('return merge-sort', offset, len, [...arr]);\r\n      } else {\r\n        arr.sort();\r\n        // o.dp.log('return directly sort', offset, len, [...arr]);\r\n      }\r\n      return [offset, len];\r\n    },\r\n\r\n    async merge(buf: SharedArrayBuffer, offset1 = 0, len1: number, offset2 = 0, len2: number, noForkThreshold = 50): Promise<null | ForkTransferablePayload<ArrayBuffer | null>> {\r\n      const destBuf = new ArrayBuffer((len1 + len2) << 2);\r\n      const destArr = new Float32Array(destBuf);\r\n      if (len1 < len2) {\r\n        // Ensure 1st array is longer than 2nd array, because we split 1st array into evenly half to be forked merge, 1st array's length determines how much\r\n        // the divide level is, not the 2nd array. In extreme case, the \"divide fork\" will be meaningless if the 1st array is empty.\r\n        const tempOffset = offset1;\r\n        offset1 = offset2;\r\n        offset2 = tempOffset;\r\n\r\n        const tempLen = len1;\r\n        len1 = len2;\r\n        len2 = tempLen;\r\n      }\r\n\r\n      if (len1 === 0) { // both empty, since len2 is always less than len1\r\n        return null;\r\n      }\r\n\r\n      if (len1 + len2 > noForkThreshold ) {\r\n        const arr1 = new Float32Array(buf, offset1 << 2, len1);\r\n        const arr1LeftOffset = offset1;\r\n        const arr1LeftLen = (len1 >> 1);\r\n        const arr1RightOffset = arr1LeftOffset + arr1LeftLen;\r\n        const arr1RightLen = len1 - arr1LeftLen;\r\n\r\n        const arr2 = new Float32Array(buf, offset2 << 2, len2);\r\n        const arr2LeftOffset = offset2;\r\n        const arr2LeftLen = binarySearch(arr2, arr1[arr1LeftLen - 1]);\r\n        const arr2RightOffset = arr2LeftOffset + arr2LeftLen;\r\n        const arr2RightLen = len2 - arr2LeftLen;\r\n\r\n        // console.log('merge with fork', offset1, len1, [...arr1], offset2, len2, [...arr2], ', binarySerach pivot value:', arr1[arr1LeftLen - 1], '\\n',\r\n        //   '1st: left', [...arr1.slice(0, arr1LeftLen)], 'right', [...arr1.slice(arr1LeftLen, arr1LeftLen + arr1RightLen)], '\\n',\r\n        //   '2nd: left', [...arr2.slice(0, arr2LeftLen)], 'right', [...arr2.slice(arr2LeftLen, arr2LeftLen + arr2RightLen)]);\r\n\r\n        const mergeRightPartAction = sorter.i.createAction('merge', buf, arr1RightOffset, arr1RightLen, arr2RightOffset, arr2RightLen, noForkThreshold);\r\n        const forkDone = rx.lastValueFrom(rx.merge(\r\n          sorter.i.pt.mergeResolved.pipe(\r\n            actionRelatedToPayload(mergeRightPartAction.i),\r\n            rx.map(([, res]) => res),\r\n            // Wait for sortCompleted recieved, so that Jest test won't report console log after test exits\r\n            rx.takeUntil(sorter.i.pt.mergeCompleted.pipe(\r\n              actionRelatedToPayload(mergeRightPartAction.i)\r\n            )),\r\n            timeoutLog(3000, () => o.dp.warn('merge resolving timeout for:', `action id: ${mergeRightPartAction.i}`,\r\n              arr1RightOffset, arr1RightLen, arr2RightOffset, arr2RightLen))\r\n          )\r\n        ));\r\n        sorter.o.dp.fork(mergeRightPartAction);\r\n        const leftMerged = (await sortActions.merge(buf, arr1LeftOffset, arr1LeftLen, arr2LeftOffset, arr2LeftLen, noForkThreshold))?.content;\r\n        o.dp.wait();\r\n        const rightMerged = (await forkDone)?.content;\r\n        o.dp.stopWaiting();\r\n        const destArr = new Float32Array(destBuf);\r\n        let i = 0;\r\n        if (leftMerged) {\r\n          for (const v of new Float32Array(leftMerged)) {\r\n            destArr[i++] = v;\r\n          }\r\n        }\r\n        if (rightMerged) {\r\n          for (const v of new Float32Array(rightMerged)) {\r\n            destArr[i++] = v;\r\n          }\r\n        }\r\n      } else {\r\n        const arr1 = new Float32Array(buf, offset1 << 2, len1);\r\n        const arr2 = new Float32Array(buf, offset2 << 2, len2);\r\n        // o.dp.log('merge directly', offset1, len1, arr1, offset2, len2, arr2);\r\n        let pos1 = 0, pos2 = 0;\r\n        for (let i = 0, l = len1 + len2; i < l; i++) {\r\n          if (pos2 >= arr2.length || arr1[pos1] <= arr2[pos2]) {\r\n            destArr[i] = arr1[pos1++];\r\n          } else {\r\n            destArr[i] = arr2[pos2++];\r\n          }\r\n        }\r\n      }\r\n\r\n      // console.log('merge returns', offset1, len1, offset2, len2, destArr);\r\n      return {content: destBuf, transferList: [destBuf]};\r\n    }\r\n  };\r\n\r\n  const sorter = reativizeRecursiveFuncs(ctl, sortActions);\r\n  const {o} = sorter;\r\n  return sorter;\r\n}\r\n\r\n"]}