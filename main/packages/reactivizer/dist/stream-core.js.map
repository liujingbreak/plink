{"version":3,"file":"stream-core.js","sourceRoot":"","sources":["../src/stream-core.ts"],"names":[],"mappings":"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","sourcesContent":["import * as rx from 'rxjs';\n\nexport type ActionFunctions = Record<string, any>; // instead of A indexed access type, since a \"class type\" can not be assigned to \"Indexed access type with function type property\"\nexport type EmptyActionFunctions = Record<string, never>;\n\nexport type InferPayload<F> = F extends (...a: infer P) => any ? P : unknown[];\n\nexport type ActionMeta = {\n  /** id */\n  i: number;\n  /** reference to other actions */\n  r?: number | number[];\n};\n\nexport type ArrayOrTuple<T> = T[] | readonly T[] | readonly [T, ...T[]];\n\nexport type Action<I extends ActionFunctions, K extends keyof I = keyof I & string> = {\n  /** type */\n  t: string;\n  /** payload **/\n  p: InferPayload<I[K]>;\n} & ActionMeta;\n\nexport type InferMapParam<I extends ActionFunctions, K extends keyof I> = [ActionMeta, ...InferPayload<I[K]>];\n\nexport type PayloadStream<I extends ActionFunctions, K extends keyof I> = rx.Observable<InferMapParam<I, K>>;\n\nexport type Dispatch<F> = (...params: InferPayload<F>) => Action<any>['i'];\nexport type DispatchFor<F> = (origActionMeta: ActionMeta | ArrayOrTuple<ActionMeta>, ...params: InferPayload<F>) => Action<any>['i'];\n\nexport type CoreOptions<K extends string[]> = {\n  name?: string | boolean;\n  debug?: boolean;\n  debugExcludeTypes?: K;\n  logStyle?: 'full' | 'noParam';\n  log?: (msg: string, ...objs: any[]) => unknown;\n};\n\nlet SEQ = 1;\nlet ACTION_SEQ = Number((Math.random() + '').slice(2, 10)) + 1;\n\nexport const has = Object.prototype.hasOwnProperty;\n\nexport class ControllerCore<I extends ActionFunctions = {[k: string]: never}> {\n  actionUpstream = new rx.Subject<Action<I, keyof I>>();\n  interceptor$ = new rx.BehaviorSubject<(up: rx.Observable<Action<I, keyof I>>) => rx.Observable<Action<I, keyof I>>>(a => a);\n  typePrefix = '#' + SEQ++ + ' ';\n  logPrefix: string;\n  action$: rx.Observable<Action<I, keyof I>>;\n  debugExcludeSet: Set<string>;\n  protected dispatcher = {} as {[K in keyof I]: Dispatch<I[keyof I]>};\n  protected dispatcherFor = {} as {[K in keyof I]: DispatchFor<I[keyof I]>};\n\n  constructor(public opts?: CoreOptions<(string & keyof I)[]>) {\n    this.logPrefix = opts?.name ? `[${this.typePrefix}${opts.name}] ` : this.typePrefix;\n    this.debugExcludeSet = new Set(opts?.debugExcludeTypes ?? []);\n\n    const debuggableAction$ = opts?.debug\n      ? this.actionUpstream.pipe(\n        opts?.log ?\n          rx.tap(action => {\n            const type = nameOfAction(action);\n            if (!this.debugExcludeSet.has(type)) {\n              opts.log!(this.logPrefix + 'rx:action', type, actionMetaToStr(action), ...(opts.logStyle === 'noParam' ? [] : action.p));\n            }\n          }) :\n          (typeof window !== 'undefined') || (typeof Worker !== 'undefined') ?\n            rx.tap(action => {\n              const type = nameOfAction(action);\n              if (!this.debugExcludeSet.has(type)) {\n                // eslint-disable-next-line no-console\n                console.log(`%c ${this.logPrefix}rx:action`, 'color: white; background: #8c61ff;',\n                  type, actionMetaToStr(action), ...(opts.logStyle === 'noParam' ? [] : action.p));\n              }\n            }) :\n            rx.tap(action => {\n              const type = nameOfAction(action);\n              if (!this.debugExcludeSet.has(type)) {\n                // eslint-disable-next-line no-console\n                console.log( this.logPrefix + 'rx:action', type, actionMetaToStr(action), ...(opts.logStyle === 'noParam' ? [] : action.p));\n              }\n            }),\n        rx.share()\n      )\n      : this.actionUpstream;\n\n    this.action$ = this.interceptor$.pipe(\n      rx.switchMap(interceptor => interceptor ?\n        debuggableAction$.pipe(interceptor, rx.share()) :\n        debuggableAction$)\n    );\n  }\n\n  createAction<J extends ActionFunctions = I, K extends keyof J = keyof J>(type: K, params?: InferPayload<J[K]>) {\n    return {\n      t: this.typePrefix + (type as string),\n      i: ACTION_SEQ++,\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      p: params ?? []\n    } as Action<J, K>;\n  }\n\n  dispatchFactory<K extends keyof I>(type: K): Dispatch<I> {\n    if (has.call(this.dispatcher, type)) {\n      return this.dispatcher[type];\n    }\n    const dispatch = (...params: InferPayload<I[keyof I]>) => {\n      const action = this.createAction(type, params);\n      this.actionUpstream.next(action);\n      return action.i;\n    };\n    this.dispatcher[type] = dispatch;\n    return dispatch;\n  }\n\n  dispatchForFactory<K extends keyof I>(type: K): DispatchFor<I> {\n    if (has.call(this.dispatcherFor, type)) {\n      return this.dispatcherFor[type];\n    }\n    const dispatch = (metas: ActionMeta | ArrayOrTuple<ActionMeta>, ...params: InferPayload<I[keyof I]>) => {\n      const action = this.createAction(type, params);\n      action.r = Array.isArray(metas) ? metas.map(m => m.i) : (metas as ActionMeta).i;\n      this.actionUpstream.next(action);\n      return action.i;\n    };\n    this.dispatcherFor[type] = dispatch;\n    return dispatch;\n  }\n\n  updateInterceptor(\n    factory: (\n      previous: (up: rx.Observable<Action<I, keyof I>>) => rx.Observable<Action<I, keyof I>>\n    ) => (up: rx.Observable<Action<I, keyof I>>) => rx.Observable<Action<I, keyof I>>\n  ) {\n    const newInterceptor = factory(this.interceptor$.getValue());\n    this.interceptor$.next(newInterceptor);\n  }\n\n  // eslint-disable-next-line space-before-function-paren\n  ofType<T extends (keyof I)[]>(...types: T) {\n    return (up: rx.Observable<Action<any, any>>) => {\n      const matchTypes = types.map(type => this.typePrefix + (type as string));\n      return up.pipe(\n        rx.filter((a): a is Action<I, T[number]> => matchTypes.some(matchType => a.t === matchType))\n      );\n    };\n  }\n\n  // eslint-disable-next-line space-before-function-paren\n  notOfType<T extends (keyof I)[]>(...types: T) {\n    return (up: rx.Observable<Action<any, any>>) => {\n      const matchTypes = types.map(type => this.typePrefix + (type as string));\n      return up.pipe(\n        rx.filter((a): a is Action<I, Exclude<(keyof I), T[number]>> => matchTypes.every(matchType => a.t !== matchType))\n      );\n    };\n  }\n}\n\n/**\n * Get the \"action name\" from payload's \"type\" field,\n * `payload.type`` is actually consist of string like `${Prefix}/${actionName}`,\n * this function returns the `actionName` part\n * @return undefined if current action doesn't have a valid \"type\" field\n */\n// eslint-disable-next-line space-before-function-paren\nexport function nameOfAction<I extends ActionFunctions>(\n  action: Pick<Action<I, keyof I>, 't'>\n) {\n  const match = /(?:#\\d+\\s+)?(\\S+)$/.exec(action.t);\n  return (match ? match[1] : action.t) as keyof I & string;\n}\n\nexport function actionMetaToStr(action: ActionMeta) {\n  const {r, i} = action;\n  return `(i: ${i}${r != null ? `, r: ${Array.isArray(r) ? [...r.values()].toString() : r}` : ''})`;\n}\n"]}