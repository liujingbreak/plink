{"version":3,"file":"worker-scheduler.js","sourceRoot":"","sources":["../../src/fork-join/worker-scheduler.ts"],"names":[],"mappings":"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","sourcesContent":["import type {Worker as NodeWorker} from 'node:worker_threads';\nimport * as algorithms from '@wfh/algorithms';\nimport * as rx from 'rxjs';\nimport {ReactorComposite, ActionMeta} from '..';\nimport {Broker, BrokerInput, BrokerEvent, brokerOutputTableFor, ThreadExpirationEvents} from './types';\n\nexport function applyScheduler(broker: Broker<any, any>, opts: {\n  maxNumOfWorker: number;\n  /** Default `false`, in which case the current thread (main) will also be assigned for tasks */\n  excludeCurrentThead?: boolean;\n  /** Once forked thread has become idle for specific milliseconds,\n  * let worker thread (or web worker) \"exit\" (unsubscribed from parent port),\n  * value of `undefined` stands for \"never expired\"\n  */\n  threadMaxIdleTime?: number;\n  workerFactory(): Worker | NodeWorker;\n}) {\n  let WORKER_NO_SEQ = 0;\n\n  const {r, o, i, outputTable} = broker as unknown as ReactorComposite<\n  BrokerInput,\n  BrokerEvent & ThreadExpirationEvents,\n  [],\n  typeof brokerOutputTableFor>;\n\n  let algo: typeof algorithms;\n  try {\n    algo = require('@wfh/algorithms') as typeof algorithms;\n  } catch (e) {\n    // Inside Plink\n    algo = require('../../packages/algorithms') as typeof algorithms;\n  }\n  const {RedBlackTree} = algo;\n  const workerRankTree = new RedBlackTree<number, number[]>();\n  const ranksByWorkerNo = new Map<number, [worker: Worker | NodeWorker | 'main', rank: number, workerNo: number]>();\n  const tasksByWorkerNo = new Map<number, [worker: Worker | NodeWorker | 'main', numTasks: number, workerNo: number]>();\n\n  const {maxNumOfWorker} = opts;\n\n  r('assignWorker -> workerAssigned', outputTable.l.assignWorker.pipe(\n    rx.map(([m]) => {\n      try {\n        const minTreeNode = workerRankTree.minimum();\n        if (minTreeNode && (minTreeNode.key === 0 ||\n           ranksByWorkerNo.size >= maxNumOfWorker)) {\n          const workerNo = minTreeNode.value[0];\n          if (ranksByWorkerNo.get(workerNo) == null)\n            throw new Error('ranksByWorkerNo has null for ' + workerNo);\n          const [worker] = ranksByWorkerNo.get(workerNo)!;\n          i.dpf.workerAssigned(m, minTreeNode.value[0], worker);\n        } if (ranksByWorkerNo.size < maxNumOfWorker) {\n          const newWorker = (ranksByWorkerNo.size === 0 && opts.excludeCurrentThead !== true) ? 'main' : opts.workerFactory();\n          if (newWorker !== 'main' && WORKER_NO_SEQ === 0) {\n            WORKER_NO_SEQ = 1; // 0 is always for \"main\"\n          }\n          ranksByWorkerNo.set(WORKER_NO_SEQ, [newWorker, 0, WORKER_NO_SEQ]);\n          tasksByWorkerNo.set(WORKER_NO_SEQ, [newWorker, 0, WORKER_NO_SEQ]);\n          const tnode = workerRankTree.insert(1);\n          if (tnode.value) {\n            tnode.value.push(WORKER_NO_SEQ);\n          } else {\n            tnode.value = [WORKER_NO_SEQ];\n          }\n          i.dpf.workerAssigned(m, WORKER_NO_SEQ, newWorker);\n          WORKER_NO_SEQ++;\n        }\n      } catch (e) {\n        broker.dispatchErrorFor(e, m);\n      }\n    })\n  ));\n\n  r('workerAssigned -> changeWorkerRank()', i.pt.workerAssigned.pipe(\n    rx.map(([m, workerNo]) => {\n      changeWorkerRank(workerNo, 1);\n      const tasks = tasksByWorkerNo.get(workerNo)!;\n      tasks[1]++;\n      checkNumOfTasks(m, workerNo, tasks[1]);\n    })\n  ));\n\n  r('newWorkerReady, workerOutputCtl.pt.stopWaiting... -> changeWorkerRank()',\n    outputTable.l.newWorkerReady.pipe(\n      rx.mergeMap(([m, workerNo, workerOutputCtl]) => rx.merge(\n        workerOutputCtl.pt.stopWaiting.pipe(\n          rx.tap(() => changeWorkerRank(workerNo, 1)),\n          broker.labelError(`worker #${workerNo} stopWaiting -> ...`)\n        ),\n        workerOutputCtl.pt.wait.pipe(\n          rx.tap(() => changeWorkerRank(workerNo, -1)),\n          broker.labelError(`worker #${workerNo} wait`)\n        ),\n        workerOutputCtl.pt.returned.pipe(\n          rx.tap(() => {\n            changeWorkerRank(workerNo, -1);\n            const taskCount = tasksByWorkerNo.get(workerNo);\n            if (taskCount) {\n              taskCount[1]--;\n              checkNumOfTasks(m, workerNo, taskCount[1]);\n            } // In case of \"excludeCurrentThead\", `main` thread is not assigned, tasksByWorkerNo does not contain `workerNo` 0\n          }),\n          broker.labelError(`worker #${workerNo} returned`)\n        )\n      ))\n    ));\n\n  r('letWorkerExit', i.pt.letWorkerExit.pipe(\n    rx.tap(([, workerNo]) => {\n      if (ranksByWorkerNo.has(workerNo)) {\n        const [, rank] = ranksByWorkerNo.get(workerNo)!;\n        ranksByWorkerNo.delete(workerNo);\n        const tnode = workerRankTree.search(rank);\n        if (tnode) {\n          const idx = tnode.value.indexOf(workerNo);\n          if (idx >= 0) {\n            tnode.value.splice(idx, 1);\n            if (tnode.value.length === 0) {\n              workerRankTree.deleteNode(tnode);\n            }\n          }\n        }\n      }\n      if (tasksByWorkerNo.has(workerNo)) {\n        tasksByWorkerNo.delete(workerNo);\n      }\n    })\n  ));\n\n  r('letAllWorkerExit', i.at.letAllWorkerExit.pipe(\n    rx.exhaustMap(a => {\n      const num = ranksByWorkerNo.size;\n      for (const [worker, , workerNo] of ranksByWorkerNo.values()) {\n        if (worker !== 'main')\n          i.dpf.letWorkerExit(a, workerNo);\n      }\n      return rx.concat(\n        o.at.onWorkerExit.pipe(\n          rx.take(opts.excludeCurrentThead !== true ? num : num - 1)\n        ),\n        new rx.Observable((sub) => {\n          o.dpf.onAllWorkerExit(a);\n          sub.complete();\n        })\n      );\n    })\n  ));\n\n  r('startExpirationTimer -> letWorkerExit', o.subForTypes(['startExpirationTimer', 'clearExpirationTimer'] as const).groupControllerBy(({p: [workerNo]}) => workerNo).pipe(\n    rx.mergeMap(([grouped]) => grouped.pt.startExpirationTimer.pipe(\n      rx.switchMap(([m, workerNo]) => rx.timer(opts.threadMaxIdleTime!).pipe(\n        rx.takeUntil(grouped.at.clearExpirationTimer),\n        rx.tap(() => {\n          const [worker] = ranksByWorkerNo.get(workerNo)!;\n          if (worker !== 'main') {\n            i.dpf.letWorkerExit(m, workerNo);\n          }\n        })\n      ))\n    ))\n  ));\n\n  r('onWorkerExit', o.pt.onWorkerExit.pipe(\n    rx.tap(([m, workerNo]) => o.dpf.clearExpirationTimer(m, workerNo))\n  ));\n\n  function changeWorkerRank(workerNo: number, changeValue: number) {\n    const entry = ranksByWorkerNo.get(workerNo)!;\n    if (entry == null) // In case of \"excludeCurrentThead\", `main` thread is not assigned, tasksByWorkerNo does not contain `workerNo` 0\n      return;\n\n    const [, rank] = entry;\n    const newRank = rank + changeValue;\n    entry[1] = newRank;\n\n    const node = workerRankTree.search(rank);\n    if (node) {\n      const idx = node.value.indexOf(workerNo);\n      node.value.splice(idx, 1);\n      if (node.value.length === 0)\n        workerRankTree.deleteNode(node);\n      const tnode = workerRankTree.insert(newRank);\n      if (tnode.value)\n        tnode.value.push(workerNo);\n      else\n        tnode.value = [workerNo];\n    }\n  }\n\n  function checkNumOfTasks(actionMeta: ActionMeta, workerNo: number, numTasks: number) {\n    o.dp.workerRankChanged(workerNo, numTasks);\n    if (workerNo !== 0 && opts.threadMaxIdleTime != null) {\n      if (numTasks === 0)\n        o.dpf.startExpirationTimer(actionMeta, workerNo);\n      else if (numTasks > 0)\n        o.dpf.clearExpirationTimer(actionMeta, workerNo);\n      else {\n        throw new Error(`Current thread worker #${workerNo} is ranked to a negative work load value ${numTasks},` +\n          ' it could also caused by an unexpected error');\n      }\n    }\n  }\n  return {ranksByWorkerNo, tasksByWorkerNo};\n}\n"]}