{"version":3,"file":"control.js","sourceRoot":"","sources":["../src/control.ts"],"names":[],"mappings":"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","sourcesContent":["import * as rx from 'rxjs';\n\nexport type ActionFunctions = object; // use \"object\" instead of A indexed access type, since a \"class type\" can not be assigned to \"Indexed access type\"\n\ntype InferPayload<F extends (...a: any[]) => any> = Parameters<F>;\n\nexport type Action<I extends ActionFunctions, K extends keyof I = keyof I> = {\n  /** id */\n  i: number;\n  /** type */\n  t: string;\n  /** payload **/\n  p: InferPayload<I[K]>;\n};\n\ntype InferMapParam<I extends ActionFunctions, K extends keyof I> = [Action<I, K>['i'], ...InferPayload<I[K]>];\n\nexport type PayloadStream<I extends ActionFunctions, K extends keyof I> = rx.Observable<InferMapParam<I, K>>;\n\nexport type CoreOptions = {\n  debug?: string | boolean;\n  log?: (msg: string, ...objs: any[]) => unknown;\n};\n\nlet SEQ = 1;\nlet ACTION_SEQ = 1;\n\nconst has = Object.prototype.hasOwnProperty;\n\nexport class ControllerCore<I extends ActionFunctions = {[k: string]: never}> {\n  actionUpstream = new rx.Subject<Action<I, keyof I>>();\n  dispatcher = {} as {[K in keyof I]: (...params: InferPayload<I[K]>) => Action<I, K>['i']};\n  interceptor$ = new rx.BehaviorSubject<(up: rx.Observable<Action<I, keyof I>>) => rx.Observable<Action<I, keyof I>>>(a => a);\n  typePrefix = SEQ++ + '/';\n  debugName: string;\n  action$: rx.Observable<Action<I, keyof I>>;\n\n  constructor(public opts?: CoreOptions) {\n    this.debugName = typeof opts?.debug === 'string' ? `[${this.typePrefix}${opts.debug}] ` : this.typePrefix;\n\n    const debuggableAction$ = opts?.debug\n      ? this.actionUpstream.pipe(\n        opts?.log ?\n          rx.tap(action => opts.log!(this.debugName + 'rx:action', nameOfAction(action))) :\n          (typeof window !== 'undefined') || (typeof Worker !== 'undefined') ?\n            rx.tap(action => {\n            // eslint-disable-next-line no-console\n              console.log(`%c ${this.debugName}rx:action `, 'color: white; background: #8c61ff;',\n                nameOfAction(action),\n                action.p === undefined ? '' : action.p\n              );\n            })\n            :\n          // eslint-disable-next-line no-console\n            rx.tap(action => console.log(this.debugName + 'rx:action', nameOfAction(action),\n              action.p === undefined ? '' : action.p )),\n        rx.share()\n      )\n      : this.actionUpstream;\n\n    this.action$ = this.interceptor$.pipe(\n      rx.switchMap(interceptor => interceptor ?\n        debuggableAction$.pipe(interceptor, rx.share()) :\n        debuggableAction$)\n    );\n  }\n\n  createAction<K extends keyof I>(type: K, params: InferPayload<I[K]>) {\n    return {\n      t: this.typePrefix + (type as string),\n      i: ACTION_SEQ++,\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      p: params\n    } as Action<I, K>;\n  }\n\n  dispatcherFactory<K extends keyof I>(type: K) {\n    if (has.call(this.dispatcher, type)) {\n      return this.dispatcher[type];\n    }\n    const dispatch = (...params: InferPayload<I[keyof I]>) => {\n      const action = this.createAction(type, params);\n      this.actionUpstream.next(action);\n      return action.i;\n    };\n    this.dispatcher[type] = dispatch;\n    return dispatch;\n  }\n\n  replaceActionInterceptor(\n    factory: (\n      origin: (up: rx.Observable<Action<I, keyof I>>) => rx.Observable<Action<I, keyof I>>\n    ) => (up: rx.Observable<Action<I, keyof I>>) => rx.Observable<Action<I, keyof I>>\n  ) {\n    const newInterceptor = factory(this.interceptor$.getValue());\n    this.interceptor$.next(newInterceptor);\n  }\n\n  ofType<T extends keyof I>(...types: [T, ...T[]]) {\n    return (up: rx.Observable<Action<any, any>>) => {\n      const matchTypes = types.map(type => this.typePrefix + (type as string));\n      return up.pipe(\n        rx.filter((a): a is Action<I, T> => matchTypes.some(matchType => a.t === matchType))\n      );\n    };\n  }\n}\n\nexport class RxController<I extends ActionFunctions> {\n  core: ControllerCore<I>;\n  dispatcher: {[K in keyof I]: (...params: InferPayload<I[K]>) => Action<I, K>['i']};\n  dp: {[K in keyof I]: (...params: InferPayload<I[K]>) => Action<I, K>['i']};\n  payloadByType: {[K in keyof I]: PayloadStream<I, K>};\n  pt: {[K in keyof I]: PayloadStream<I, K>};\n  actionByType: {[K in keyof I]: rx.Observable<Action<I, K>>};\n  at: {[K in keyof I]: rx.Observable<Action<I, K>>};\n  replaceActionInterceptor: ControllerCore<I>['replaceActionInterceptor'];\n\n  constructor(private opts?: CoreOptions) {\n    const core = this.core = new ControllerCore(opts);\n\n    this.dispatcher = this.dp = new Proxy({} as {[K in keyof I]: (...params: InferPayload<I[K]>) => Action<I, K>['i']}, {\n      get(_target, key, _rec) {\n        return core.dispatcherFactory(key as keyof I);\n      }\n    });\n\n    const actionsByType = {} as {[K in keyof I]: rx.Observable<Action<I, K>>};\n    const actionByTypeProxy = new Proxy(\n      {} as typeof actionsByType,\n      {\n        get(_target, type, _rec) {\n          let a$ = actionsByType[type as keyof I];\n          if (a$ == null) {\n            const matchType = core.typePrefix + (type as string);\n            a$ = actionsByType[type as keyof I] = core.action$.pipe(\n              rx.filter(({t}) => t === matchType),\n              rx.share()\n            );\n          }\n          return a$;\n        }\n      });\n\n    const payloadsByType = {} as {[K in keyof I]: rx.Observable<[Action<I, K>['i'], ...Action<I, K>['p']]>};\n    const payloadByTypeProxy = new Proxy(\n      {} as typeof payloadsByType,\n      {\n        get(_target, key, _rec) {\n          const a$ = actionByTypeProxy[key as keyof I];\n          return a$.pipe(\n            rx.map(a => [a.i, ...a.p]),\n            rx.share()\n          );\n        }\n      });\n    this.actionByType = this.at = actionByTypeProxy;\n    this.payloadByType = this.pt = payloadByTypeProxy;\n    this.replaceActionInterceptor = core.replaceActionInterceptor;\n  }\n\n  /**\n   * Conceptually, it is a \"store store\" like Apache Kafka's \"table\"\n   * From perspecitve of implementation, a map ReplaySubject which provides similiar function as rx.withLatestFrom() does\n   */\n  createLatestPayloadsFor<T extends keyof I>(...types: [T, ...T[]]): {[K in T]: PayloadStream<I, K>} {\n    const replayedPayloads = {} as {[K in T]: rx.Observable<InferMapParam<I, T>>};\n    const payloadByTypeProxy = this.payloadByType;\n    for (const key of types) {\n      const r$ = new rx.ReplaySubject<InferMapParam<I, T>>(1);\n      replayedPayloads[key] = this.opts?.debug ?\n        r$.pipe(this.debugLogLatestActionOperator(key as string)) :\n        r$.asObservable();\n      payloadByTypeProxy[key].subscribe(r$);\n    }\n    return replayedPayloads;\n  }\n\n  protected  debugLogLatestActionOperator<P>(type: string) {\n    return this.opts?.log ?\n      rx.map<P, P>((payload, idx) => {\n        if (idx === 0) {\n          this.opts!.log!(this.core.debugName + 'rx:latest', type);\n        }\n        return payload;\n      }) :\n      (typeof window !== 'undefined') || (typeof Worker !== 'undefined') ?\n        rx.map<P, P>((payload, idx) => {\n          if (idx === 0) {\n            // eslint-disable-next-line no-console\n            console.log(`%c ${this.core.debugName}rx:latest `, 'color: #f0fe0fe0; background: #8c61dd;', type,\n              payload === undefined ? '' : payload\n            );\n          }\n          return payload;\n        }) :\n        rx.map<P, P>((payload, idx) => {\n          if (idx === 0) {\n            // eslint-disable-next-line no-console\n            console.log(this.core.debugName + 'rx:action', type, payload === undefined ? '' : payload);\n          }\n          return payload;\n        });\n  }\n}\n\n/**\n * Get the \"action name\" from payload's \"type\" field,\n * `payload.type`` is actually consist of string like `${Prefix}/${actionName}`,\n * this function returns the `actionName` part\n * @return undefined if current action doesn't have a valid \"type\" field\n */\n// eslint-disable-next-line space-before-function-paren\nexport function nameOfAction<I extends ActionFunctions>(\n  action: Action<I, keyof I>\n): keyof I | undefined {\n  return action.t.split('/')[1] as keyof I;\n}\n\n"]}