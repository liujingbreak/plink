{"version":3,"file":"epic.js","sourceRoot":"","sources":["../src/epic.ts"],"names":[],"mappings":"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","sourcesContent":["// import inspector from 'node:inspector';\nimport * as rx from 'rxjs';\nimport {RxController, ActionFunctions} from './control';\nimport {DuplexController, DuplexOptions} from './duplex';\n// inspector.open(9222, 'localhost', true);\n\nexport type Reactor<I extends ActionFunctions> = (ctl: RxController<I>) => rx.Observable<any>;\nexport type DuplexReactor<I extends ActionFunctions, O extends ActionFunctions> = (ctl: DuplexController<I, O>) => rx.Observable<any>;\n\nexport type InferFuncReturnEvents<I extends ActionFunctions> = {\n  [K in keyof I as `${K & string}Resolved`]: (\n    p: ReturnType<I[K]> extends PromiseLike<infer P> ?\n      P : ReturnType<I[K]> extends rx.Observable<infer OB> ?\n        OB : ReturnType<I[K]>) => void\n} & {\n  [K in keyof I as `${K & string}Completed`]: () => void;\n};\n\nexport class ReactorComposite<\n  I extends ActionFunctions = Record<string, never>,\n  O extends ActionFunctions = Record<string, never>\n> extends DuplexController<I, O> {\n  error$: rx.Subject<[lable: string, originError: any]> = new rx.ReplaySubject();\n  destory$: rx.Subject<void> = new rx.ReplaySubject(1);\n  // protected static logSubj: rx.Subject<[level: string, ...msg: any[]]>;\n  protected reactorSubj: rx.Subject<[label: string, stream: rx.Observable<any>, disableCatchError?: boolean]>;\n\n  constructor(private opts?: DuplexOptions<I & O>) {\n    super(opts);\n    this.reactorSubj = new rx.ReplaySubject();\n    // this.logSubj = new rx.ReplaySubject(50);\n  }\n\n  startAll() {\n    return rx.merge(\n      this.reactorSubj.pipe(\n        rx.mergeMap(([label, downStream, noError]) => {\n          if (noError == null || !noError) {\n            downStream = this.handleError(downStream, label);\n          }\n          return downStream;\n        })\n      )\n    ).pipe(\n      rx.takeUntil(this.destory$),\n      rx.catchError((err, src) => {\n        if (this.opts?.log)\n          this.opts.log(err);\n        else\n          console.error(err);\n        return src;\n      })\n    ).subscribe();\n  }\n\n  destory() {\n    this.destory$.next();\n  }\n\n  // eslint-disable-next-line space-before-function-paren\n  reactivize<F extends {[s: string]: (...a: any[]) => any}>(fObject: F) {\n    const funcs = Object.entries(fObject);\n\n    for (const [key, func] of funcs) {\n      if (typeof func === 'function') {\n        this.reactivizeFunction(key, func, fObject);\n      }\n    }\n    return this as unknown as ReactorComposite<I & F, InferFuncReturnEvents<F> & O>;\n  }\n\n  /** \n   * It is just a declaration of mergeMap() operator, which merge an observable to the main stream\n   * which will be or has already been observed by `startAll()`.\n   * This is where we can add `side effect`s\n  * */\n  addReaction(...params: [label: string, stream: rx.Observable<any>, disableCatchError?: boolean]) {\n    this.r(...params);\n  }\n\n  /** Abbrevation of addReaction */\n  r = (...params: [label: string, stream: rx.Observable<any>, disableCatchError?: boolean] | [stream: rx.Observable<any>, disableCatchError?: boolean]) => {\n    if (typeof params[0] === 'string')\n      this.reactorSubj.next(params as [label: string, stream: rx.Observable<any>, disableCatchError?: boolean]);\n    else\n      this.reactorSubj.next(['', ...params as [stream: rx.Observable<any>, disableCatchError?: boolean]]);\n  };\n\n  protected reactivizeFunction(key: string, func: (...a: any[]) => any, funcThisRef?: any) {\n    const resolveFuncKey = key + 'Resolved';\n    const finishFuncKey = key + 'Completed';\n    const dispatchResolved = (this as unknown as ReactorComposite<Record<string, never>, Record<string, never>>).o.core.dispatchForFactory(resolveFuncKey as any);\n    const dispatchCompleted = (this as unknown as ReactorComposite<Record<string, never>, Record<string, never>>).o.core.dispatchForFactory(finishFuncKey as any);\n\n    this.r(this.i.pt[key as keyof I].pipe(\n      rx.mergeMap(([meta, ...params]) => {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const res = func.apply(funcThisRef, params);\n        if (rx.isObservable(res)) {\n          return res.pipe(\n            rx.map(res => dispatchResolved(meta, res)),\n            rx.finalize(() => dispatchCompleted(meta))\n          );\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        } else if (res?.then != null && res?.catch != null) {\n          return rx.defer(() => (res as PromiseLike<unknown>)).pipe(\n            rx.map(res => dispatchResolved(meta, res)),\n            rx.finalize(() => dispatchCompleted(meta))\n          );\n        } else {\n          dispatchResolved(meta, res);\n          dispatchCompleted(meta);\n          return rx.EMPTY;\n        }\n      })\n    ));\n\n    return resolveFuncKey;\n  }\n\n  protected handleError(upStream: rx.Observable<any>, label?: string) {\n    return upStream.pipe(\n      rx.catchError((err, src) => {\n        (this as unknown as ReactorComposite<Record<string, never>, Record<string, never>>).error$.next([err, label]);\n        if (this.opts?.log)\n          this.opts.log(err);\n        else\n          console.error(label ?? '', err);\n        return src;\n      })\n    );\n  }\n}\n"]}