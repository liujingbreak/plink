{"version":3,"file":"helper.js","sourceRoot":"","sources":["../helper.ts"],"names":[],"mappings":"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","sourcesContent":["import {CreateSliceOptions, SliceCaseReducers, Slice, PayloadAction, CaseReducerActions, PayloadActionCreator, Action, Draft,\n  ActionCreatorWithPayload} from '@reduxjs/toolkit';\nimport {Epic} from 'redux-observable';\nimport {Observable, EMPTY, of, Subject, OperatorFunction} from 'rxjs';\nimport * as op from 'rxjs/operators';\nimport {immerable, Immutable} from 'immer';\nimport {StateFactory, ExtraSliceReducers, ofPayloadAction} from './redux-toolkit-observable';\n\nexport type EpicFactory<S, R extends SliceCaseReducers<S>, Name extends string = string> =\n  (slice: SliceHelper<S, R, Name>) => Epic<PayloadAction<any>, any, {[sliceName in Name]: S}> | void;\n\n/**\n * A separate Redux slice which has its own life cycle, works for component internal state management.\n * Compare to React's useReducer() hook, sliceHelper offers more strong functionality for complicated component,\n * it uses redux-observable to resolve async action needs.\n */\nexport type SliceHelper<S, R extends SliceCaseReducers<S>, Name extends string = string> = Slice<S, R, Name> & {\n  /** You don't have to create en Epic for subscribing action stream, you subscribe this property\n   * to react on 'done' reducer action, and you may call actionDispatcher to emit a new action\n   */\n  action$: Observable<PayloadAction | Action>;\n  action$ByType: ActionByType<CaseReducerActions<R & ExtraSliceReducers<S>, Name>>;\n  actionDispatcher: CaseReducerActions<R & ExtraSliceReducers<S>, Name>;\n  destroy$: Observable<any>;\n  addEpic(epicFactory: EpicFactory<S, R>): () => void;\n  addEpic$(epicFactory: Observable<EpicFactory<S, R> | null | undefined>): () => void;\n  destroy(): void;\n  getStore(): Observable<S>;\n  getState(): S;\n};\n\nexport function createSliceHelper<S extends Record<string, any>, R extends SliceCaseReducers<S>>(\n  stateFactory: StateFactory, opts: CreateSliceOptions<S, R>): SliceHelper<S, R> {\n\n  const slice = stateFactory.newSlice(opts);\n  const actionDispatcher = stateFactory.bindActionCreators(slice);\n  const destory$ = new Subject();\n  const action$ = new Subject<PayloadAction | Action>();\n\n  new Observable(() => {\n    // Release epic\n    return stateFactory.addEpic(_action$ => {\n      return _action$.pipe(\n        op.tap(action => action$.next(action)),\n        op.ignoreElements()\n      );\n    }, opts.name);\n  }).subscribe();\n\n  function addEpic$(epicFactory$: Observable<EpicFactory<S, R> | null | undefined>) {\n    const sub = epicFactory$.pipe(\n      op.distinctUntilChanged(),\n      op.switchMap(fac => {\n        if (fac) {\n          const epic = fac(helper);\n          if (epic) {\n            return new Observable(() => {\n              // Release epic\n              return stateFactory.addEpic(epic, opts.name);\n            });\n          }\n        }\n        return EMPTY;\n      }),\n      op.takeUntil(destory$)\n    ).subscribe();\n    // releaseEpic.push(() => sub.unsubscribe());\n    return () => sub.unsubscribe();\n  }\n\n  // let releaseEpic: Array<() => void> = [];\n  const helper = {\n    ...slice,\n    action$: action$.asObservable(),\n    action$ByType: castByActionType(slice.actions, action$),\n    actionDispatcher,\n    epic(epic: Epic) {\n      const fac: EpicFactory<S, R> = () => epic;\n      addEpic$(of(fac));\n    },\n    addEpic(epicFactory: EpicFactory<S, R>) {\n      return addEpic$(of(epicFactory));\n    },\n    addEpic$,\n    destroy$: destory$.asObservable(),\n    destroy() {\n      destory$.next();\n      destory$.complete();\n      stateFactory.removeSlice(slice);\n    },\n    getStore() {\n      return stateFactory.sliceStore(slice);\n    },\n    getState() {\n      return stateFactory.sliceState(slice);\n    }\n  };\n  return helper;\n}\n\ntype SimpleReducers<S> = {\n  [K: string]: (draft: S | Draft<S>, payload?: any) => S | void | Draft<S>;\n};\n\nexport type RegularReducers<S, R extends SimpleReducers<S>> = {\n  [K in keyof R]: R[K] extends (s: any) => any ? (s: Draft<S>) => S | void | Draft<S> :\n    R[K] extends (s: any, payload: infer P) => any ? (s: Draft<S>, action: PayloadAction<P>) => void | Draft<S> :\n      (s: Draft<S>, action: PayloadAction<unknown>) => void | Draft<S>;\n};\n\n/**\n * createReducers helps to simplify how we writing definition of SliceCaseReducers,\n * e.g. A regular SliceCaseReducers takes PayloadAction as parameter, like: \n * ```ts\n * const reducers = {\n *   reducerName(state: State, {payload}: PayloadAction<number>) {\n *      // update state with payload data\n *    }\n * };\n * ```\n * Normally reducer's logic only care about `payload` instead of `PayloadAction`,\n * createReducers accepts a simpler format:\n * ```ts\n * const reducers = createReducers({\n *   reducerName(draft: State, payload: number) {\n *   }\n * });\n * ```\n * You can declare payload as reducer's parameter instead of a PayloadAction\n * @param simpleReducers\n * @returns SliceCaseReducers which can be part of parameter of createSliceHelper\n */\nexport function createReducers<S, R extends SimpleReducers<S>>(simpleReducers: R): RegularReducers<S, R> {\n  const rReducers = {} as {[key: string]: any};\n  for (const [key, sReducer] of Object.entries(simpleReducers)) {\n    rReducers[key] = (s: Draft<S>, {payload}: PayloadAction<any>) => {\n      return sReducer(s, payload);\n    };\n  }\n  return rReducers as RegularReducers<S, R>;\n}\n\ntype ActionByType<R> = {\n  [K in keyof R]:\n  Observable<\n  R[K] extends PayloadActionCreator<infer P> ?\n    PayloadAction<P> : PayloadAction<unknown>\n  >\n};\n\n/**\n * Map action stream to multiple action streams by their action type.\n * This is an alternative way to categorize action stream, compare to \"ofPayloadAction()\"\n * Usage:\n```\nslice.addEpic(slice => action$ => {\n  const actionsByType = castByActionType(slice.actions, action$);\n  return merge(\n    actionsByType.REDUCER_NAME_A.pipe(\n      ...\n    ),\n    actionsByType.REDUCER_NAME_B.pipe(\n      ...\n    ),\n  )\n})\n```\n * @param actionCreators \n * @param action$ \n */\nexport function castByActionType<Name extends string, R extends CaseReducerActions<SliceCaseReducers<any>, Name>>(actionCreators: R,\n  action$: Observable<PayloadAction | Action>): ActionByType<R> {\n  const source = action$.pipe(op.share());\n  const splitActions = {} as ActionByType<R>;\n\n  for (const reducerName of Object.keys(actionCreators)) {\n    Object.defineProperty(splitActions, reducerName, {\n      get() {\n        return source.pipe(\n          ofPayloadAction(actionCreators[reducerName]),\n          op.share()\n        );\n      }\n    });\n  }\n  return splitActions;\n}\n\nexport function action$ByType<S, R extends SliceCaseReducers<S>>(stateFactory: StateFactory, slice: Slice<S, R> | SliceHelper<S, R>) {\n  if ((slice as SliceHelper<S, R>).action$) {\n    return (slice as SliceHelper<S, R>).action$ByType;\n  } else {\n    const action$ = new Subject<PayloadAction | Action>();\n    stateFactory.addEpic(_action$ => {\n      return _action$.pipe(\n        op.tap(action => action$.next(action)),\n        op.ignoreElements()\n      );\n    }, slice.name);\n    return castByActionType(slice.actions, action$);\n  }\n}\n\nexport function isActionOfCreator<P, T extends string>(action: PayloadAction<any, any>, actionCreator: ActionCreatorWithPayload<P, T>):\n  action is PayloadAction<P, T> {\n  return action.type === actionCreator.type;\n}\n\n/**\n * Add an epicFactory to another component's sliceHelper\n * e.g.\n * ```\n * action$.pipe(ofPayloadAction(slice.actionDispatcher._onChildSliceRef),\n *  childSliceOp((childSlice) => {\n *    return childAction$ => {\n *      return childAction$.pipe(...);\n *    };\n *  })\n * ```\n * @param epicFactory \n */\nexport function sliceRefActionOp<S, R extends SliceCaseReducers<S>>(epicFactory: EpicFactory<S, R>):\nOperatorFunction<PayloadAction<SliceHelper<S, R>>, PayloadAction<any>> {\n  return function(in$: Observable<PayloadAction<SliceHelper<S, R>>>) {\n    return in$.pipe(\n      op.switchMap(({payload}) => {\n        const release = payload.addEpic(epicFactory);\n        return new Observable<PayloadAction<never>>(sub => release);\n      })\n    );\n  };\n}\n\ntype ActionOfReducer<S, R extends SliceCaseReducers<S>, T extends keyof R> = R[T] extends (s: any, action: infer A) => any ?\n  (A extends {payload: infer P} ? {payload: P; type: T} : {type: T}) : never;\n\nexport function action$Of<P, T extends string>(\n  stateFactory: StateFactory,\n  actionCreator: ActionCreatorWithPayload<P, T>) {\n\n  return new Observable<P extends undefined ? {type: T} : PayloadAction<P, T>>(sub => {\n    stateFactory.addEpic<unknown>((action$) => {\n      return action$.pipe(\n        ofPayloadAction(actionCreator),\n        op.map(action => sub.next(action as any)),\n        op.ignoreElements()\n      );\n    });\n  });\n}\n\nexport function action$OfSlice<S, R extends SliceCaseReducers<S>,\n  T extends keyof R>(\n  sliceHelper: SliceHelper<S, R>,\n  actionType: T) {\n\n  return new Observable<ActionOfReducer<S, R, T>>(sub => {\n    sliceHelper.addEpic(slice => (action$) => {\n      return action$.pipe(\n        ofPayloadAction(slice.actions[actionType]!),\n        op.map(action => sub.next(action as any)),\n        op.ignoreElements()\n      );\n    });\n  });\n}\n\n\n/**\n * ImmerJS does not work with some large object (like HTMLElement), meaning you can not directly defined a\n * Redux-toolkit state to contain such a large object, this class provides a wrapper to those\n * \"large object\", and avoid ImmerJs to recursively freeze it by pre-freeze itself. \n * \n * Use it with `Immutable` to inform Redux-toolkit and ImmerJS that this type should be ignored from `drafting`\n * Usage:\n * ```\n    import {Immutable} from 'immer';\n\n    interface YourState {\n      someDom: Immutable<Refrigerator<HTMLElement>>;\n    }\n * ```\n */\nexport class Refrigerator<T> {\n  private ref: Immutable<T>;\n  [immerable] = false;\n  static [immerable] = false;\n\n  constructor(originRef: T) {\n    this.ref = originRef as Immutable<T>;\n    Object.freeze(this);\n  }\n\n  creatNewIfNoEqual(ref: T) {\n    if (this.ref !== ref) {\n      return new Refrigerator(ref);\n    } else {\n      return this;\n    }\n  }\n  getRef(): T {\n    return this.ref as T;\n  }\n}\n"]}