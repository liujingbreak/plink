{"version":3,"file":"rx-utils.js","sourceRoot":"","sources":["../rx-utils.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH,OAAO,EAAa,OAAO,EAAoB,eAAe,EAAE,aAAa,EAAC,MAAM,MAAM,CAAC;AAC3F,OAAO,EAAC,SAAS,EAAE,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE,KAAK,EAAC,MAAM,gBAAgB,CAAC;AAyBlE,IAAI,GAAG,GAAG,CAAC,CAAC;AACZ;;;;;;;;;;;;;;;GAeG;AACH,uDAAuD;AACvD,MAAM,UAAU,kBAAkB,CAA2D,aAAiB,EAAE,KAAe;IAQ7H,MAAM,UAAU,GAAG,EAAQ,CAAC;IAC5B,MAAM,cAAc,GAAG,IAAI,OAAO,EAA6B,CAAC;IAChE,MAAM,UAAU,GAAG,GAAG,EAAE,GAAG,GAAG,CAAC;IAC/B,KAAK,MAAM,IAAI,IAAI,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,EAAE;QAC7C,MAAM,QAAQ,GAAG,CAAC,GAAG,MAAa,EAAE,EAAE;YACpC,MAAM,MAAM,GAAG;gBACb,IAAI,EAAE,UAAU,GAAG,IAAI;gBACvB,mEAAmE;gBACnE,OAAO,EAAE,MAAM,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,MAAM;aACvD,CAAC;YAC/B,cAAc,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC9B,CAAC,CAAC;QACF,UAAU,CAAC,IAAgB,CAAC,GAAG,QAAwB,CAAC;KACzD;IAED,MAAM,OAAO,GAAG,KAAK;QACnB,CAAC,CAAC,cAAc,CAAC,IAAI,CACnB,GAAG,CAAC,OAAO,MAAM,KAAK,WAAW;YAC/B,CAAC,CAAC,MAAM,CAAC,EAAE;gBACT,sCAAsC;gBACtC,OAAO,CAAC,GAAG,CAAC,eAAe,EAAE,oCAAoC,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC;YAClF,CAAC;YACD,sCAAsC;YACtC,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC,WAAW,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC,EACpD,KAAK,EAAE,CACR;QACD,CAAC,CAAC,cAAc,CAAC;IAEnB,OAAO;QACL,UAAU;QACV,OAAO;QACP,MAAM,EAAE,oBAAoB,CAAK,UAAU,CAAC;QAC5C,YAAY,EAAE,oBAAoB,CAAK,UAAU,CAAC;QAClD,YAAY,EAAE,CAAqB,MAA0B,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAM;KACjG,CAAC;AACJ,CAAC;AA0CD;;;;;;;;;;;;;;;;GAgBG;AACH,uDAAuD;AACvD,MAAM,UAAU,wBAAwB,CAA2D,MAG/F,EAAE;IACJ,MAAM,cAAc,GAAG,IAAI,OAAO,EAA6B,CAAC;IAChE,MAAM,UAAU,GAAG,EAAQ,CAAC;IAC5B,MAAM,UAAU,GAAG,GAAG,EAAE,GAAG,GAAG,CAAC;IAE/B,SAAS,eAAe,CAAC,IAAc;QACrC,IAAI,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,EAAE;YAC1D,OAAO,UAAU,CAAC,IAAI,CAAC,CAAC;SACzB;QACD,MAAM,QAAQ,GAAG,CAAC,GAAG,MAAgC,EAAE,EAAE;YACvD,MAAM,MAAM,GAAG,YAAY,CAAC,IAAI,EAAE,GAAG,MAAM,CAAC,CAAC;YAC7C,cAAc,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC9B,CAAC,CAAC;QACF,UAAU,CAAC,IAAI,CAAC,GAAG,QAAwB,CAAC;QAC5C,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED,SAAS,YAAY,CAAqB,IAAO,EAAE,GAAG,MAAyB;QAC7E,OAAO;YACL,IAAI,EAAE,UAAU,GAAI,IAAe;YACnC,mEAAmE;YACnE,OAAO,EAAE,MAAM,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,MAAM;SAC9D,CAAC;IAC1B,CAAC;IAED,MAAM,eAAe,GAAG,IAAI,KAAK,CAAK,EAAQ,EAAE;QAC9C,GAAG,CAAC,OAAO,EAAE,GAAG,EAAE,IAAI;YACpB,OAAO,eAAe,CAAC,GAAe,CAAC,CAAC;QAC1C,CAAC;KACF,CAAC,CAAC;IAEH,MAAM,aAAa,GAAG,EAAuD,CAAC;IAC9E,MAAM,cAAc,GAAG,EAAsD,CAAC;IAE9E,MAAM,MAAM,GAAG,oBAAoB,CAAK,UAAU,CAAC,CAAC;IAEpD,SAAS,YAAY,CAAqB,IAAO;QAC/C,IAAI,EAAE,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC;QAC7B,IAAI,EAAE,IAAI,IAAI,EAAE;YACd,EAAE,GAAG,aAAa,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC,IAAI,CACrC,MAAM,CAAC,IAAI,CAAC,CACb,CAAC;SACH;QACD,OAAO,EAAE,CAAC;IACZ,CAAC;IAED,MAAM,iBAAiB,GAAG,IAAI,KAAK,CACjC,EAAuD,EACvD;QACE,GAAG,CAAC,OAAO,EAAE,GAAG,EAAE,IAAI;YACpB,OAAO,YAAY,CAAC,GAAe,CAAC,CAAC;QACvC,CAAC;KACF,CAAC,CAAC;IAEL,MAAM,kBAAkB,GAAG,IAAI,KAAK,CAClC,EAAsD,EACtD;QACE,GAAG,CAAC,OAAO,EAAE,GAAG,EAAE,IAAI;YACpB,IAAI,EAAE,GAAG,cAAc,CAAC,GAAe,CAAC,CAAC;YACzC,IAAI,EAAE,IAAI,IAAI,EAAE;gBACd,MAAM,SAAS,GAAG,UAAU,GAAI,GAAc,CAAC;gBAC/C,EAAE,GAAG,cAAc,CAAC,GAAe,CAAC,GAAG,OAAO,CAAC,IAAI,CACjD,MAAM,CAAC,CAAC,EAAC,IAAI,EAAC,EAAE,EAAE,CAAC,IAAI,KAAK,SAAS,CAAC;gBACtC,+DAA+D;gBAC/D,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,OAAO,CAAC,EAC7B,KAAK,EAAE,CACR,CAAC;aACH;YACD,OAAO,EAAE,CAAC;QACZ,CAAC;KACF,CAAC,CAAC;IAEL,MAAM,SAAS,GAAG,OAAO,GAAG,CAAC,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,IAAI,UAAU,GAAG,GAAG,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC,UAAU,CAAC;IAC9F,MAAM,YAAY,GAAG,IAAI,eAAe,CAAgF,IAAI,CAAC,CAAC;IAE9H,SAAS,uBAAuB,CAC9B,OAE2E;QAE3E,MAAM,cAAc,GAAG,OAAO,CAAC,YAAY,CAAC,QAAQ,EAAE,CAAC,CAAC;QACxD,YAAY,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;IACpC,CAAC;IAED,MAAM,iBAAiB,GAAG,GAAG,CAAC,KAAK;QACjC,CAAC,CAAC,cAAc,CAAC,IAAI,CACnB,GAAG,CAAC,GAAG,CAAC,CAAC;YACP,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,GAAG,CAAC,GAAI,CAAC,SAAS,GAAG,WAAW,EAAE,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;YACxE,CAAC,OAAO,MAAM,KAAK,WAAW,CAAC,IAAI,CAAC,OAAO,MAAM,KAAK,WAAW,CAAC,CAAC,CAAC;gBAClE,GAAG,CAAC,MAAM,CAAC,EAAE;oBACX,sCAAsC;oBACtC,OAAO,CAAC,GAAG,CAAC,MAAM,SAAS,YAAY,EAAE,oCAAoC,EAC3E,YAAY,CAAC,MAAM,CAAC,EACpB,MAAM,CAAC,OAAO,KAAK,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,OAAO,CACnD,CAAC;gBACJ,CAAC,CAAC;gBACF,CAAC;oBACD,sCAAsC;oBACtC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC,SAAS,GAAG,WAAW,EAAE,YAAY,CAAC,MAAM,CAAC,EACrE,MAAM,CAAC,OAAO,KAAK,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,OAAO,CAAE,CAAC,EAC3D,KAAK,EAAE,CACR;QACD,CAAC,CAAC,cAAc,CAAC;IAEnB,MAAM,OAAO,GAAG,YAAY,CAAC,IAAI,CAC/B,SAAS,CAAC,WAAW,CAAC,EAAE,CAAC,WAAW,CAAC,CAAC;QACpC,iBAAiB,CAAC,IAAI,CAAC,WAAW,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC;QAC9C,iBAAiB,CAAC,CACrB,CAAC;IAEF,SAAS,4BAA4B,CAAI,IAAY;QACnD,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC;YACd,GAAG,CAAO,CAAC,OAAO,EAAE,GAAG,EAAE,EAAE;gBACzB,IAAI,GAAG,KAAK,CAAC,EAAE;oBACb,GAAG,CAAC,GAAI,CAAC,SAAS,GAAG,WAAW,EAAE,IAAI,CAAC,CAAC;iBACzC;gBACD,OAAO,OAAO,CAAC;YACjB,CAAC,CAAC,CAAC,CAAC;YACJ,CAAC,OAAO,MAAM,KAAK,WAAW,CAAC,IAAI,CAAC,OAAO,MAAM,KAAK,WAAW,CAAC,CAAC,CAAC;gBAClE,GAAG,CAAO,CAAC,OAAO,EAAE,GAAG,EAAE,EAAE;oBACzB,IAAI,GAAG,KAAK,CAAC,EAAE;wBACb,sCAAsC;wBACtC,OAAO,CAAC,GAAG,CAAC,MAAM,SAAS,YAAY,EAAE,wCAAwC,EAAE,IAAI,EACrF,OAAO,KAAK,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,OAAO,CACrC,CAAC;qBACH;oBACD,OAAO,OAAO,CAAC;gBACjB,CAAC,CAAC,CAAC,CAAC;gBACJ,GAAG,CAAO,CAAC,OAAO,EAAE,GAAG,EAAE,EAAE;oBACzB,IAAI,GAAG,KAAK,CAAC,EAAE;wBACb,sCAAsC;wBACtC,OAAO,CAAC,GAAG,CAAC,SAAS,GAAG,WAAW,EAAE,IAAI,EAAE,OAAO,KAAK,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;qBAClF;oBACD,OAAO,OAAO,CAAC;gBACjB,CAAC,CAAC,CAAC;IACT,CAAC;IAED,OAAO;QACL,UAAU,EAAE,eAAe;QAC3B,oBAAoB,CAAqB,GAAG,KAAU;YACpD,MAAM,gBAAgB,GAAG,EAA+C,CAAC;YACzE,KAAK,MAAM,GAAG,IAAI,KAAK,EAAE;gBACvB,MAAM,EAAE,GAAG,IAAI,aAAa,CAAoB,CAAC,CAAC,CAAC;gBACnD,gBAAgB,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC;oBACjC,EAAE,CAAC,YAAY,EAAE,CAAC,IAAI,CACpB,4BAA4B,CAAC,GAAa,CAAC,CAC5C,CAAC,CAAC;oBACH,EAAE,CAAC,YAAY,EAAE,CAAC;gBACpB,kBAAkB,CAAC,GAAG,CAAC,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;aACvC;YACD,OAAO,gBAAgB,CAAC;QAC1B,CAAC;QACD,eAAe,EAAE,eAAkD;QACnE,cAAc,EAAE,cAAc;QAC9B,OAAO;QACP,aAAa,EAAE,kBAAkB;QACjC,YAAY,EAAE,iBAAiB;QAC/B,YAAY;QACZ,uBAAuB;QACvB,MAAM;QACN,YAAY,EAAE,oBAAoB,CAAK,UAAU,CAAC;QAClD,YAAY,EAAE,CAAC,MAAiC,EAAE,EAAE,CAAC,YAAY,CAAK,MAAM,CAAC;QAC7E,YAAY;QACZ,iBAAiB,CAAC,GAAwB;YACxC,mEAAmE;YACnE,cAAc,CAAC,IAAI,CAAC,EAAC,IAAI,EAAE,UAAU,GAAG,GAAG,CAAC,CAAC,EAAE,OAAO,EAAE,GAAG,CAAC,CAAC,EAA8B,CAAC,CAAC;QAC/F,CAAC;QACD,cAAc,CAAC,GAAwB;YACrC,mEAAmE;YACnE,OAAO,EAAC,IAAI,EAAE,UAAU,GAAG,GAAG,CAAC,CAAC,EAAE,OAAO,EAAE,GAAG,CAAC,CAAC,EAA8B,CAAC;QACjF,CAAC;QACD,eAAe,CAAC,MAAiC;YAC/C,OAAO,EAAC,CAAC,EAAE,YAAY,CAAC,MAAM,CAAW,EAAE,CAAC,EAAE,MAAM,CAAC,OAAO,EAAC,CAAC;QAChE,CAAC;KACF,CAAC;AACJ,CAAC;AAED;;;;;GAKG;AACH,uDAAuD;AACvD,MAAM,UAAU,YAAY,CAC1B,MAAiC;IAEjC,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;AACnC,CAAC;AAaD,SAAS,oBAAoB,CAAK,MAAc;IAC9C,OAAO,SAAS,YAAY,CAAqB,MAAuB,EAAE,IAAO;QAC/E,OAAO,MAAM,CAAC,IAAI,KAAK,MAAM,GAAI,IAAe,CAAC;IACnD,CAAC,CAAC;AACJ,CAAC;AAED,2DAA2D;AAC3D,SAAS,oBAAoB,CAAK,UAAU,GAAG,EAAE;IAC/C,OAAO,CAAqB,GAAG,KAAU,EAAE,EAAE,CAC3C,CAAC,QAAyB,EAAE,EAAE;QAC5B,MAAM,UAAU,GAAG,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,UAAU,GAAI,IAAe,CAAC,CAAC;QACpE,sEAAsE;QACtE,OAAO,QAAQ,CAAC,IAAI;QAClB,sEAAsE;QACtE,MAAM,CAAC,CAAC,MAAM,EAAiC,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC,EAChG,KAAK,EAAE,CACR,CAAE;IACL,CAAC,CAAC;AACN,CAAC;AAED,yCAAyC;AACzC,8BAA8B;AAC9B,yCAAyC;AACzC,qBAAqB;AACrB,4DAA4D;AAC5D,KAAK;AAEL,wBAAwB;AACxB,+FAA+F;AAC/F,KAAK;AACL,qFAAqF;AACrF,oCAAoC","sourcesContent":["/**\n * redux-observable like async reactive actions, side effect utilities\n * https://redux-observable.js.org/\n */\n\nimport {Observable, Subject, OperatorFunction, BehaviorSubject, ReplaySubject} from 'rxjs';\nimport {switchMap, filter, map, tap, share} from 'rxjs/operators';\n\ntype Plen<T> = (T extends (...a: infer A) => any ? A : [])['length'];\n\nexport type ActionTypes<AC> = {\n  [K in keyof AC]: {\n    type: string;\n    payload: InferParam<AC[K]>;\n  };\n};\n\n\ntype InferParam<F> = Plen<F> extends 1 | 0 ?\n  (F extends (a: infer A) => any ? A : unknown)\n  :\n  Plen<F> extends 2 ? F extends (...p: infer P) => any ? P : unknown\n    :\n    Plen<F> extends 1 | 2 ?\n      F extends (a: infer A, b: infer B) => any ?\n        A | [A, B]\n        :\n        F extends (...p: infer P) => any ? P : unknown\n      :\n      F extends (...p: infer P) => any ? P : unknown;\n\nlet SEQ = 0;\n/**\n * @Deprecated\n * Use createActionStreamByType<R>() instead.\n * create Stream of action stream and action dispatcher,\n * similar to redux-observable Epic concept,\n * What you can get from this function are:\n *   1. An action observable (stream),\n *      so that you can subscribe to it and react with fantastic Reactive operators\n *      to handle complex async logic\n *\n *   2. An action dispatcher,\n *      so that you can emit new action along with paramters (payload) back to action observale stream.\n *\n *   3. An RxJs \"filter()\" operator to filter action by its type, it provides better Typescript\n *   type definition for downstream action compare bare \"filter()\"\n */\n// eslint-disable-next-line space-before-function-paren\nexport function createActionStream<AC extends Record<string, ((...payload: any[]) => void)>>(actionCreator: AC, debug?: boolean):\n{\n  dispatcher: AC;\n  action$: Observable<ActionTypes<AC>[keyof AC]>;\n  ofType: OfTypeFn<AC>;\n  isActionType: <K extends keyof AC>(action: {type: unknown}, type: K) => action is ActionTypes<AC>[K];\n  nameOfAction: <K extends keyof AC>(action: ActionTypes<AC>[K]) => K;\n} {\n  const dispatcher = {} as AC;\n  const actionUpstream = new Subject<ActionTypes<AC>[keyof AC]>();\n  const typePrefix = SEQ++ + '/';\n  for (const type of Object.keys(actionCreator)) {\n    const dispatch = (...params: any[]) => {\n      const action = {\n        type: typePrefix + type,\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        payload: params.length === 1 ? params[0] : params.length === 0 ? undefined : params\n      } as ActionTypes<AC>[keyof AC];\n      actionUpstream.next(action);\n    };\n    dispatcher[type as keyof AC] = dispatch as AC[keyof AC];\n  }\n\n  const action$ = debug\n    ? actionUpstream.pipe(\n      tap(typeof window !== 'undefined'\n        ? action => {\n          // eslint-disable-next-line no-console\n          console.log('%c rx:action ', 'color: white; background: #8c61ff;', action.type);\n        }\n        // eslint-disable-next-line no-console\n        : action => console.log('rx:action', action.type)),\n      share()\n    )\n    : actionUpstream;\n\n  return {\n    dispatcher,\n    action$,\n    ofType: createOfTypeOperator<AC>(typePrefix),\n    isActionType: createIsActionTypeFn<AC>(typePrefix),\n    nameOfAction: <K extends keyof AC>(action: ActionTypes<AC>[K]) => action.type.split('/')[1] as K\n  };\n}\n\ntype SimpleActionDispatchFactory<AC> = <K extends keyof AC>(type: K) => AC[K];\n\nexport type PayloadStreams<AC extends Record<string, (...a: any[]) => void>> = {\n  [K in keyof AC]: Observable<InferParam<AC[K]>>\n};\n\ninterface CreateReplayableFn<AC extends Record<string, (...a: any[]) => void>> {\n  <R1 extends keyof AC, R2 extends keyof AC>(actionType1: R1, at2: R2): PayloadStreams<Pick<AC, R1 | R2>>;\n  <R1 extends keyof AC, R2 extends keyof AC, R3 extends keyof AC>(actionType1: R1, at2: R2, at3: R3): PayloadStreams<Pick<AC, R1 | R2 | R3>>;\n  <R1 extends keyof AC, R2 extends keyof AC, R3 extends keyof AC, R4 extends keyof AC>(actionType1: R1, at2: R2, at3: R3, at4: R4): PayloadStreams<Pick<AC, R1 | R2 | R3 | R4>>;\n  <R1 extends keyof AC, R2 extends keyof AC, R3 extends keyof AC, R4 extends keyof AC, R5 extends keyof AC>(actionType1: R1, at2: R2, at3: R3, at4: R4, at5: R5): PayloadStreams<Pick<AC, R1 | R2 | R3 | R4 | R5>>;\n  <R extends keyof AC>(...actionTypes: R[]): PayloadStreams<Pick<AC, R>>;\n}\n\nexport type ActionStreamControl<AC extends Record<string, (...a: any[]) => void>> = {\n  /** create `ReplaySubject(1)` for each `payloadByType` */\n  createLatestPayloads: CreateReplayableFn<AC>;\n  dispatcher: AC;\n  dispatchStream: Subject<ActionTypes<AC>[keyof AC]>;\n  payloadByType: PayloadStreams<AC>;\n  actionByType: {[T in keyof AC]: Observable<ActionTypes<AC>[T]>};\n  /** @Deprecated use dispatcher.<actionName> instead */\n  dispatchFactory: SimpleActionDispatchFactory<AC>;\n  /** @Deprecated use `actionByType.<actionName>` instead */\n  actionOfType<T extends keyof AC>(type: T): Observable<ActionTypes<AC>[T]>;\n  changeActionInterceptor<T extends keyof AC>(\n    interceptorFactory: (\n      originalInterceptor: OperatorFunction<ActionTypes<AC>[T], ActionTypes<AC>[T]> | null\n    ) => OperatorFunction<ActionTypes<AC>[T], ActionTypes<AC>[T]>\n  ): void;\n  action$: Observable<ActionTypes<AC>[keyof AC]>;\n  createAction<K extends keyof AC>(type: K, ...params: Parameters<AC[K]>): ActionTypes<AC>[K];\n  ofType: OfTypeFn<AC>;\n  isActionType<K extends keyof AC>(action: {type: unknown}, type: K): action is ActionTypes<AC>[K];\n  nameOfAction(action: ActionTypes<AC>[keyof AC]): keyof AC | undefined;\n  objectToAction(obj: {t: string; p: any}): ActionTypes<AC>[keyof AC];\n  _actionFromObject(obj: {t: string; p: any}): void;\n  _actionToObject(action: ActionTypes<AC>[keyof AC]): {t: string; p: any};\n};\n\n/**\n * Unlike `createActionStream()`, this function only needs an \"Action creator\" type as generic type parameter,\n * instead of an actual empty \"Action creator\" object to be parameter\n *\n * create Stream of action stream and action dispatcher,\n * similar to redux-observable Epic concept,\n * What you can get from this function are:\n *   1. An action observable (stream),\n *      so that you can subscribe to it and react with fantastic Reactive operators\n *      to handle complex async logic\n *                                                                                                      \n *   2. An action dispatcher,\n *      so that you can emit new action along with paramters (payload) back to action observale stream.\n *                                                                                                      \n *   3. An RxJs \"filter()\" operator to filter action by its type, it provides better Typescript\n *   type definition for downstream action compare bare \"filter()\"\n */\n// eslint-disable-next-line space-before-function-paren\nexport function createActionStreamByType<AC extends Record<string, ((...payload: any[]) => void)>>(opt: {\n  debug?: string | boolean;\n  log?: (msg: string, ...objs: any[]) => unknown;\n} = {}): ActionStreamControl<AC> {\n  const actionUpstream = new Subject<ActionTypes<AC>[keyof AC]>();\n  const dispatcher = {} as AC;\n  const typePrefix = SEQ++ + '/';\n\n  function dispatchFactory(type: keyof AC) {\n    if (Object.prototype.hasOwnProperty.call(dispatcher, type)) {\n      return dispatcher[type];\n    }\n    const dispatch = (...params: Parameters<AC[keyof AC]>) => {\n      const action = createAction(type, ...params);\n      actionUpstream.next(action);\n    };\n    dispatcher[type] = dispatch as AC[keyof AC];\n    return dispatch;\n  }\n\n  function createAction<K extends keyof AC>(type: K, ...params: Parameters<AC[K]>) {\n    return {\n      type: typePrefix + (type as string),\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      payload: params.length === 1 ? params[0] : params.length === 0 ? undefined : params\n    } as ActionTypes<AC>[K];\n  }\n\n  const dispatcherProxy = new Proxy<AC>({} as AC, {\n    get(_target, key, _rec) {\n      return dispatchFactory(key as keyof AC);\n    }\n  });\n\n  const actionsByType = {} as {[K in keyof AC]: Observable<ActionTypes<AC>[K]>};\n  const payloadsByType = {} as {[K in keyof AC]: Observable<InferParam<AC[K]>>};\n\n  const ofType = createOfTypeOperator<AC>(typePrefix);\n\n  function actionOfType<T extends keyof AC>(type: T): Observable<ActionTypes<AC>[T]> {\n    let a$ = actionsByType[type];\n    if (a$ == null) {\n      a$ = actionsByType[type] = action$.pipe(\n        ofType(type)\n      );\n    }\n    return a$;\n  }\n\n  const actionByTypeProxy = new Proxy<{[T in keyof AC]: Observable<ActionTypes<AC>[T]>}>(\n    {} as {[T in keyof AC]: Observable<ActionTypes<AC>[T]>},\n    {\n      get(_target, key, _rec) {\n        return actionOfType(key as keyof AC);\n      }\n    });\n\n  const payloadByTypeProxy = new Proxy<{[T in keyof AC]: Observable<InferParam<AC[T]>>}>(\n    {} as {[T in keyof AC]: Observable<InferParam<AC[T]>>},\n    {\n      get(_target, key, _rec) {\n        let p$ = payloadsByType[key as keyof AC];\n        if (p$ == null) {\n          const matchType = typePrefix + (key as string);\n          p$ = payloadsByType[key as keyof AC] = action$.pipe(\n            filter(({type}) => type === matchType),\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            map(action => action.payload),\n            share()\n          );\n        }\n        return p$;\n      }\n    });\n\n  const debugName = typeof opt.debug === 'string' ? `[${typePrefix}${opt.debug}] ` : typePrefix;\n  const interceptor$ = new BehaviorSubject<OperatorFunction<ActionTypes<AC>[keyof AC], ActionTypes<AC>[keyof AC]> | null>(null);\n\n  function changeActionInterceptor(\n    factory: (\n      origin: OperatorFunction<ActionTypes<AC>[keyof AC], ActionTypes<AC>[keyof AC]> | null\n    ) => OperatorFunction<ActionTypes<AC>[keyof AC], ActionTypes<AC>[keyof AC]>\n  ) {\n    const newInterceptor = factory(interceptor$.getValue());\n    interceptor$.next(newInterceptor);\n  }\n\n  const debuggableAction$ = opt.debug\n    ? actionUpstream.pipe(\n      opt.log ?\n        tap(action => opt.log!(debugName + 'rx:action', nameOfAction(action))) :\n        (typeof window !== 'undefined') || (typeof Worker !== 'undefined') ?\n          tap(action => {\n            // eslint-disable-next-line no-console\n            console.log(`%c ${debugName}rx:action `, 'color: white; background: #8c61ff;',\n              nameOfAction(action),\n              action.payload === undefined ? '' : action.payload\n            );\n          })\n          :\n          // eslint-disable-next-line no-console\n          tap(action => console.log(debugName + 'rx:action', nameOfAction(action),\n            action.payload === undefined ? '' : action.payload )),\n      share()\n    )\n    : actionUpstream;\n\n  const action$ = interceptor$.pipe(\n    switchMap(interceptor => interceptor ?\n      debuggableAction$.pipe(interceptor, share()) :\n      debuggableAction$)\n  );\n\n  function debugLogLatestActionOperator<P>(type: string) {\n    return opt.log ?\n      map<P, P>((payload, idx) => {\n        if (idx === 0) {\n          opt.log!(debugName + 'rx:latest', type);\n        }\n        return payload;\n      }) :\n      (typeof window !== 'undefined') || (typeof Worker !== 'undefined') ?\n        map<P, P>((payload, idx) => {\n          if (idx === 0) {\n            // eslint-disable-next-line no-console\n            console.log(`%c ${debugName}rx:latest `, 'color: #f0fe0fe0; background: #8c61dd;', type,\n              payload === undefined ? '' : payload\n            );\n          }\n          return payload;\n        }) :\n        map<P, P>((payload, idx) => {\n          if (idx === 0) {\n            // eslint-disable-next-line no-console\n            console.log(debugName + 'rx:action', type, payload === undefined ? '' : payload);\n          }\n          return payload;\n        });\n  }\n\n  return {\n    dispatcher: dispatcherProxy,\n    createLatestPayloads<R extends keyof AC>(...types: R[]) {\n      const replayedPayloads = {} as {[K in R]: Observable<InferParam<AC[K]>>};\n      for (const key of types) {\n        const r$ = new ReplaySubject<InferParam<AC[R]>>(1);\n        replayedPayloads[key] = opt.debug ?\n          r$.asObservable().pipe(\n            debugLogLatestActionOperator(key as string)\n          ) :\n          r$.asObservable();\n        payloadByTypeProxy[key].subscribe(r$);\n      }\n      return replayedPayloads;\n    },\n    dispatchFactory: dispatchFactory as SimpleActionDispatchFactory<AC>,\n    dispatchStream: actionUpstream,\n    action$,\n    payloadByType: payloadByTypeProxy,\n    actionByType: actionByTypeProxy,\n    actionOfType,\n    changeActionInterceptor,\n    ofType,\n    isActionType: createIsActionTypeFn<AC>(typePrefix),\n    nameOfAction: (action: ActionTypes<AC>[keyof AC]) => nameOfAction<AC>(action),\n    createAction,\n    _actionFromObject(obj: {t: string; p: any}) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      actionUpstream.next({type: typePrefix + obj.t, payload: obj.p} as ActionTypes<AC>[keyof AC]);\n    },\n    objectToAction(obj: {t: string; p: any}) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      return {type: typePrefix + obj.t, payload: obj.p} as ActionTypes<AC>[keyof AC];\n    },\n    _actionToObject(action: ActionTypes<AC>[keyof AC]) {\n      return {t: nameOfAction(action) as string, p: action.payload};\n    }\n  };\n}\n\n/**\n * Get the \"action name\" from payload's \"type\" field,\n * `payload.type`` is actually consist of string like `${Prefix}/${actionName}`,\n * this function returns the `actionName` part\n * @return undefined if current action doesn't have a valid \"type\" field\n */\n// eslint-disable-next-line space-before-function-paren\nexport function nameOfAction<AC extends Record<string, ((...payload: any[]) => void)>>(\n  action: ActionTypes<AC>[keyof AC]\n): keyof AC | undefined {\n  return action.type.split('/')[1];\n}\n\nexport interface OfTypeFn<AC> {\n  <T extends keyof AC>(type: T): (upstream: Observable<any>) => Observable<ActionTypes<AC>[T]>;\n  <T extends keyof AC, T2 extends keyof AC>(type: T, type2: T2): (\n    upstream: Observable<any>\n  ) => Observable<ActionTypes<AC>[T] | ActionTypes<AC>[T2]>;\n  <T extends keyof AC, T2 extends keyof AC, T3 extends keyof AC>(type: T, type2: T2, type3: T3): (\n    upstream: Observable<any>\n  ) => Observable<ActionTypes<AC>[T] | ActionTypes<AC>[T2] | ActionTypes<AC>[T3]>;\n  <T extends keyof AC>(...types: T[]): (upstream: Observable<any>) => Observable<ActionTypes<AC>[T]>;\n}\n\nfunction createIsActionTypeFn<AC>(prefix: string) {\n  return function isActionType<K extends keyof AC>(action: {type: unknown}, type: K): action is ActionTypes<AC>[K] {\n    return action.type === prefix + (type as string);\n  };\n}\n\n/** create rx a operator to filter action by action.type */\nfunction createOfTypeOperator<AC>(typePrefix = ''): OfTypeFn<AC> {\n  return <T extends keyof AC>(...types: T[]) =>\n    (upstream: Observable<any>) => {\n      const matchTypes = types.map(type => typePrefix + (type as string));\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return upstream.pipe(\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        filter((action) : action is ActionTypes<AC>[T] => matchTypes.some(type => action.type === type)),\n        share()\n      ) ;\n    };\n}\n\n// type TestActions<X extends string> = {\n//   action1(p: string): void;\n//   action2(a: string, b: number): void;\n//   action3(): void;\n//   action4<A extends string>(y: number, x: X, z: A): void;\n// };\n\n// type TestActionsB = {\n//   action5(a: Observable<ActionTypes<TestActions<string>>[keyof TestActions<string>]>): void;\n// };\n// const ctl = createActionStreamByType<TestActions<'abc' | 'xyz'> & TestActionsB>();\n// ctl.payloadByType.action5.pipe();\n"]}