{"version":3,"file":"replace-require.js","sourceRoot":"","sources":["../ts/replace-require.ts"],"names":[],"mappings":"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","sourcesContent":["// tslint:disable: member-ordering\n// import {Transform} from 'stream';\nimport log4js from 'log4js';\nimport ts from 'typescript';\nimport _ from 'lodash';\nimport {ReplacementInf} from './patch-text';\nimport {FactoryMap, ReplaceType, FactoryMapInterf} from './factory-map';\nimport Injector, {InjectorOption, ResolveOption} from './node-inject';\nimport {TypescriptParser} from './parse-ts-import';\n\nconst log = log4js.getLogger('require-injector.replace-require');\n\n// acornjsx = acornImpInject(acorn);\n\nexport interface RequireInjector {\n  fromPackage(packageName: string | string[], resolveOpt?: ResolveOption): FactoryMapInterf;\n  fromDir(dir: string | string[]): FactoryMapInterf;\n  fromRoot(): FactoryMapInterf;\n  // transform(file: string): Transform;\n  injectToFile(filePath: string, code: string, ast?: any): string;\n  cleanup(): void;\n}\n\n// function replace(code: string, factoryMaps: FactoryMap[], fileParam: any, ast: any) {\n//   return new ReplaceRequire().replace(code, factoryMaps, fileParam, ast);\n//   // return ReplaceRequire.prototype.replace.apply(new ReplaceRequire(), arguments);\n// }\n\nexport default class ReplaceRequire extends Injector implements RequireInjector {\n\n  // transform: (file: string) => Transform;\n  protected tsParser: TypescriptParser;\n  /**\n\t * opts.enableFactoryParamFile `true` if you need \"filePath\" as parameter for .factory(factory(filePath) {...})\n\t * \tthis will expose original source file path in code, default is `false`.\n\t */\n  constructor(opts?: InjectorOption) {\n    super(opts);\n    if (!(this instanceof ReplaceRequire)) {\n      return new ReplaceRequire(opts);\n    }\n    this.tsParser = new TypescriptParser(this);\n\n    // this.transform = function(file: string) {\n    //   if (!_.endsWith(file, '.js')) {\n    //     return through();\n    //   }\n    //   let data = '';\n    //   return through(write, end);\n\n    //   function write(buf: string, enc: string, next: through.TransformCallback) {\n    //     data += buf; next();\n    //   }\n    //   function end(next: through.TransformCallback) {\n    //     this.push(self.injectToFile(file, data));\n    //     next();\n    //   }\n    // };\n  }\n\n  changeTsCompiler(tsCompiler: typeof ts) {\n    this.tsParser.ts = tsCompiler;\n  }\n\n  cleanup() {\n    this.removeAllListeners('replace');\n    super.cleanup();\n  }\n  /**\n\t * Here \"inject\" is actually \"replacement\".\n\t Parsing a matched file to Acorn AST tree, looking for matched `require(module)` expression and replacing\n\t  them with proper values, expression.\n\t * @name injectToFile\n\t * @param  {string} filePath file path\n\t * @param  {string} code     content of file\n\t * @param  {object} ast      optional, if you have already parsed code to AST tree, pass it to this function which\n\t *  helps to speed up process by skip parsing again.\n\t * @return {string}          replaced source code, if there is no injectable `require()`,\n\t * \tsame source code will be returned.\n\t */\n  injectToFile(filePath: string, code: string, ast?: ts.SourceFile) {\n    return this.injectToFileWithPatchInfo(filePath, code, ast).replaced;\n  }\n\n  /**\n\t * @return patch information, so that other parser tool can resue AST and \n\t * calculate position with these patch information\n\t */\n  injectToFileWithPatchInfo(filePath: string, code: string, ast?: ts.SourceFile):\n  {replaced: string; patches: Array<{start: number; end: number; replacement: string}>; ast: ts.SourceFile} {\n    let factoryMaps: FactoryMap[] | undefined;\n    try {\n      factoryMaps = this.factoryMapsForFile(filePath);\n      if (factoryMaps.length > 0) {\n        // if (/\\.tsx?$/.test(filePath)) {\n        const result = this.tsParser.replace(code, factoryMaps, filePath, ast);\n        // } else\n        // replaced = this.replace(code, factoryMaps, filePath, ast);\n        if (result.replaced != null)\n          return result as {\n            replaced: string;\n            patches: Array<{start: number; end: number; replacement: string}>;\n            ast: ts.SourceFile;\n          };\n      }\n      return {replaced: code, patches: [], ast: this.tsParser.srcfile};\n    } catch (e: unknown) {\n      log.error('filePath: ' + filePath);\n      if (factoryMaps != null)\n        log.error(_.map(factoryMaps, factoryMap => factoryMap.requireMap).join());\n      log.error((e as Error).stack);\n      throw e;\n    }\n  }\n\n  addPatch(patches: ReplacementInf[], start: number, end: number, moduleName: string,\n    replaceType: ReplaceType, fmaps: FactoryMap[], fileParam: string) {\n    const self = this;\n    let setting;\n    for (const factoryMap of fmaps) {\n      setting = factoryMap.matchRequire(moduleName);\n      if (setting) {\n        const replacement = factoryMap.getReplacement(setting, replaceType, fileParam);\n        if (replacement != null) {\n          patches.push({\n            start,\n            end,\n            replacement: typeof (replacement) === 'string' ?\n              replacement\n              : (replacement ).code\n          });\n          self.emit('replace', moduleName, replacement);\n        }\n        break;\n      }\n    }\n  }\n}\n\n// export function parseCode(code: string) {\n//   var ast;\n//   var firstCompileErr = null;\n//   try {\n//     ast = acornjsx.parse(code, {allowHashBang: true, sourceType: 'module'});\n//   } catch (err) {\n//     firstCompileErr = err;\n//     try {\n//       ast = acorn.parse(code, {allowHashBang: true});\n//     } catch (err2) {\n//       log.error('Possible ES compilation error', firstCompileErr);\n//       firstCompileErr.message += '\\nOr ' + err2.message;\n//       firstCompileErr.stack += '\\nAnother possible compilation error is\\n' + err2.stack;\n//       throw firstCompileErr;\n//     }\n//   }\n//   return ast;\n// }\n"]}