{"version":3,"file":"ts-ast-query.js","sourceRoot":"","sources":["../ts/ts-ast-query.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from 'fs';\n// import api from '__api';\nimport _ from 'lodash';\nimport ts from 'typescript';\nimport { SyntaxKind as sk } from 'typescript';\nconst {green, yellow} = require('chalk');\n// const log = require('log4js').getLogger('ts-ast-query');\n\nexport function printFile(fileName: string) {\n\tif (!fileName) {\n\t\t// tslint:disable-next-line\n\t\tconsole.log('Usage:\\n' + green('drcp run @dr-core/ng-app-builder/dist/utils/ts-ast-query --file <ts file>'));\n\t\treturn;\n\t}\n\tnew Selector(fs.readFileSync(fileName, 'utf8'), fileName).printAll();\n}\n\nexport interface WalkCallback {\n\tquery: string;\n\tcallback: (ast: ts.Node, path: string[], parents?: ts.Node[]) => true | void;\n}\n// type Callback = (ast: ts.Node, path: string[]) => boolean | void;\nexport default class Selector {\n\tsrc: ts.SourceFile;\n\n\tconstructor(src: string, file: string);\n\tconstructor(src: ts.SourceFile);\n\tconstructor(src: ts.SourceFile | string, file?: string) {\n\t\tif (typeof src === 'string') {\n\t\t\tthis.src = ts.createSourceFile(file || 'unknown', src, ts.ScriptTarget.ESNext,\n\t\t\t\ttrue, ts.ScriptKind.TSX);\n\t\t} else {\n\t\t\tthis.src = src;\n\t\t}\n\t}\n\n\twalkAst(handlers: WalkCallback[]): void;\n\twalkAst(ast: ts.Node, handlers: WalkCallback[]): void;\n\twalkAst(ast: ts.Node|WalkCallback[] , handlers?: WalkCallback[]): void {\n\t\tif (Array.isArray(ast)) {\n\t\t\thandlers = ast;\n\t\t\tast = this.src;\n\t\t}\n\n\t\tconst queryMap: {[str: string]: Query} = {};\n\t\tif (!handlers)\n\t\t\treturn;\n\t\thandlers.forEach(h => queryMap[h.query] = new Query(h.query));\n\n\t\tthis.traverse(ast, (ast, path, parents) => {\n\t\t\tlet skip = false;\n\t\t\thandlers!.some(h => {\n\t\t\t\tif (queryMap[h.query].matches(path)) {\n\t\t\t\t  h.callback(ast, path, parents);\n\t\t\t\t  return true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t});\n\t\t\tif (skip)\n\t\t\t\treturn true;\n\t\t});\n\t}\n\n\t/**\n\t * \n\t * @param query Like CSS select := [\"^\"] <selector element> (\" \" | \">\") <selector element>\n\t *   where <selector element> := \".\" <property name> <index>? | \":\" <Typescript Syntax kind name> | *\n\t *   where <index> := \"[\" \"0\"-\"9\" \"]\"\n\t * \n\t * e.g.\n\t *  - .elements:ImportSpecifier > .name\n\t *  - .elements[2] > .name\n\t *  - ^.statements[0] :ImportSpecifier > :Identifier\n\t * Begining with \"^\" means strictly comparing from first queried AST node\n\t * @param callback \n\t */\n\tfindWith<T>(query: string, callback: (ast: ts.Node, path: string[], parents: ts.Node[]) => T): T | null;\n\tfindWith<T>(ast: ts.Node, query: string, callback: (ast: ts.Node, path: string[], parents: ts.Node[]) => T): T | null;\n\tfindWith<T>(...arg: any[]): T | null {\n\t\tlet query: string;\n\t\tlet ast: ts.Node;\n\t\tlet callback: (ast: ts.Node, path: string[], parents: ts.Node[]) => T;\n\t\tif (typeof arg[0] === 'string') {\n\t\t\tast = this.src;\n\t\t\tquery = arg[0];\n\t\t\tcallback = arg[1];\n\t\t} else {\n\t\t\tast = arg[0];\n\t\t\tquery = arg[1];\n\t\t\tcallback = arg[2];\n\t\t}\n\t\tlet res: T | null = null;\n\t\tconst q = new Query(query!);\n\n\t\tthis.traverse(ast, (ast, path, parents) => {\n\t\t\tif (res != null)\n\t\t\t\treturn true;\n\t\t\tif (q.matches(path)) {\n\t\t\t\tres = callback(ast, path, parents);\n\t\t\t\tif (res != null)\n\t\t\t\t  return true;\n\t\t\t}\n\t\t});\n\t\treturn res;\n\t}\n\n\t/**\n\t * \n\t * @param ast root AST node\n\t * @param query Like CSS select := [\"^\"] <selector element> (\" \" | \">\") <selector element>\n\t *   where <selector element> := \".\" <property name> <index>? | \":\" <Typescript Syntax kind name> | *\n\t *   where <index> := \"[\" \"0\"-\"9\" \"]\"\n\t * e.g.\n\t *  - .elements:ImportSpecifier > .name\n\t *  - .elements[2] > .name\n\t *  - .statements[0] :ImportSpecifier > :Identifier\n\t */\n\tfindAll(query: string): ts.Node[];\n\tfindAll(ast: ts.Node, query: string): ts.Node[];\n\tfindAll(ast: ts.Node | string, query?: string): ts.Node[] {\n\t\tlet q: Query;\n\t\tif (typeof ast === 'string') {\n\t\t\tquery = ast;\n\t\t\tq = new Query(ast);\n\t\t\tast = this.src;\n\t\t} else {\n\t\t\tq = new Query(query!);\n\t\t}\n\n\t\tconst res: ts.Node[] = [];\n\t\tthis.traverse(ast, (ast, path, _parents, _isLeaf) => {\n\t\t\tif (q.matches(path)) {\n\t\t\t\tres.push(ast);\n\t\t\t}\n\t\t});\n\t\treturn res;\n\t}\n\t/**\n\t * \n\t * @param ast root AST node\n\t * @param query Like CSS select := [\"^\"] <selector element> (\" \" | \">\") <selector element>\n\t *   where <selector element> := \".\" <property name> <index>? | \":\" <Typescript Syntax kind name> | *\n\t *   where <index> := \"[\" \"0\"-\"9\" \"]\"\n\t * e.g.\n\t *  - .elements:ImportSpecifier > .name\n\t *  - .elements[2] > .name\n\t *  - .statements[0] :ImportSpecifier > :Identifier\n\t */\n\tfindFirst(query: string): ts.Node | undefined;\n\tfindFirst(ast: ts.Node, query: string): ts.Node | undefined;\n\tfindFirst(ast: ts.Node | string, query?: string): ts.Node | undefined {\n\t\tlet q: Query;\n\t\tif (typeof ast === 'string') {\n\t\t\tquery = ast;\n\t\t\tq = new Query(query);\n\t\t\tast = this.src;\n\t\t} else {\n\t\t\tq = new Query(query!);\n\t\t}\n\t\tlet res: ts.Node | undefined;\n\t\tthis.traverse(ast, (ast, path) => {\n\t\t\tif (res)\n\t\t\t\treturn true;\n\t\t\tif (q.matches(path)) {\n\t\t\t\tres = ast;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\treturn res;\n\t}\n\n\tlist(ast: ts.Node = this.src) {\n\t\tlet out = '';\n\t\tthis.traverse(ast, (node, path, _parents, noChild) => {\n\t\t\tif (noChild) {\n\t\t\t\tout += path.join('>') + ' ' + node.getText(this.src);\n\t\t\t\tout += '\\n';\n\t\t\t}\n\t\t});\n\t\treturn out;\n\t}\n\n\tprintAll(ast: ts.Node = this.src) {\n\t\tthis.traverse(ast, (node, path, _parents, noChild) => {\n\t\t\tif (noChild) {\n\t\t\t\t// tslint:disable-next-line:no-console\n\t\t\t\tconsole.log(path.join('>'), green(node.getText(this.src)));\n\t\t\t}\n\t\t});\n\t}\n\n\tprintAllNoType(ast: ts.Node = this.src) {\n\t\tthis.traverse(ast, (node, path, _parents, noChild) => {\n\t\t\tif (noChild) {\n\t\t\t\t// tslint:disable-next-line:no-console\n\t\t\t\tconsole.log(path.map(name => name.split(':')[0]).join('>'), green(node.getText(this.src)));\n\t\t\t}\n\t\t});\n\t}\n\t/**\n\t * \n\t * @param ast \n\t * @param cb return true to skip traversing child node\n\t * @param level default 0\n\t */\n\ttraverse(ast: ts.Node,\n\t\tcb: (ast: ts.Node, path: string[], parents: ts.Node[], isLeaf: boolean) => true | void,\n\t\tpropName = '', parents: ts.Node[] = [], pathEls: string[] = []) {\n\n\t\tlet needPopPathEl = false;\n\n\t\t// if (ast.kind !== ts.SyntaxKind.SourceFile) {\n\t\t\t// let propName = parents[parents.length - 1] === this.src ? '' : this._findParentPropName(ast, parents);\n\t\tlet pathEl = ':' + sk[ast.kind];\n\t\tif (propName)\n\t\t\tpathEl = '.' + propName + pathEl;\n\t\tpathEls.push(pathEl);\n\t\tneedPopPathEl = true;\n\t\t// }\n\n\t\tconst res = cb(ast, pathEls, parents, ast.getChildCount(this.src) <= 0);\n\n\t\tif (res !== true) {\n\t\t\tparents.push(ast);\n\t\t\tconst _value2key = new Map<any, string>();\n\t\t\t// tslint:disable-next-line:forin\n\t\t\t// for (const key in ast) {\n\t\t\tconst self = this;\n\t\t\tfor (const key of Object.keys(ast)) {\n\t\t\t\tif (key === 'parent' || key === 'kind')\n\t\t\t\t  continue;\n\t\t\t\t  _value2key.set((ast as any)[key], key);\n\t\t\t}\n\t\t\tts.forEachChild(ast, sub => {\n\t\t\t\t  self.traverse(sub, cb, _value2key.get(sub), parents, pathEls);\n\t\t\t\t},\n\t\t\t\tsubArray => self.traverseArray(subArray, cb, _value2key.get(subArray), parents, pathEls)\n\t\t\t);\n\t\t\tparents.pop();\n\t\t}\n\t\tif (needPopPathEl)\n\t\t\tpathEls.pop();\n\t}\n\n\tpathForAst(ast: ts.Node): string {\n\t\tconst pathEls: string[] = [];\n\t\tlet p = ast;\n\t\twhile (p && p !== this.src) {\n\t\t\tpathEls.push(this.propNameForAst(p) + ':' + sk[p.kind]);\n\t\t\tp = p.parent;\n\t\t}\n\t\treturn pathEls.reverse().join('>');\n\t}\n\n\tprotected propNameForAst(ast: ts.Node): string {\n\t\tconst p = ast.parent;\n\t\tfor (const prop of Object.keys(p)) {\n\t\t\tconst value = (p as any)[prop];\n\t\t\tif (prop === 'parent' || prop === 'kind')\n\t\t\t\tcontinue;\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tconst idx = (value as any[]).indexOf(ast);\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t  return prop + `[${idx}]`;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (value === ast) {\n\t\t\t\treturn prop;\n\t\t\t}\n\t\t}\n\t\treturn '';\n\t}\n\n\tprotected traverseArray(nodes: ts.NodeArray<ts.Node>,\n\t\tcb: (ast: ts.Node, path: string[], parents: ts.Node[], isLeaf: boolean) => true | void,\n\t\tpropName = '', parents: ts.Node[] = [], pathEls: string[] = []) {\n\n\t\tlet i = 0;\n\t\tfor (const ast of nodes) {\n\t\t\tthis.traverse(ast, cb, propName + `[${i++}]`, parents, pathEls);\n\t\t}\n\t}\n}\n\nexport interface AstCharacter {\n\tpropertyName?: string;\n\tpropIndex?: number;\n\tkind?: string;\n}\n\nexport interface AstQuery extends AstCharacter {\n\ttext?: RegExp;\n}\n\nexport class Query {\n\tqueryPaths: AstCharacter[][]; // in reversed order\n\tprivate fromRoot = false;\n\n\tconstructor(query: string) {\n\t\tif (query.startsWith('^')) {\n\t\t\tquery = query.slice(1);\n\t\t\tthis.fromRoot = true;\n\t\t}\n\t\tthis.queryPaths = query.trim()\n\t\t\t.replace(/\\s*>\\s*/g, '>')\n\t\t\t.split(/\\s+/)\n\t\t\t.map(paths => paths.split('>')\n\t\t\t\t.map(singleAstDesc => this._parseDesc(singleAstDesc)).reverse())\n\t\t\t.reverse();\n\t}\n\n\tmatches(path: string[]): boolean {\n\t\tlet testPos = path.length - 1;\n\t\tconst startTestPos = testPos;\n\t\tfor (const consecutiveNodes of this.queryPaths.slice(0)) {\n\t\t\twhile (true) {\n\t\t\t\tif (this.matchesConsecutiveNodes(consecutiveNodes, path, testPos)) {\n\t\t\t\t  testPos -= consecutiveNodes.length;\n\t\t\t\t  break;\n\t\t\t\t} else if (testPos === startTestPos) {\n\t\t\t\t  return false;\n\t\t\t\t} else {\n\t\t\t\t  testPos--;\n\t\t\t\t}\n\t\t\t\tif (consecutiveNodes.length > testPos + 1)\n\t\t\t\t  return false;\n\t\t\t}\n\t\t}\n\t\treturn this.fromRoot ? testPos === 0 : true;\n\t}\n\n\tprotected _parseDesc(singleAstDesc: string): AstQuery {\n\t\tconst astChar: AstQuery = {};\n\t\t\t// tslint:disable-next-line\n\t\t\tlet m = /^(?:\\.([a-zA-Z0-9_$]+)(?:\\[([0-9]*)\\])?)?(?:\\:([a-zA-Z0-9_$]+))?$|^\\*$/.exec(singleAstDesc);\n\t\t\tif (m == null) {\n\t\t\t\tthrow new Error(`Invalid query string \"${yellow(singleAstDesc)}\"`);\n\t\t\t}\n\t\t\tif (m[1]) {\n\t\t\t\tastChar.propertyName = m[1];\n\t\t\t\tif (m[2])\n\t\t\t\t  astChar.propIndex = parseInt(m[2], 10);\n\t\t\t}\n\t\t\tif (m[3])\n\t\t\t\tastChar.kind = m[3];\n\t\t\t// if (m[4])\n\t\t\t// \tastChar.text = new RegExp(m[4]);\n\t\t\treturn astChar;\n\t}\n\n\tprivate matchesAst(query: AstQuery, target: AstCharacter): boolean {\n\t\tfor (const key of Object.keys(query)) {\n\t\t\tconst value = (query as any)[key];\n\t\t\tif (_.isRegExp(value)) {\n\t\t\t\tif (!(value as RegExp).test((target as any)[key]))\n\t\t\t\t  return false;\n\t\t\t} else if ((target as any)[key] !== value)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * predicte if it matches \">\" connected path expression \n\t * @param queryNodes all items in reversed order\n\t * @param path \n\t * @param testPos starts with path.length - 1\n\t */\n\tprivate matchesConsecutiveNodes(queryNodes: AstCharacter[], path: string[], testPos: number) {\n\t\tif (queryNodes.length > testPos + 1)\n\t\t\treturn false;\n\t\tfor (const query of queryNodes.slice(0)) {\n\t\t\tconst target = this._parseDesc(path[testPos--]);\n\t\t\tif (!this.matchesAst(query, target))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}\n"]}