{"version":3,"file":"factory-map.js","sourceRoot":"","sources":["../ts/factory-map.ts"],"names":[],"mappings":"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","sourcesContent":["// tslint:disable max-line-length\nimport {ParseInfo, ParseExportInfo} from './parse-esnext-import';\nimport * as _ from 'lodash';\nvar Path = require('path');\nimport {toAssignment} from './parse-esnext-import';\n\nexport interface Config {\n\t[key: string]: any;\n\tenableFactoryParamFile?: boolean | undefined;\n}\nexport interface FactorySetting {\n\tmethod: keyof ReplaceActions;\n\tprefix: string;\n\tvalue?: FactoryFunc | any;\n\texecResult?: RegExpExecArray;\n\tsubPath?: string;\n\treplacement?: (file: string, execResult: RegExpExecArray) => any | string;\n}\n\nexport interface ReplaceTypeValue {\n\treplacement: string;\n\tvalue: any | FactoryFunc;\n}\n/** // TODO */\nexport enum ReplaceType {\n\trq= 0, // require()\n\tima, // import()\n\timp, // import expression\n\trs // require.ensure()\n}\n\nexport interface RegexSetting extends FactorySetting {\n\tregex: RegExp;\n}\n\n// export type FactorySetting = FactorySettingObj;\n\nexport interface ReplacedResult {replaceAll: boolean; code: string;}\ninterface ReplaceActions {\n\t[method: string]: (this: FactoryMap, replaceWith: FactoryFunc | any, type: ReplaceType, fileParam: string, execResult: RegExpExecArray,\n\t\tastInfo: ParseInfo, prefix?: any, subPath?: string) => null | string | ReplacedResult;\n}\n\ninterface InjectActions {\n\t[method: string]: InjectActionFunc;\n}\ntype InjectActionFunc = (this: FactoryMap, value: FactoryFunc | any,\n\tcalleeModuleId: string,\n\tcalleeModule: any,\n\trequireCall: (m: any, file: string) => FactorySetting,\n\tsubPath?: string) => FactorySetting;\n\nexport type FactoryFunc = (sourceFilePath: string, regexpExecResult?: RegExpExecArray) => any;\n\nexport class FactoryMap implements FactoryMapInterf {\n\tconfig: Config;\n\trequireMap: {[k: string]: FactorySetting} = {};\n\tbeginWithSearch: any[] = []; // Binary search\n\tregexSettings: RegexSetting[] = [];\n\tbeginWithSorted: boolean = false;\n\tprivate resolvePaths: string[] | null = null;\n\t// static METHODS: string[] = ['factory', 'substitute', 'value', 'swigTemplateDir', 'replaceCode', 'variable'];\n\n\tconstructor(config?: Config) {\n\t\tif (config === undefined)\n\t\t\tthis.config = {};\n\t\telse\n\t\t\tthis.config = config;\n\t}\n\n\tfactory(requiredModule: string | RegExp, factoryFunc: FactoryFunc): FactoryMapInterf {\n\t\treturn this._addSetting('factory', requiredModule, factoryFunc);\n\t}\n\n\tsubstitute(requiredModule: string | RegExp, newModule: string| FactoryFunc): FactoryMapInterf {\n\t\treturn this._addSetting('substitute', requiredModule, newModule);\n\t}\n\tvalue(requiredModule: string | RegExp, newModule: {replacement: any}| FactoryFunc | any): FactoryMapInterf {\n\t\treturn this._addSetting('value', requiredModule, newModule);\n\t}\n\n\tswigTemplateDir(requiredModule: string, dir: string): FactoryMapInterf {\n\t\treturn this._addSetting('swigTemplateDir', requiredModule, dir);\n\t}\n\n\treplaceCode(requiredModule: string | RegExp, newModule: string| FactoryFunc): FactoryMapInterf {\n\t\treturn this._addSetting('replaceCode', requiredModule, newModule);\n\t}\n\n\talias(requiredModule: string | RegExp, newModule: string| FactoryFunc): FactoryMapInterf {\n\t\treturn this._addSetting('substitute', requiredModule, newModule);\n\t}\n\t// asInterface() {\n\t// \treturn ((this as any) as FactoryMapInterf & FactoryMap);\n\t// }\n\n\tgetInjector(name: string): FactorySetting | null {\n\t\treturn this.matchRequire(name);\n\t}\n\t// you can extend with new method here\n\n\tmatchRequire(name: string): FactorySetting | null {\n\t\tif (!name)\n\t\t\treturn null;\n\t\tvar webpackLoaderPrefix = '';\n\t\tvar webpackLoaderIdx = name.lastIndexOf('!');\n\t\tif (webpackLoaderIdx >= 0) {\n\t\t\twebpackLoaderPrefix = name.substring(0, webpackLoaderIdx + 1);\n\t\t\tname = name.substring(webpackLoaderIdx + 1);\n\t\t}\n\n\t\tlet setting: FactorySetting;\n\t\tif (_.has(this.requireMap, name)) {\n\t\t\tsetting = _.extend({}, this.requireMap[name]);\n\t\t\tsetting.prefix = webpackLoaderPrefix;\n\t\t\treturn setting;\n\t\t} else {\n\t\t\tconst isPackage = !_.startsWith(name, '.') && !Path.isAbsolute(name);\n\t\t\tif (isPackage && (_.startsWith(name, '@') || name.indexOf('/') > 0)) {\n\t\t\t\tvar m = /^((?:@[^\\/]+\\/)?[^\\/]+)(\\/.+?)?$/.exec(name);\n\t\t\t\tif (m && _.has(this.requireMap, m[1])) {\n\t\t\t\t\tsetting = _.extend({}, this.requireMap[m[1]]);\n\t\t\t\t\tsetting.subPath = m[2];\n\t\t\t\t\tsetting.prefix = webpackLoaderPrefix;\n\t\t\t\t\treturn setting;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet foundReg =  _.find(this.regexSettings, s => {\n\t\t\t\ts.execResult = s.regex.exec(name) || undefined;\n\t\t\t\treturn s.execResult != null;\n\t\t\t});\n\t\t\tif (foundReg) {\n\t\t\t\tfoundReg = _.extend({}, foundReg);\n\t\t\t\tfoundReg.prefix = webpackLoaderPrefix;\n\t\t\t\treturn foundReg;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param  {any} factorySetting matchRequire() returned value\n\t * @param  {ReplaceType} type       \"rq\" for \"require()\", \"rs\" for \"require.ensure\"\n\t * @param  {string} fileParam  current replacing file path\n\t * @return {string}            replacement text\n\t */\n\tgetReplacement(factorySetting: FactorySetting, type: ReplaceType, fileParam: string, info?: ParseInfo | ParseExportInfo): string | ReplacedResult | null {\n\t\tif (!factorySetting)\n\t\t\tthrow new Error('This is require-injector\\' fault, error due to null factorySetting, tell author about it.');\n\t\treturn replaceActions[factorySetting.method].call(this,\n\t\t\tfactorySetting.value, type, fileParam, factorySetting.execResult,\n\t\t\tinfo, factorySetting.prefix, factorySetting.subPath);\n\t}\n\n\tgetInjected(factorySetting: FactorySetting, calleeModuleId: string, calleeModule: any,\n\t\trequireCall: (m: any, file: string) => FactorySetting): any {\n\t\tif (!factorySetting)\n\t\t\tthrow new Error('This is require-injector\\'s fault, error due to null factorySetting, tell author about it.');\n\t\treturn injectActions[factorySetting.method].call(this, factorySetting.value,\n\t\t\tcalleeModuleId, calleeModule, requireCall, factorySetting.subPath);\n\t}\n\n\taddResolvePath(dir: string) {\n\t\tif (this.resolvePaths == null)\n\t\t\tthis.resolvePaths = [];\n\t\tthis.resolvePaths.push(dir);\n\t\treturn this;\n\t}\n\n\t_addSetting(this: FactoryMap, method: string, name: string | RegExp, value: FactoryFunc | any) {\n\t\tif (_.isRegExp(name)) {\n\t\t\tthis.regexSettings.push( {\n\t\t\t\tregex: name,\n\t\t\t\tmethod,\n\t\t\t\tvalue,\n\t\t\t\tsubPath: '',\n\t\t\t\tprefix: ''\n\t\t\t});\n\t\t} else {\n\t\t\tthis.requireMap[name] = {\n\t\t\t\tmethod,\n\t\t\t\tvalue,\n\t\t\t\tsubPath: '',\n\t\t\t\tprefix: ''\n\t\t\t};\n\t\t}\n\t\treturn this;\n\t}\n}\n\nlet replaceActions: ReplaceActions = {\n\tfactory(this: FactoryMap, value: FactoryFunc, type: ReplaceType, fileParam: string, execResult: RegExpExecArray,\n\t\tastInfo: ParseInfo, prefix?: any, subPath?: string): string | ReplacedResult | null {\n\t\tconst sourcePath = JSON.stringify(this.config.enableFactoryParamFile ? fileParam : '');\n\t\tconst execFactory = '(' + value.toString() + ')(' + sourcePath +\n\t\t\t\t(execResult ? ',' + JSON.stringify(execResult) : '') + ')';\n\n\t\tif (type === ReplaceType.rq || type === ReplaceType.ima) { // for require() or import()\n\t\t\treturn execFactory;\n\t\t} else if (type === ReplaceType.imp) {\n\t\t\treturn {\n\t\t\t\treplaceAll: true,\n\t\t\t\tcode: toAssignment(astInfo, execFactory)\n\t\t\t};\n\t\t}\n\t\treturn null;\n\t},\n\n\tsubstitute(this: FactoryMap, setting: FactoryFunc | string, type: ReplaceType, fileParam: string, execResult: RegExpExecArray,\n\t\tastInfo: ParseInfo, prefix?: any, subPath?: string): string | ReplacedResult | null {\n\t\tif (type === ReplaceType.rs) { // for require.ensure\n\t\t\tif (_.isFunction(setting))\n\t\t\t\treturn JSON.stringify(setting(fileParam, execResult) + subPath);\n\t\t\treturn JSON.stringify(setting + subPath);\n\t\t} else if (type === ReplaceType.rq) {\n\t\t\tif (_.isFunction(setting))\n\t\t\t\treturn 'require(' + JSON.stringify(prefix + setting(fileParam, execResult)) + subPath + ')';\n\t\t\treturn 'require(' + JSON.stringify(prefix + setting + subPath) + ')';\n\t\t} else if (type === ReplaceType.ima) {\n\t\t\tif (_.isFunction(setting))\n\t\t\t\treturn 'import(' + JSON.stringify(prefix + setting(fileParam, execResult)) + subPath + ')';\n\t\t\treturn 'import(' + JSON.stringify(prefix + setting) + subPath + ')';\n\t\t} else if (type === ReplaceType.imp) {\n\t\t\tvar replaced = _.isFunction(setting) ? setting(fileParam, execResult) : setting;\n\t\t\treplaced = JSON.stringify(prefix + replaced + subPath);\n\t\t\treturn {\n\t\t\t\treplaceAll: false,\n\t\t\t\tcode: replaced\n\t\t\t};\n\t\t}\n\t\treturn null;\n\t},\n\n\tvalue(this: FactoryMap, setting: FactoryFunc | {replacement: FactoryFunc | string}, type: ReplaceType, fileParam: string, execResult: RegExpExecArray,\n\t\tastInfo: ParseInfo, prefix?: any, subPath?: string): ReplacedResult | string | null {\n\t\tif (type === ReplaceType.rq || type === ReplaceType.imp || type === ReplaceType.ima) {\n\t\t\tvar replaced;\n\t\t\tif (_.has(setting, 'replacement')) {\n\t\t\t\tconst setting1 = setting as {replacement: FactoryFunc};\n\t\t\t\treplaced = (_.isFunction(setting1.replacement)) ?\n\t\t\t\t\t(setting1.replacement as FactoryFunc)(fileParam, execResult) :\n\t\t\t\t\tsetting1.replacement as any;\n\t\t\t} else {\n\t\t\t\treplaced = _.isFunction(setting) ? JSON.stringify(setting(fileParam, execResult)) :\n\t\t\t\t\tJSON.stringify(setting);\n\t\t\t}\n\t\t\treturn type === ReplaceType.imp ? {\n\t\t\t\t\treplaceAll: true,\n\t\t\t\t\tcode: toAssignment(astInfo, replaced)\n\t\t\t\t} : replaced;\n\t\t}\n\t\treturn null;\n\t},\n\n\treplaceCode(setting: FactoryFunc | string, type: ReplaceType, fileParam: string, execResult: RegExpExecArray,\n\t\tastInfo: ParseInfo, prefix?: any, subPath?: string): ReplacedResult | string {\n\t\tvar replaced = setting as string;\n\t\tif (_.isFunction(setting))\n\t\t\treplaced = setting(fileParam, execResult);\n\t\treturn type === ReplaceType.imp ? {\n\t\t\treplaceAll: true,\n\t\t\tcode: toAssignment(astInfo, replaced)\n\t\t} : replaced;\n\t},\n\n\tvariable(setting: string, type: ReplaceType, fileParam: string, execResult: RegExpExecArray,\n\t\tastInfo: ParseInfo) {\n\t\tif (type === ReplaceType.rq || type === ReplaceType.ima) {\n\t\t\treturn setting as string;\n\t\t}\n\t\tif (type === ReplaceType.imp)\n\t\t\treturn {\n\t\t\t\treplaceAll: true,\n\t\t\t\tcode: toAssignment(astInfo, setting as string)\n\t\t\t};\n\t\treturn null;\n\t}\n\n\t// resolvePath(dir: FactorySetting, type: string, fileParam: string, execResult: RegExpExecArray,\n\t// \tastInfo: ParseInfo): string {\n\t// \treturn dir as string;\n\t// }\n};\n\nexport interface FactoryMapInterf {\n\t/**\n\t * Replacing a required module with a function returned value. Not working for `require.ensure()`\n\t * @param requiredModule the original module name which is required for, it can't be a relative file path.\n\t * @param factoryFunc A function invoked with 1 argument: `sourceFilePath` and returns a value which then will replace the original module of `requiredModule`.\n\t * \n\t * **Note**: In browser side replacement mode, it replaces entire `require('requiredModule')` expression in source code with Immediately-Invoked Function Expression (IIFE) of the factory function`.toString()`:\n\t\t```js\n// require('requiredModule'); ->\n'(' + factory.toString() + ')(sourceFilePath, regexpExecResult)';\n```\n\t\t> In replacement mode, parameter `sourceFilePath` will be null by default, since this would expose\n\t\toriginal source file path of your file system, if you still want to obtain `sourceFilePath`, set option `.enableFactoryParamFile`\n\t\tto `true`\n\n\t\tThe factory eventually stands in source code, not NodeJS runtime.\n\t\tThus you can not have any reference to any closure variable in factory function.\n\t */\n\tfactory(requiredModule: string | RegExp, factoryFunc: FactoryFunc): FactoryMapInterf;\n\t/**\n\t * Or\n\t\t`alias(requiredModule, newModule)`\n\n\t\tReplacing a required module with requiring another module.\n\t\t> Also support `npm://package` reference in Swig template tags `include` and `import`,\n\t\tcheck this out [swig-package-tmpl-loader injection](https://www.npmjs.com/package/swig-package-tmpl-loader#injection)\n\n\t\t> It works very like **Webpack**'s `resolve.alias`,\n\t\tit also matches module name which is consist of node package name and specific path\n\n\t\te.g.\n\t\tWhen injector is configured as\n\t\t```js\n\t\trj.fromDir('.').alias('moduleA', 'moduleB');\n\t\t```\n\t\tThen the file contains `require('moduleA/foo/bar.js')` will be replaced with `require('moduleB/foo/bar.js')`\n\t * @param requiredModule the original module name which is required for, it can't be relative file path, only supports absolute path, a package name or Regular Expression.\n\t> Package name like `lodash/throttle` also works, as long as it can be resolved to same absolute path all the time.\n\t * @param newModule the new module name that is replaced with.\n\t * If `newModule` is a function, it will be passed in 2 parameters: `sourceFilePath` and `regexpExecResult`, and must return string value of replaced module name.\n\t*/\n\tsubstitute(requiredModule: string | RegExp, newModule: string| FactoryFunc): FactoryMapInterf;\n\t/**\n\t * Replacing a required module with any object or primitive value.\n\t\t> Not work for `require.ensure()`\n\t * @param requiredModule the original module name which is required for, it can't be a relative file path.\n\t * @param newModule the value to replace `requiredModule` exports.\n\t * \n\t * When `.injectToFile()` is called or `.transform` is used for Browserify, meaning it is not a Node environment, the solution is actually replacing entire `require('requiredModule')`‘’ expression with result of `JSON.stringify(value)`.\n\t\tSometimes, the value is variable reference,\n\t\tyou wouldn't want `JSON.stringify` for it, you can use an object expression:\n\t\t- `{string}` `value.replacement`: The replaced string literal as variable expression, same as what `.replaceCode()` does.\n\t\t- `{object}` `value.value`: Node require injection value\n\t\t```js\n\t\trj.fromDir('dir1')\n\t\t.value('replaceMe', {\n\t\t\treplacement: 'window.jQuery', // for Browserify transform\n\t\t\tvalue: cheerio   // for Node require() injection\n\t\t})\n\t\t```\n\t\tIf `value` is a function, it will be passed in 2 parameters: `sourceFilePath` and `regexpExecResult`, and must return some value.\n\t*/\n\tvalue(requiredModule: string | RegExp, newModule: ReplaceTypeValue | FactoryFunc | any): FactoryMapInterf;\n\t/**\n\t * Replace `npm://package` reference in Swig template tags `include` and `import`,\ncheck this out [swig-package-tmpl-loader injection](https://www.npmjs.com/package/swig-package-tmpl-loader#injection)\n\t * @param requiredModule \n\t * @param dir \n\t */\n\tswigTemplateDir(requiredModule: string, dir: string): FactoryMapInterf;\n\t/**\n\t * Arbitrary JS code replacement\n\t> Only work in replacement mode, not NodeJs side\n\n\t```js\n\tvar rjReplace = rj({noNode: true});\n\trjReplace.fromPackage([packageA...])\n\t\t.replaceCode('foobar', JSON.stringify({foo: 'bar'}));\n\t```\n\tIn which \"`var foobar = require('foobar');\"` is replaced with:\n\t```js\n\tvar  foobar = {\"foo\": \"bar\"};\n\t```\n\t * @param requiredModule \n\t * @param newModule \n\t */\n\treplaceCode(requiredModule: string | RegExp, newModule: string| FactoryFunc): FactoryMapInterf;\n\t/**\n\t * Same as substitute()\n\t * @param requiredModule \n\t * @param newModule \n\t */\n\talias(requiredModule: string | RegExp, newModule: string| FactoryFunc): FactoryMapInterf;\n}\n\nlet injectActions: InjectActions = {\n\tfactory(setting: FactorySetting,\n\t\tcalleeModuleId: string,\n\t\tcalleeModule?: any,\n\t\trequireCall?: (m: any, file: string) => FactorySetting,\n\t\tsubPath?: string) {\n\t\tif (_.isFunction(setting)) {\n\t\t\treturn setting(calleeModuleId);\n\t\t} else {\n\t\t\treturn setting;\n\t\t}\n\t},\n\n\tvalue(setting: FactorySetting,\n\t\tcalleeModuleId: string,\n\t\tcalleeModule: any,\n\t\trequireCall: (m: any, file: string) => FactorySetting,\n\t\tsubPath?: string) {\n\t\tif (_.has(setting, 'value'))\n\t\t\treturn setting.value;\n\t\telse\n\t\t\treturn setting;\n\t},\n\n\treplaceCode(setting: FactorySetting,\n\t\tcalleeModuleId: string,\n\t\tcalleeModule: any,\n\t\trequireCall: (m: any, file: string) => FactorySetting,\n\t\tsubPath?: string): any {\n\t\t// tslint:disable-next-line:no-console\n\t\tconsole.log('require-injector does not support \"replaceCode()\" for NodeJS environment');\n\t},\n\n\tsubstitute(setting: any, calleeModuleId: string, calleeModule: any,\n\t\trequireCall: (m: any, file: string) => FactorySetting, subPath?: string) {\n\t\treturn requireCall.call(calleeModule, setting + subPath);\n\t},\n\n\tvariable(setting: FactorySetting,\n\t\tcalleeModuleId: string,\n\t\tcalleeModule?: any,\n\t\trequireCall?: (m: any, file: string) => FactorySetting,\n\t\tsubPath?: string) {\n\t\treturn setting;\n\t}\n};\n\nexport class FactoryMapCollection implements FactoryMapInterf {\n\tmaps: FactoryMapInterf[];\n\tconstructor(maps: FactoryMapInterf[]) {\n\t\tthis.maps = maps;\n\t}\n\tfactory(requiredModule: string | RegExp, factoryFunc: FactoryFunc): FactoryMapInterf {\n\t\treturn this._addSetting('factory', requiredModule, factoryFunc);\n\t}\n\n\tsubstitute(requiredModule: string | RegExp, newModule: string| FactoryFunc): FactoryMapInterf {\n\t\treturn this._addSetting('substitute', requiredModule, newModule);\n\t}\n\tvalue(requiredModule: string | RegExp, newModule: any| FactoryFunc): FactoryMapInterf {\n\t\treturn this._addSetting('value', requiredModule, newModule);\n\t}\n\n\tswigTemplateDir(requiredModule: string, dir: string): FactoryMapInterf {\n\t\treturn this._addSetting('swigTemplateDir', requiredModule, dir);\n\t}\n\n\treplaceCode(requiredModule: string | RegExp, newModule: string| FactoryFunc): FactoryMapInterf {\n\t\treturn this._addSetting('replaceCode', requiredModule, newModule);\n\t}\n\n\talias(requiredModule: string | RegExp, newModule: string| FactoryFunc): FactoryMapInterf {\n\t\treturn this._addSetting('substitute', requiredModule, newModule);\n\t}\n\tprotected _addSetting(this: FactoryMapCollection, method: string, requiredModule: string | RegExp, newModule: string| FactoryFunc): FactoryMapInterf {\n\t\tfor (const factoryMap of this.maps) {\n\t\t\t(factoryMap as FactoryMap)._addSetting(method, requiredModule, newModule);\n\t\t}\n\t\treturn this;\n\t}\n}\n\n"]}