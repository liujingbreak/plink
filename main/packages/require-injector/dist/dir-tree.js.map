{"version":3,"file":"dir-tree.js","sourceRoot":"","sources":["../ts/dir-tree.ts"],"names":[],"mappings":"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","sourcesContent":["import Path from 'path';\nimport _ from 'lodash';\n// const os = require('os');\n// var isWin32 = os.platform().indexOf('win32') >= 0;\n\nexport interface TreeNode<T> {\n  map: {[child: string]: TreeNode<T>};\n  name: string;\n  data?: T;\n}\nexport class DirTree<T> {\n  root: TreeNode<T> = {map: {}, name: ''};\n\n  putRootData(data: T) {\n    this.root.data = data;\n  }\n\n  getRootData() {\n    return this.root.data;\n  }\n\n  putData(path: string, data: T) {\n    if (!path) {\n      this.putRootData(data);\n      return;\n    }\n    const tree = this.ensureNode(path);\n    tree.data = data;\n  }\n\n  getData(path: string): T | null | undefined {\n    if (!path) {\n      return this.getRootData();\n    }\n    const tree = this.findNode(path);\n    return tree ? tree.data : null;\n  }\n\n  /**\n\t * @return Array of data\n\t */\n  getAllData(path: string | string[]): T[] {\n    if (!Array.isArray(path)) {\n      if (Path.sep === '\\\\')\n        path = path.toLowerCase();\n      return this.getAllData(path.split(/[/\\\\]/));\n    }\n    // if (path[0] === '')\n    // \tpath.shift();\n    let tree = this.root;\n    const datas: T[] = [];\n    if (_.has(tree, 'data'))\n      datas.push(tree.data!);\n    _.every(path, name => {\n      if (_.has(tree, ['map', name])) {\n        tree = tree.map[name];\n        if (_.has(tree, 'data'))\n          datas.push(tree.data!);\n        return true;\n      }\n      // tree = null;\n      return false;\n    });\n    return datas;\n  }\n\n  ensureNode(path: string | string[]): TreeNode<T> {\n    if (!Array.isArray(path)) {\n      if (Path.sep === '\\\\')\n        path = path.toLowerCase();\n      return this.ensureNode(path.split(/[/\\\\]/));\n    }\n    let tree = this.root;\n    _.each(path, name => {\n      if (_.has(tree, ['map', name])) {\n        tree = tree.map[name];\n      } else {\n        const child = {map: {}, name};\n        tree.map[name] = child;\n        tree = child;\n      }\n    });\n    return tree;\n  }\n\n  findNode(path: string | string[]): TreeNode<T> | null {\n    if (!Array.isArray(path)) {\n      if (Path.sep === '\\\\')\n        path = path.toLowerCase();\n      return this.findNode(path.split(/[/\\\\]/));\n    }\n    let tree: TreeNode<T> | null = this.root;\n    _.every(path, name => {\n      if (_.has(tree, ['map', name])) {\n        tree = tree!.map[name];\n        return true;\n      }\n      tree = null;\n      return false;\n    });\n    return tree;\n  }\n\n  traverse(level = 0, tree?: TreeNode<T>, lines: string[] = []) {\n    let isRoot = false;\n    if (!level)\n      level = 0;\n    if (!tree)\n      tree = this.root;\n    if (!lines) {\n      isRoot = true;\n      lines = [];\n    }\n    const indent = _.repeat('│  ', level);\n    lines.push(indent + '├─ ' + tree.name + (tree.data ? ' [x]' : ''));\n    _.each(tree.map, (subTree, subNames) => {\n      this.traverse(level + 1, subTree, lines);\n    });\n    return isRoot ? lines.join('\\n') : lines;\n  }\n}\n"]}