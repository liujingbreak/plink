import { RedBlackTree } from './rb-tree';
/**
 * Maintaining:
 *  node.max = max(node.int[1], node.left.max, node.right.max)
 *
 *
 */
export class IntervalTree extends RedBlackTree {
    insertInterval(low, high, data) {
        var _a;
        const node = this.insert(low);
        if (node.int) {
            // A duplicate low boundray
            node.multi = [
                [node.int[1], node.value],
                [high, data]
            ];
            node.int = undefined;
        }
        else if (node.multi) {
            if (node.multi.length >= 3) {
                node.highValuesTree = new RedBlackTree();
                for (const [h, v] of node.multi) {
                    node.highValuesTree.insert(h).value = v;
                }
                node.highValuesTree.insert(high).value = data;
                node.multi = undefined;
            }
            else {
                node.multi.push([high, data]);
            }
        }
        else if (node.highValuesTree) {
            node.highValuesTree.insert(high).value = data;
        }
        else {
            node.int = [low, high];
            node.value = data;
        }
        if (high > ((_a = node.maxHighOfMulti) !== null && _a !== void 0 ? _a : Number.MIN_VALUE)) {
            node.maxHighOfMulti = high;
        }
        maintainNodeMaxValue(node);
        return node;
    }
    deleteInterval(low, high) {
        const node = this.search(low);
        if (node == null)
            return false;
        if (node.int && node.int[1] === high) {
            this.deleteNode(node);
            return true;
        }
        else if (node.multi != null) {
            const multiLen = node.multi.length;
            node.multi = node.multi.filter(it => it[0] !== high);
            const deleted = multiLen !== node.multi.length;
            const origMaxHigh = node.maxHighOfMulti;
            if (node.multi.length === 1) {
                node.int = [node.key, node.multi[0][0]];
                node.value = node.multi[0][1];
                node.multi = undefined;
                node.maxHighOfMulti = node.int[1];
            }
            else if (deleted) {
                node.maxHighOfMulti = node.multi.reduce((max, curr) => Math.max(curr[0], max), Number.MIN_VALUE);
            }
            if (origMaxHigh !== node.maxHighOfMulti)
                maintainNodeMaxValue(node);
            return deleted;
        }
        else if (node.highValuesTree) {
            const origMaxHigh = node.maxHighOfMulti;
            const deleted = node.highValuesTree.delete(high);
            if (deleted && node.highValuesTree.size() === 1) {
                node.int = [node.key, node.highValuesTree.root.key];
                node.value = node.highValuesTree.root.value;
                node.highValuesTree = undefined;
                node.maxHighOfMulti = node.int[1];
                if (origMaxHigh !== node.maxHighOfMulti)
                    maintainNodeMaxValue(node);
                return true;
            }
            else if (deleted) {
                node.maxHighOfMulti = node.highValuesTree.maximum().key;
                if (origMaxHigh !== node.maxHighOfMulti)
                    maintainNodeMaxValue(node);
                return true;
            }
        }
        return false;
    }
    searchSingleOverlap(low, high) {
        let node = this.root;
        while (node && !doesIntervalOverlap([node.key, node.maxHighOfMulti], [low, high])) {
            if (node.left && low <= node.left.max) {
                node = node.left;
            }
            else {
                node = node.right;
            }
        }
        return node;
    }
    *searchMultipleOverlaps(low, high) {
        const foundNodes = [];
        searchMultipleOverlaps(foundNodes, low, high, this.root);
        // const intervals = new Array<[number, number, V, IntervalTreeNode<V>]>(foundNodes.length);
        for (const node of foundNodes) {
            if (node.int) {
                yield [...node.int, node.value, node];
            }
            else if (node.multi) {
                for (const [h, data] of node.multi) {
                    if (doesIntervalOverlap([low, high], [node.key, h])) {
                        yield [node.key, h, data, node];
                    }
                }
            }
            else if (node.highValuesTree) {
                for (const highTreeNode of node.highValuesTree.keysSmallererThan(high)) {
                    yield [node.key, highTreeNode.key, highTreeNode.value, node];
                }
            }
        }
    }
    /** @Override
     */
    onLeftChildChange(parent, child) {
        maintainNodeMaxValue(parent);
    }
    /** @Override
     */
    onRightChildChange(parent, child) {
        maintainNodeMaxValue(parent);
    }
}
function maintainNodeMaxValue(node) {
    var _a, _b, _c, _d;
    let currNode = node;
    while (currNode) {
        if (currNode.maxHighOfMulti == null)
            throw new Error('currNode.maxHighOfMulti should not be empty');
        currNode.max = Math.max(currNode.maxHighOfMulti, Math.max((_b = (_a = currNode.left) === null || _a === void 0 ? void 0 : _a.max) !== null && _b !== void 0 ? _b : Number.MIN_VALUE, (_d = (_c = currNode.right) === null || _c === void 0 ? void 0 : _c.max) !== null && _d !== void 0 ? _d : Number.MIN_VALUE));
        currNode = currNode.p;
    }
}
function doesIntervalOverlap(intA, intB) {
    // Not in case of: intA is left to intB or intA is right to intB entirely
    return !(intA[1] < intB[0] || intB[1] < intA[0]);
}
function searchMultipleOverlaps(overlaps, low, high, node) {
    if (node == null) {
        return 0;
    }
    let numOverlaps = 0;
    if (doesIntervalOverlap([node.key, node.maxHighOfMulti], [low, high])) {
        overlaps.push(node);
        numOverlaps = 1;
    }
    if (node.left && low <= node.left.max) {
        const numOverlapsLeft = searchMultipleOverlaps(overlaps, low, high, node.left);
        if (numOverlapsLeft > 0) {
            numOverlaps += numOverlapsLeft;
            numOverlaps += searchMultipleOverlaps(overlaps, low, high, node.right);
        }
        // Skip right child, as if zero left child overlaps, then
        // target interval's high value must be even smaller than all left children's low values,
        // meaning entire left child tree is greater than target interval, so right child tree does the same
    }
    else {
        numOverlaps += searchMultipleOverlaps(overlaps, low, high, node.right);
    }
    return numOverlaps;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJ2YWwtdHJlZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3RzL3NoYXJlL2FsZ29yaXRobXMvaW50ZXJ2YWwtdHJlZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQWEsWUFBWSxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBbUJuRDs7Ozs7R0FLRztBQUNILE1BQU0sT0FBTyxZQUEwQixTQUFRLFlBQTRDO0lBQ3pGLGNBQWMsQ0FBQyxHQUFXLEVBQUUsSUFBWSxFQUFFLElBQU87O1FBQy9DLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDOUIsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFO1lBQ1osMkJBQTJCO1lBQzNCLElBQUksQ0FBQyxLQUFLLEdBQUc7Z0JBQ1gsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFVLENBQUM7Z0JBQzlCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQzthQUNiLENBQUM7WUFDRixJQUFJLENBQUMsR0FBRyxHQUFHLFNBQVMsQ0FBQztTQUN0QjthQUFNLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNyQixJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRTtnQkFDMUIsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLFlBQVksRUFBYSxDQUFDO2dCQUNwRCxLQUFLLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtvQkFDL0IsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztpQkFDekM7Z0JBQ0QsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztnQkFDOUMsSUFBSSxD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ZSc7XG5cbi8qKlxuICogQSBSZWQgYmxhY2sgdHJlZSBub2RlIHRvIGNvbnRhaW5zIG11bHRpcGxlIGludGVydmFscyB3aGljaCBoYXMgc2FtZSBcImxvd1wiIHZhbHVlLFxuICogXCJrZXlcIiBpcyBpbnRlcnZhbCdzIGxvdyB2YWx1ZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEludGVydmFsVHJlZU5vZGU8ViA9IHVua25vd24+IGV4dGVuZHMgUmJUcmVlTm9kZTxudW1iZXIsIFYsIEludGVydmFsVHJlZU5vZGU8Vj4+IHtcbiAgLyoqIEZvciBubyBkdXBsaWNhdGUgc2luZ2xlIGludGVydmFsKi9cbiAgaW50PzogW2xvdzogbnVtYmVyLCBoaWdoOiBudW1iZXJdO1xuICAvKiogRm9yIDItMyBpbnRlcnZhbHMgd2hpY2ggaGFzIHNhbWUgXCJsb3dcIiB2YWx1ZSBidXQgZGlmZmVyZW50IFwiaGlnaFwiIHZhbHVlICovXG4gIG11bHRpPzogW2hpZ2g6IG51bWJlciwgZGF0YTogVl1bXTtcbiAgLyoqIEZvciA0KyBpbnRlcnZhbHMsIGEgdHJlZSB0byBzdG9yZSBkaWZmZXJlbnQgXCJoaWdoXCIgdmFsdWUgKi9cbiAgaGlnaFZhbHVlc1RyZWU/OiBSZWRCbGFja1RyZWU8bnVtYmVyLCBWPjtcbiAgLyoqIE1heGltdW0gXCJoaWdoXCIgdmFsdWUgb2YgbXVsdGkgaW50ZXJ2YWxzIHRoYXQgdGhpcyBub2RlIGNvbnRhaW5zICovXG4gIG1heEhpZ2hPZk11bHRpPzogbnVtYmVyO1xuICAvKiogTWF4aW11bSBcImhpZ2hcIiBvZiBjaGlsZHJlbiAqL1xuICBtYXg6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBNYWludGFpbmluZzpcbiAqICBub2RlLm1heCA9IG1heChub2RlLmludFsxXSwgbm9kZS5sZWZ0Lm1heCwgbm9kZS5yaWdodC5tYXgpXG4gKlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIEludGVydmFsVHJlZTxWID0gdW5rbm93bj4gZXh0ZW5kcyBSZWRCbGFja1RyZWU8bnVtYmVyLCBWLCBJbnRlcnZhbFRyZWVOb2RlPFY+PiB7XG4gIGluc2VydEludGVydmFsKGxvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIsIGRhdGE6IFYpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5pbnNlcnQobG93KTtcbiAgICBpZiAobm9kZS5pbnQpIHtcbiAgICAgIC8vIEEgZHVwbGljYXRlIGxvdyBib3VuZHJheVxuICAgICAgbm9kZS5tdWx0aSA9IFtcbiAgICAgICAgW25vZGUuaW50WzFdLCBub2RlLnZhbHVlIGFzIFZdLFxuICAgICAgICBbaGlnaCwgZGF0YV1cbiAgICAgIF07XG4gICAgICBub2RlLmludCA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKG5vZGUubXVsdGkpIHtcbiAgICAgIGlmIChub2RlLm11bHRpLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgIG5vZGUuaGlnaFZhbHVlc1RyZWUgPSBuZXcgUmVkQmxhY2tUcmVlPG51bWJlciwgVj4oKTtcbiAgICAgICAgZm9yIChjb25zdCBbaCwgdl0gb2Ygbm9kZS5tdWx0aSkge1xuICAgICAgICAgIG5vZGUuaGlnaFZhbHVlc1RyZWUuaW5zZXJ0KGgpLnZhbHVlID0gdjtcbiAgICAgICAgfVxuICAgICAgICBub2RlLmhpZ2hWYWx1ZXNUcmVlLmluc2VydChoaWdoKS52YWx1ZSA9IGRhdGE7XG4gICAgICAgIG5vZGUubXVsdGkgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLm11bHRpLnB1c2goW2hpZ2gsIGRhdGFdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUuaGlnaFZhbHVlc1RyZWUpIHtcbiAgICAgIG5vZGUuaGlnaFZhbHVlc1RyZWUuaW5zZXJ0KGhpZ2gpLnZhbHVlID0gZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5pbnQgPSBbbG93LCBoaWdoXTtcbiAgICAgIG5vZGUudmFsdWUgPSBkYXRhO1xuICAgIH1cbiAgICBpZiAoaGlnaCA+IChub2RlLm1heEhpZ2hPZk11bHRpID8/IE51bWJlci5NSU5fVkFMVUUpKSB7XG4gICAgICBub2RlLm1heEhpZ2hPZk11bHRpID0gaGlnaDtcbiAgICB9XG4gICAgbWFpbnRhaW5Ob2RlTWF4VmFsdWUobm9kZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBkZWxldGVJbnRlcnZhbChsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc2VhcmNoKGxvdyk7XG4gICAgaWYgKG5vZGUgPT0gbnVsbClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAobm9kZS5pbnQgJiYgbm9kZS5pbnRbMV0gPT09IGhpZ2gpIHtcbiAgICAgIHRoaXMuZGVsZXRlTm9kZShub2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5tdWx0aSAhPSBudWxsKSB7XG4gICAgICBjb25zdCBtdWx0aUxlbiA9IG5vZGUubXVsdGkubGVuZ3RoO1xuICAgICAgbm9kZS5tdWx0aSA9IG5vZGUubXVsdGkuZmlsdGVyKGl0ID0+IGl0WzBdICE9PSBoaWdoKTtcbiAgICAgIGNvbnN0IGRlbGV0ZWQgPSBtdWx0aUxlbiAhPT0gbm9kZS5tdWx0aS5sZW5ndGg7XG4gICAgICBjb25zdCBvcmlnTWF4SGlnaCA9IG5vZGUubWF4SGlnaE9mTXVsdGk7XG5cbiAgICAgIGlmIChub2RlLm11bHRpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBub2RlLmludCA9IFtub2RlLmtleSwgbm9kZS5tdWx0aVswXVswXV07XG4gICAgICAgIG5vZGUudmFsdWUgPSBub2RlLm11bHRpWzBdWzFdO1xuICAgICAgICBub2RlLm11bHRpID0gdW5kZWZpbmVkO1xuICAgICAgICBub2RlLm1heEhpZ2hPZk11bHRpID0gbm9kZS5pbnRbMV07XG4gICAgICB9IGVsc2UgaWYgKGRlbGV0ZWQpIHtcbiAgICAgICAgbm9kZS5tYXhIaWdoT2ZNdWx0aSA9IG5vZGUubXVsdGkucmVkdWNlKChtYXgsIGN1cnIpID0+IE1hdGgubWF4KGN1cnJbMF0sIG1heCksIE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAgfVxuICAgICAgaWYgKG9yaWdNYXhIaWdoICE9PSBub2RlLm1heEhpZ2hPZk11bHRpKVxuICAgICAgICBtYWludGFpbk5vZGVNYXhWYWx1ZShub2RlKTtcbiAgICAgIHJldHVybiBkZWxldGVkO1xuICAgIH0gZWxzZSBpZiAobm9kZS5oaWdoVmFsdWVzVHJlZSkge1xuICAgICAgY29uc3Qgb3JpZ01heEhpZ2ggPSBub2RlLm1heEhpZ2hPZk11bHRpO1xuICAgICAgY29uc3QgZGVsZXRlZCA9IG5vZGUuaGlnaFZhbHVlc1RyZWUuZGVsZXRlKGhpZ2gpO1xuICAgICAgaWYgKGRlbGV0ZWQgJiYgbm9kZS5oaWdoVmFsdWVzVHJlZS5zaXplKCkgPT09IDEpIHtcbiAgICAgICAgbm9kZS5pbnQgPSBbbm9kZS5rZXksIG5vZGUuaGlnaFZhbHVlc1RyZWUucm9vdCEua2V5XTtcbiAgICAgICAgbm9kZS52YWx1ZSA9IG5vZGUuaGlnaFZhbHVlc1RyZWUucm9vdCEudmFsdWU7XG4gICAgICAgIG5vZGUuaGlnaFZhbHVlc1RyZWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIG5vZGUubWF4SGlnaE9mTXVsdGkgPSBub2RlLmludFsxXTtcbiAgICAgICAgaWYgKG9yaWdNYXhIaWdoICE9PSBub2RlLm1heEhpZ2hPZk11bHRpKVxuICAgICAgICAgIG1haW50YWluTm9kZU1heFZhbHVlKG5vZGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGVsZXRlZCkge1xuICAgICAgICBub2RlLm1heEhpZ2hPZk11bHRpID0gbm9kZS5oaWdoVmFsdWVzVHJlZS5tYXhpbXVtKCkhLmtleTtcbiAgICAgICAgaWYgKG9yaWdNYXhIaWdoICE9PSBub2RlLm1heEhpZ2hPZk11bHRpKVxuICAgICAgICAgIG1haW50YWluTm9kZU1heFZhbHVlKG5vZGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc2VhcmNoU2luZ2xlT3ZlcmxhcChsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyKSB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLnJvb3Q7XG4gICAgd2hpbGUgKG5vZGUgJiYgIWRvZXNJbnRlcnZhbE92ZXJsYXAoW25vZGUua2V5LCBub2RlLm1heEhpZ2hPZk11bHRpIV0sIFtsb3csIGhpZ2hdKSkge1xuICAgICAgaWYgKG5vZGUubGVmdCAmJiBsb3cgPD0gbm9kZS5sZWZ0Lm1heCkge1xuICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgKnNlYXJjaE11bHRpcGxlT3ZlcmxhcHMobG93OiBudW1iZXIsIGhpZ2g6IG51bWJlcik6IEdlbmVyYXRvcjxbbG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgZGF0YTogViwgbm9kZTogSW50ZXJ2YWxUcmVlTm9kZTxWPl0+IHtcbiAgICBjb25zdCBmb3VuZE5vZGVzID0gW10gYXMgSW50ZXJ2YWxUcmVlTm9kZTxWPltdO1xuICAgIHNlYXJjaE11bHRpcGxlT3ZlcmxhcHMoZm91bmROb2RlcywgbG93LCBoaWdoLCB0aGlzLnJvb3QpO1xuICAgIC8vIGNvbnN0IGludGVydmFscyA9IG5ldyBBcnJheTxbbnVtYmVyLCBudW1iZXIsIFYsIEludGVydmFsVHJlZU5vZGU8Vj5dPihmb3VuZE5vZGVzLmxlbmd0aCk7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIGZvdW5kTm9kZXMpIHtcbiAgICAgIGlmIChub2RlLmludCkge1xuICAgICAgICB5aWVsZCBbLi4ubm9kZS5pbnQsIG5vZGUudmFsdWUsIG5vZGVdO1xuICAgICAgfSBlbHNlIGlmIChub2RlLm11bHRpKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2gsIGRhdGFdIG9mIG5vZGUubXVsdGkpIHtcbiAgICAgICAgICBpZiAoZG9lc0ludGVydmFsT3ZlcmxhcChbbG93LCBoaWdoXSwgW25vZGUua2V5LCBoXSkpIHtcbiAgICAgICAgICAgIHlpZWxkIFtub2RlLmtleSwgaCwgZGF0YSwgbm9kZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuaGlnaFZhbHVlc1RyZWUpIHtcbiAgICAgICAgZm9yIChjb25zdCBoaWdoVHJlZU5vZGUgb2Ygbm9kZS5oaWdoVmFsdWVzVHJlZS5rZXlzU21hbGxlcmVyVGhhbihoaWdoKSkge1xuICAgICAgICAgIHlpZWxkIFtub2RlLmtleSwgaGlnaFRyZWVOb2RlLmtleSwgaGlnaFRyZWVOb2RlLnZhbHVlLCBub2RlXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAT3ZlcnJpZGVcbiAgICovXG4gIHByb3RlY3RlZCBvbkxlZnRDaGlsZENoYW5nZShwYXJlbnQ6IEludGVydmFsVHJlZU5vZGU8Vj4sIGNoaWxkOiBJbnRlcnZhbFRyZWVOb2RlPFY+IHwgbnVsbCB8IHVuZGVmaW5lZCkge1xuICAgIG1haW50YWluTm9kZU1heFZhbHVlPFY+KHBhcmVudCk7XG4gIH1cbiAgLyoqIEBPdmVycmlkZVxuICAgKi9cbiAgcHJvdGVjdGVkIG9uUmlnaHRDaGlsZENoYW5nZShwYXJlbnQ6IEludGVydmFsVHJlZU5vZGU8Vj4sIGNoaWxkOiBJbnRlcnZhbFRyZWVOb2RlPFY+IHwgbnVsbCB8IHVuZGVmaW5lZCkge1xuICAgIG1haW50YWluTm9kZU1heFZhbHVlPFY+KHBhcmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFpbnRhaW5Ob2RlTWF4VmFsdWU8Vj4obm9kZTogSW50ZXJ2YWxUcmVlTm9kZTxWPikge1xuICBsZXQgY3Vyck5vZGU6IEludGVydmFsVHJlZU5vZGU8Vj4gfCBudWxsID0gbm9kZTtcbiAgd2hpbGUgKGN1cnJOb2RlKSB7XG4gICAgaWYgKGN1cnJOb2RlLm1heEhpZ2hPZk11bHRpID09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJOb2RlLm1heEhpZ2hPZk11bHRpIHNob3VsZCBub3QgYmUgZW1wdHknKTtcbiAgICBjdXJyTm9kZS5tYXggPSBNYXRoLm1heChjdXJyTm9kZS5tYXhIaWdoT2ZNdWx0aSwgTWF0aC5tYXgoXG4gICAgICBjdXJyTm9kZS5sZWZ0Py5tYXggPz8gTnVtYmVyLk1JTl9WQUxVRSwgY3Vyck5vZGUucmlnaHQ/Lm1heCA/PyBOdW1iZXIuTUlOX1ZBTFVFXG4gICAgKSk7XG4gICAgY3Vyck5vZGUgPSBjdXJyTm9kZS5wO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRvZXNJbnRlcnZhbE92ZXJsYXAoaW50QTogW251bWJlciwgbnVtYmVyXSwgaW50QjogW251bWJlciwgbnVtYmVyXSkge1xuICAvLyBOb3QgaW4gY2FzZSBvZjogaW50QSBpcyBsZWZ0IHRvIGludEIgb3IgaW50QSBpcyByaWdodCB0byBpbnRCIGVudGlyZWx5XG4gIHJldHVybiAhKGludEFbMV0gPCBpbnRCWzBdIHx8IGludEJbMV0gPCBpbnRBWzBdKTtcbn1cblxuZnVuY3Rpb24gc2VhcmNoTXVsdGlwbGVPdmVybGFwczxWPihcbiAgb3ZlcmxhcHM6IEludGVydmFsVHJlZU5vZGU8Vj5bXSwgbG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgbm9kZTogSW50ZXJ2YWxUcmVlTm9kZTxWPiB8IG51bGwgfCB1bmRlZmluZWRcbik6IG51bWJlciB7XG4gIGlmIChub2RlID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBsZXQgbnVtT3ZlcmxhcHMgPSAwO1xuICBpZiAoZG9lc0ludGVydmFsT3ZlcmxhcChbbm9kZS5rZXksIG5vZGUubWF4SGlnaE9mTXVsdGkhXSwgW2xvdywgaGlnaF0pKSB7XG4gICAgb3ZlcmxhcHMucHVzaChub2RlKTtcbiAgICBudW1PdmVybGFwcyA9IDE7XG4gIH1cbiAgaWYgKG5vZGUubGVmdCAmJiBsb3cgPD0gbm9kZS5sZWZ0Lm1heCkge1xuICAgIGNvbnN0IG51bU92ZXJsYXBzTGVmdCA9IHNlYXJjaE11bHRpcGxlT3ZlcmxhcHMob3ZlcmxhcHMsIGxvdywgaGlnaCwgbm9kZS5sZWZ0KTtcbiAgICBpZiAobnVtT3ZlcmxhcHNMZWZ0ID4gMCkge1xuICAgICAgbnVtT3ZlcmxhcHMgKz0gbnVtT3ZlcmxhcHNMZWZ0O1xuICAgICAgbnVtT3ZlcmxhcHMgKz0gc2VhcmNoTXVsdGlwbGVPdmVybGFwcyhvdmVybGFwcywgbG93LCBoaWdoLCBub2RlLnJpZ2h0KTtcbiAgICB9XG4gICAgLy8gU2tpcCByaWdodCBjaGlsZCwgYXMgaWYgemVybyBsZWZ0IGNoaWxkIG92ZXJsYXBzLCB0aGVuXG4gICAgLy8gdGFyZ2V0IGludGVydmFsJ3MgaGlnaCB2YWx1ZSBtdXN0IGJlIGV2ZW4gc21hbGxlciB0aGFuIGFsbCBsZWZ0IGNoaWxkcmVuJ3MgbG93IHZhbHVlcyxcbiAgICAvLyBtZWFuaW5nIGVudGlyZSBsZWZ0IGNoaWxkIHRyZWUgaXMgZ3JlYXRlciB0aGFuIHRhcmdldCBpbnRlcnZhbCwgc28gcmlnaHQgY2hpbGQgdHJlZSBkb2VzIHRoZSBzYW1lXG4gIH0gZWxzZSB7XG4gICAgbnVtT3ZlcmxhcHMgKz0gc2VhcmNoTXVsdGlwbGVPdmVybGFwcyhvdmVybGFwcywgbG93LCBoaWdoLCBub2RlLnJpZ2h0KTtcbiAgfVxuICByZXR1cm4gbnVtT3ZlcmxhcHM7XG59XG4iXX0=