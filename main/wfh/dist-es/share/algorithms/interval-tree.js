import { RedBlackTree } from './rb-tree';
/**
 * Maintaining:
 *  node.max = max(node.int[1], node.left.max, node.right.max)
 *
 *
 */
export class IntervalTree extends RedBlackTree {
    /** Return tree node, if property value is undefined */
    insertInterval(low, high) {
        var _a;
        let valueContainer;
        if (low > high) {
            const temp = high = low;
            low = temp;
        }
        const node = this.insert(low);
        if (node.int) {
            if (node.int[1] === high) {
                // duplicate high boundray value
                // node.value = data;
                return node;
            }
            // A duplicate low boundray
            node.highValuesTree = new RedBlackTree();
            node.highValuesTree.insert(node.int[1]).value = node.value;
            valueContainer = node.highValuesTree.insert(high);
            node.int = undefined;
            node.weight++;
        }
        if (node.highValuesTree) {
            // node.highValuesTree.insert(high).value = data;
            valueContainer = node.highValuesTree.insert(high);
            node.weight = node.highValuesTree.size();
        }
        else {
            node.int = [low, high];
            // node.value = data;
            valueContainer = node;
        }
        if (high > ((_a = node.maxHighOfMulti) !== null && _a !== void 0 ? _a : Number.MIN_VALUE)) {
            node.maxHighOfMulti = high;
        }
        maintainNodeMaxValue(node);
        return valueContainer;
    }
    deleteInterval(low, high) {
        const node = this.search(low);
        if (node == null)
            return false;
        if (node.int && node.int[1] === high) {
            this.deleteNode(node);
            return true;
        }
        else if (node.highValuesTree) {
            const origMaxHigh = node.maxHighOfMulti;
            const deleted = node.highValuesTree.delete(high);
            if (deleted) {
                node.weight--;
                if (node.highValuesTree.size() === 1) {
                    node.int = [node.key, node.highValuesTree.root.key];
                    node.value = node.highValuesTree.root.value;
                    node.highValuesTree = undefined;
                    node.maxHighOfMulti = node.int[1];
                    if (origMaxHigh !== node.maxHighOfMulti)
                        maintainNodeMaxValue(node);
                    return true;
                }
                else {
                    node.maxHighOfMulti = node.highValuesTree.maximum().key;
                    if (origMaxHigh !== node.maxHighOfMulti)
                        maintainNodeMaxValue(node);
                    return true;
                }
            }
        }
        return false;
    }
    searchSingleOverlap(low, high) {
        let node = this.root;
        while (node && !doesIntervalOverlap([node.key, node.maxHighOfMulti], [low, high])) {
            if (node.left && low <= node.left.max) {
                node = node.left;
            }
            else {
                node = node.right;
            }
        }
        return node;
    }
    *searchMultipleOverlaps(low, high) {
        const foundNodes = [];
        searchMultipleOverlaps(foundNodes, low, high, this.root);
        // const intervals = new Array<[number, number, V, IntervalTreeNode<V>]>(foundNodes.length);
        for (const node of foundNodes) {
            if (node.int) {
                yield [...node.int, node.value, node];
            }
            else if (node.highValuesTree) {
                for (const highTreeNode of node.highValuesTree.keysSmallererThan(high)) {
                    yield [node.key, highTreeNode.key, highTreeNode.value, node];
                }
            }
        }
    }
    /** @Override
     */
    onLeftChildChange(parent, child) {
        maintainNodeMaxValue(parent);
    }
    /** @Override
     */
    onRightChildChange(parent, child) {
        maintainNodeMaxValue(parent);
    }
}
function maintainNodeMaxValue(node) {
    var _a, _b, _c, _d, _e;
    let currNode = node;
    while (currNode) {
        // if (currNode.maxHighOfMulti == null)
        //   throw new Error('currNode.maxHighOfMulti should not be empty');
        currNode.max = Math.max((_a = currNode.maxHighOfMulti) !== null && _a !== void 0 ? _a : Number.MIN_VALUE, Math.max((_c = (_b = currNode.left) === null || _b === void 0 ? void 0 : _b.max) !== null && _c !== void 0 ? _c : Number.MIN_VALUE, (_e = (_d = currNode.right) === null || _d === void 0 ? void 0 : _d.max) !== null && _e !== void 0 ? _e : Number.MIN_VALUE));
        currNode = currNode.p;
    }
}
function doesIntervalOverlap(intA, intB) {
    // Not in case of: intA is left to intB or intA is right to intB entirely
    return !(intA[1] < intB[0] || intB[1] < intA[0]);
}
function searchMultipleOverlaps(overlaps, low, high, node) {
    if (node == null) {
        return 0;
    }
    let numOverlaps = 0;
    if (doesIntervalOverlap([node.key, node.maxHighOfMulti], [low, high])) {
        overlaps.push(node);
        numOverlaps = 1;
    }
    if (node.left && low <= node.left.max) {
        const numOverlapsLeft = searchMultipleOverlaps(overlaps, low, high, node.left);
        if (numOverlapsLeft > 0) {
            numOverlaps += numOverlapsLeft;
            numOverlaps += searchMultipleOverlaps(overlaps, low, high, node.right);
        }
        // Skip right child, as if zero left child overlaps, then
        // target interval's high value must be even smaller than all left children's low values,
        // meaning entire left child tree is greater than target interval, so right child tree does the same
    }
    else {
        numOverlaps += searchMultipleOverlaps(overlaps, low, high, node.right);
    }
    return numOverlaps;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJ2YWwtdHJlZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3RzL3NoYXJlL2FsZ29yaXRobXMvaW50ZXJ2YWwtdHJlZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQWEsWUFBWSxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBaUJuRDs7Ozs7R0FLRztBQUNILE1BQU0sT0FBTyxZQUEwQixTQUFRLFlBQTRDO0lBQ3pGLHVEQUF1RDtJQUN2RCxjQUFjLENBQUMsR0FBVyxFQUFFLElBQVk7O1FBR3RDLElBQUksY0FBcUgsQ0FBQztRQUMxSCxJQUFJLEdBQUcsR0FBRyxJQUFJLEVBQUU7WUFDZCxNQUFNLElBQUksR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDO1lBQ3hCLEdBQUcsR0FBRyxJQUFJLENBQUM7U0FDWjtRQUNELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDOUIsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFO1lBQ1osSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksRUFBRTtnQkFDeEIsZ0NBQWdDO2dCQUNoQyxxQkFBcUI7Z0JBQ3JCLE9BQU8sSUFBSSxDQUFDO2FBQ2I7WUFDRCwyQkFBMkI7WUFDM0IsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLFlBQVksRUFBYSxDQUFDO1lBQ3BELElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztZQUMzRCxjQUFjLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFbEQsSUFBSSxDQUFDLEdBQUcsR0FBRyxTQUFTLENBQUM7WUFDckIsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1NBQ2Y7UUFDRCxJQUFJLElB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QUcsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRTtRQUNyQyxNQUFNLGVBQWUsR0FBRyxzQkFBc0IsQ0FBQyxRQUFRLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDL0UsSUFBSSxlQUFlLEdBQUcsQ0FBQyxFQUFFO1lBQ3ZCLFdBQVcsSUFBSSxlQUFlLENBQUM7WUFDL0IsV0FBVyxJQUFJLHNCQUFzQixDQUFDLFFBQVEsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUN4RTtRQUNELHlEQUF5RDtRQUN6RCx5RkFBeUY7UUFDekYsb0dBQW9HO0tBQ3JHO1NBQU07UUFDTCxXQUFXLElBQUksc0JBQXNCLENBQUMsUUFBUSxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQ3hFO0lBQ0QsT0FBTyxXQUFXLENBQUM7QUFDckIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7UmJUcmVlTm9kZSwgUmVkQmxhY2tUcmVlfSBmcm9tICcuL3JiLXRyZWUnO1xuXG4vKipcbiAqIEEgUmVkIGJsYWNrIHRyZWUgbm9kZSB0byBjb250YWlucyBtdWx0aXBsZSBpbnRlcnZhbHMgd2hpY2ggaGFzIHNhbWUgXCJsb3dcIiB2YWx1ZSxcbiAqIFwia2V5XCIgaXMgaW50ZXJ2YWwncyBsb3cgdmFsdWVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbnRlcnZhbFRyZWVOb2RlPFYgPSB1bmtub3duPiBleHRlbmRzIFJiVHJlZU5vZGU8bnVtYmVyLCBWLCBJbnRlcnZhbFRyZWVOb2RlPFY+PiB7XG4gIC8qKiBGb3Igbm8gZHVwbGljYXRlIHNpbmdsZSBpbnRlcnZhbCovXG4gIGludD86IFtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyXTtcbiAgLyoqIEZvciBtdWx0aXBsZSBpbnRlcnZhbHMsIGEgdHJlZSB0byBzdG9yZSBkaWZmZXJlbnQgXCJoaWdoXCIgdmFsdWUgKi9cbiAgaGlnaFZhbHVlc1RyZWU/OiBSZWRCbGFja1RyZWU8bnVtYmVyLCBWPjtcbiAgLyoqIE1heGltdW0gXCJoaWdoXCIgdmFsdWUgb2YgbXVsdGkgaW50ZXJ2YWxzIHRoYXQgdGhpcyBub2RlIGNvbnRhaW5zICovXG4gIG1heEhpZ2hPZk11bHRpPzogbnVtYmVyO1xuICAvKiogTWF4aW11bSBcImhpZ2hcIiBvZiBjaGlsZHJlbiAqL1xuICBtYXg6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBNYWludGFpbmluZzpcbiAqICBub2RlLm1heCA9IG1heChub2RlLmludFsxXSwgbm9kZS5sZWZ0Lm1heCwgbm9kZS5yaWdodC5tYXgpXG4gKlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIEludGVydmFsVHJlZTxWID0gdW5rbm93bj4gZXh0ZW5kcyBSZWRCbGFja1RyZWU8bnVtYmVyLCBWLCBJbnRlcnZhbFRyZWVOb2RlPFY+PiB7XG4gIC8qKiBSZXR1cm4gdHJlZSBub2RlLCBpZiBwcm9wZXJ0eSB2YWx1ZSBpcyB1bmRlZmluZWQgKi9cbiAgaW5zZXJ0SW50ZXJ2YWwobG93OiBudW1iZXIsIGhpZ2g6IG51bWJlcik6XG4gIE9taXQ8SW50ZXJ2YWxUcmVlTm9kZTxWPiwgJ3ZhbHVlJz4gJiB7dmFsdWU/OiBWfSB8IE9taXQ8UmJUcmVlTm9kZTxudW1iZXIsIFY+LCAndmFsdWUnPiAmIHt2YWx1ZT86IFZ9IHtcblxuICAgIGxldCB2YWx1ZUNvbnRhaW5lcjogT21pdDxJbnRlcnZhbFRyZWVOb2RlPFY+LCAndmFsdWUnPiAmIHt2YWx1ZT86IFZ9IHwgT21pdDxSYlRyZWVOb2RlPG51bWJlciwgVj4sICd2YWx1ZSc+ICYge3ZhbHVlPzogVn07XG4gICAgaWYgKGxvdyA+IGhpZ2gpIHtcbiAgICAgIGNvbnN0IHRlbXAgPSBoaWdoID0gbG93O1xuICAgICAgbG93ID0gdGVtcDtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuaW5zZXJ0KGxvdyk7XG4gICAgaWYgKG5vZGUuaW50KSB7XG4gICAgICBpZiAobm9kZS5pbnRbMV0gPT09IGhpZ2gpIHtcbiAgICAgICAgLy8gZHVwbGljYXRlIGhpZ2ggYm91bmRyYXkgdmFsdWVcbiAgICAgICAgLy8gbm9kZS52YWx1ZSA9IGRhdGE7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgICAgLy8gQSBkdXBsaWNhdGUgbG93IGJvdW5kcmF5XG4gICAgICBub2RlLmhpZ2hWYWx1ZXNUcmVlID0gbmV3IFJlZEJsYWNrVHJlZTxudW1iZXIsIFY+KCk7XG4gICAgICBub2RlLmhpZ2hWYWx1ZXNUcmVlLmluc2VydChub2RlLmludFsxXSkudmFsdWUgPSBub2RlLnZhbHVlO1xuICAgICAgdmFsdWVDb250YWluZXIgPSBub2RlLmhpZ2hWYWx1ZXNUcmVlLmluc2VydChoaWdoKTtcblxuICAgICAgbm9kZS5pbnQgPSB1bmRlZmluZWQ7XG4gICAgICBub2RlLndlaWdodCsrO1xuICAgIH1cbiAgICBpZiAobm9kZS5oaWdoVmFsdWVzVHJlZSkge1xuICAgICAgLy8gbm9kZS5oaWdoVmFsdWVzVHJlZS5pbnNlcnQoaGlnaCkudmFsdWUgPSBkYXRhO1xuICAgICAgdmFsdWVDb250YWluZXIgPSBub2RlLmhpZ2hWYWx1ZXNUcmVlLmluc2VydChoaWdoKTtcbiAgICAgIG5vZGUud2VpZ2h0ID0gbm9kZS5oaWdoVmFsdWVzVHJlZS5zaXplKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuaW50ID0gW2xvdywgaGlnaF07XG4gICAgICAvLyBub2RlLnZhbHVlID0gZGF0YTtcbiAgICAgIHZhbHVlQ29udGFpbmVyID0gbm9kZTtcbiAgICB9XG4gICAgaWYgKGhpZ2ggPiAobm9kZS5tYXhIaWdoT2ZNdWx0aSA/PyBOdW1iZXIuTUlOX1ZBTFVFKSkge1xuICAgICAgbm9kZS5tYXhIaWdoT2ZNdWx0aSA9IGhpZ2g7XG4gICAgfVxuICAgIG1haW50YWluTm9kZU1heFZhbHVlKG5vZGUpO1xuICAgIHJldHVybiB2YWx1ZUNvbnRhaW5lcjtcbiAgfVxuXG4gIGRlbGV0ZUludGVydmFsKGxvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zZWFyY2gobG93KTtcbiAgICBpZiAobm9kZSA9PSBudWxsKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChub2RlLmludCAmJiBub2RlLmludFsxXSA9PT0gaGlnaCkge1xuICAgICAgdGhpcy5kZWxldGVOb2RlKG5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChub2RlLmhpZ2hWYWx1ZXNUcmVlKSB7XG4gICAgICBjb25zdCBvcmlnTWF4SGlnaCA9IG5vZGUubWF4SGlnaE9mTXVsdGk7XG4gICAgICBjb25zdCBkZWxldGVkID0gbm9kZS5oaWdoVmFsdWVzVHJlZS5kZWxldGUoaGlnaCk7XG4gICAgICBpZiAoZGVsZXRlZCkge1xuICAgICAgICBub2RlLndlaWdodC0tO1xuICAgICAgICBpZiAobm9kZS5oaWdoVmFsdWVzVHJlZS5zaXplKCkgPT09IDEpIHtcbiAgICAgICAgICBub2RlLmludCA9IFtub2RlLmtleSwgbm9kZS5oaWdoVmFsdWVzVHJlZS5yb290IS5rZXldO1xuICAgICAgICAgIG5vZGUudmFsdWUgPSBub2RlLmhpZ2hWYWx1ZXNUcmVlLnJvb3QhLnZhbHVlO1xuICAgICAgICAgIG5vZGUuaGlnaFZhbHVlc1RyZWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbm9kZS5tYXhIaWdoT2ZNdWx0aSA9IG5vZGUuaW50WzFdO1xuICAgICAgICAgIGlmIChvcmlnTWF4SGlnaCAhPT0gbm9kZS5tYXhIaWdoT2ZNdWx0aSlcbiAgICAgICAgICAgIG1haW50YWluTm9kZU1heFZhbHVlKG5vZGUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUubWF4SGlnaE9mTXVsdGkgPSBub2RlLmhpZ2hWYWx1ZXNUcmVlLm1heGltdW0oKSEua2V5O1xuICAgICAgICAgIGlmIChvcmlnTWF4SGlnaCAhPT0gbm9kZS5tYXhIaWdoT2ZNdWx0aSlcbiAgICAgICAgICAgIG1haW50YWluTm9kZU1heFZhbHVlKG5vZGUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHNlYXJjaFNpbmdsZU92ZXJsYXAobG93OiBudW1iZXIsIGhpZ2g6IG51bWJlcikge1xuICAgIGxldCBub2RlID0gdGhpcy5yb290O1xuICAgIHdoaWxlIChub2RlICYmICFkb2VzSW50ZXJ2YWxPdmVybGFwKFtub2RlLmtleSwgbm9kZS5tYXhIaWdoT2ZNdWx0aSFdLCBbbG93LCBoaWdoXSkpIHtcbiAgICAgIGlmIChub2RlLmxlZnQgJiYgbG93IDw9IG5vZGUubGVmdC5tYXgpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gICpzZWFyY2hNdWx0aXBsZU92ZXJsYXBzKGxvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIpOiBHZW5lcmF0b3I8W2xvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIsIGRhdGE6IFYsIG5vZGU6IEludGVydmFsVHJlZU5vZGU8Vj5dPiB7XG4gICAgY29uc3QgZm91bmROb2RlcyA9IFtdIGFzIEludGVydmFsVHJlZU5vZGU8Vj5bXTtcbiAgICBzZWFyY2hNdWx0aXBsZU92ZXJsYXBzKGZvdW5kTm9kZXMsIGxvdywgaGlnaCwgdGhpcy5yb290KTtcbiAgICAvLyBjb25zdCBpbnRlcnZhbHMgPSBuZXcgQXJyYXk8W251bWJlciwgbnVtYmVyLCBWLCBJbnRlcnZhbFRyZWVOb2RlPFY+XT4oZm91bmROb2Rlcy5sZW5ndGgpO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBmb3VuZE5vZGVzKSB7XG4gICAgICBpZiAobm9kZS5pbnQpIHtcbiAgICAgICAgeWllbGQgWy4uLm5vZGUuaW50LCBub2RlLnZhbHVlLCBub2RlXTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5oaWdoVmFsdWVzVHJlZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGhpZ2hUcmVlTm9kZSBvZiBub2RlLmhpZ2hWYWx1ZXNUcmVlLmtleXNTbWFsbGVyZXJUaGFuKGhpZ2gpKSB7XG4gICAgICAgICAgeWllbGQgW25vZGUua2V5LCBoaWdoVHJlZU5vZGUua2V5LCBoaWdoVHJlZU5vZGUudmFsdWUsIG5vZGVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIEBPdmVycmlkZVxuICAgKi9cbiAgcHJvdGVjdGVkIG9uTGVmdENoaWxkQ2hhbmdlKHBhcmVudDogSW50ZXJ2YWxUcmVlTm9kZTxWPiwgY2hpbGQ6IEludGVydmFsVHJlZU5vZGU8Vj4gfCBudWxsIHwgdW5kZWZpbmVkKSB7XG4gICAgbWFpbnRhaW5Ob2RlTWF4VmFsdWU8Vj4ocGFyZW50KTtcbiAgfVxuICAvKiogQE92ZXJyaWRlXG4gICAqL1xuICBwcm90ZWN0ZWQgb25SaWdodENoaWxkQ2hhbmdlKHBhcmVudDogSW50ZXJ2YWxUcmVlTm9kZTxWPiwgY2hpbGQ6IEludGVydmFsVHJlZU5vZGU8Vj4gfCBudWxsIHwgdW5kZWZpbmVkKSB7XG4gICAgbWFpbnRhaW5Ob2RlTWF4VmFsdWU8Vj4ocGFyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWludGFpbk5vZGVNYXhWYWx1ZTxWPihub2RlOiBQYXJ0aWFsPEludGVydmFsVHJlZU5vZGU8Vj4+KSB7XG4gIGxldCBjdXJyTm9kZTogUGFydGlhbDxJbnRlcnZhbFRyZWVOb2RlPFY+PiB8IG51bGwgfCB1bmRlZmluZWQgPSBub2RlO1xuICB3aGlsZSAoY3Vyck5vZGUpIHtcbiAgICAvLyBpZiAoY3Vyck5vZGUubWF4SGlnaE9mTXVsdGkgPT0gbnVsbClcbiAgICAvLyAgIHRocm93IG5ldyBFcnJvcignY3Vyck5vZGUubWF4SGlnaE9mTXVsdGkgc2hvdWxkIG5vdCBiZSBlbXB0eScpO1xuICAgIGN1cnJOb2RlLm1heCA9IE1hdGgubWF4KGN1cnJOb2RlLm1heEhpZ2hPZk11bHRpID8/IE51bWJlci5NSU5fVkFMVUUsIE1hdGgubWF4KFxuICAgICAgY3Vyck5vZGUubGVmdD8ubWF4ID8/IE51bWJlci5NSU5fVkFMVUUsIGN1cnJOb2RlLnJpZ2h0Py5tYXggPz8gTnVtYmVyLk1JTl9WQUxVRVxuICAgICkpO1xuICAgIGN1cnJOb2RlID0gY3Vyck5vZGUucDtcbiAgfVxufVxuXG5mdW5jdGlvbiBkb2VzSW50ZXJ2YWxPdmVybGFwKGludEE6IFtudW1iZXIsIG51bWJlcl0sIGludEI6IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgLy8gTm90IGluIGNhc2Ugb2Y6IGludEEgaXMgbGVmdCB0byBpbnRCIG9yIGludEEgaXMgcmlnaHQgdG8gaW50QiBlbnRpcmVseVxuICByZXR1cm4gIShpbnRBWzFdIDwgaW50QlswXSB8fCBpbnRCWzFdIDwgaW50QVswXSk7XG59XG5cbmZ1bmN0aW9uIHNlYXJjaE11bHRpcGxlT3ZlcmxhcHM8Vj4oXG4gIG92ZXJsYXBzOiBJbnRlcnZhbFRyZWVOb2RlPFY+W10sIGxvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIsIG5vZGU6IEludGVydmFsVHJlZU5vZGU8Vj4gfCBudWxsIHwgdW5kZWZpbmVkXG4pOiBudW1iZXIge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgbGV0IG51bU92ZXJsYXBzID0gMDtcbiAgaWYgKGRvZXNJbnRlcnZhbE92ZXJsYXAoW25vZGUua2V5LCBub2RlLm1heEhpZ2hPZk11bHRpIV0sIFtsb3csIGhpZ2hdKSkge1xuICAgIG92ZXJsYXBzLnB1c2gobm9kZSk7XG4gICAgbnVtT3ZlcmxhcHMgPSAxO1xuICB9XG4gIGlmIChub2RlLmxlZnQgJiYgbG93IDw9IG5vZGUubGVmdC5tYXgpIHtcbiAgICBjb25zdCBudW1PdmVybGFwc0xlZnQgPSBzZWFyY2hNdWx0aXBsZU92ZXJsYXBzKG92ZXJsYXBzLCBsb3csIGhpZ2gsIG5vZGUubGVmdCk7XG4gICAgaWYgKG51bU92ZXJsYXBzTGVmdCA+IDApIHtcbiAgICAgIG51bU92ZXJsYXBzICs9IG51bU92ZXJsYXBzTGVmdDtcbiAgICAgIG51bU92ZXJsYXBzICs9IHNlYXJjaE11bHRpcGxlT3ZlcmxhcHMob3ZlcmxhcHMsIGxvdywgaGlnaCwgbm9kZS5yaWdodCk7XG4gICAgfVxuICAgIC8vIFNraXAgcmlnaHQgY2hpbGQsIGFzIGlmIHplcm8gbGVmdCBjaGlsZCBvdmVybGFwcywgdGhlblxuICAgIC8vIHRhcmdldCBpbnRlcnZhbCdzIGhpZ2ggdmFsdWUgbXVzdCBiZSBldmVuIHNtYWxsZXIgdGhhbiBhbGwgbGVmdCBjaGlsZHJlbidzIGxvdyB2YWx1ZXMsXG4gICAgLy8gbWVhbmluZyBlbnRpcmUgbGVmdCBjaGlsZCB0cmVlIGlzIGdyZWF0ZXIgdGhhbiB0YXJnZXQgaW50ZXJ2YWwsIHNvIHJpZ2h0IGNoaWxkIHRyZWUgZG9lcyB0aGUgc2FtZVxuICB9IGVsc2Uge1xuICAgIG51bU92ZXJsYXBzICs9IHNlYXJjaE11bHRpcGxlT3ZlcmxhcHMob3ZlcmxhcHMsIGxvdywgaGlnaCwgbm9kZS5yaWdodCk7XG4gIH1cbiAgcmV0dXJuIG51bU92ZXJsYXBzO1xufVxuIl19