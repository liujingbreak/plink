{"version":3,"file":"LLn-parser.js","sourceRoot":"","sources":["../src/LLn-parser.ts"],"names":[],"mappings":"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","sourcesContent":["import util from 'util';\n\n/**\n * T - Token Types\n * AST - type of returned AST object\n */\nexport function createStringParser<T, AST>(parserName: string, lexer: Lexer<string, T, Token<T>>,\n  grammar: Grammar<Token<T>, AST>) {\n\n  return function(input: string) {\n    const p = parser(parserName, lexer, grammar);\n    p.write(input);\n    p.end();\n    return p.getResult();\n  };\n}\n\n/**\n * Help for testing result of lexer function\n * @param lexer \n */\nexport function listTokens<T>(debugName: string, input: string, lexer: Lexer<string, T>): Token<T>[] {\n  const lexerLa = new LookAhead<string, T>(debugName, () => {\n    lexerLa._write(input);\n    lexerLa._final();\n  });\n\n  const tokens = [] as Token<T>[];\n  lexer(lexerLa, {\n    emit() {\n      if (lexerLa.currChunk == null)\n        return;\n      const token = strChunk2Token(lexerLa.currChunk);\n      token.close(lexerLa.position);\n      tokens.push(token);\n    },\n    end() {}\n  });\n\n  return tokens;\n}\nexport class Chunk<V, T> {\n  type: T | undefined;\n  values?: V[] = [];\n  end!: number;\n  isClosed = false;\n  trackValue = true;\n\n  constructor(\n    public pos: number, public line: number, public col: number\n  ) {}\n\n  close(position: number) {\n    this.isClosed = true;\n    this.end = position;\n    return this;\n  }\n}\n\nexport class Token<T> extends Chunk<string, T> {\n  text!: string;\n}\n\n/**\n *  V is type of each `character`, e.g. string, number\n *  T is Token Type, e.g. string or a enum\n *  C could be omit\n */\nexport type Lexer<V, T, C extends Chunk<V, T> = Chunk<V, T>> =\n  (la: LookAhead<V, T>, emitter: TokenEmitter<V, T, C>) => void;\nexport type Grammar<C, A> = (tokenLa: LookAhead<C, string>) => A;\n\ninterface TokenEmitter<V, T, C> {\n  emit(): void;\n  end(): void;\n}\n\nexport function parser<V, T, C extends Chunk<V, T>, A>(parserName: string,\n  lexer: Lexer<V, T, C>,\n  grammar: Grammar<C, A>,\n  chunkConverter?: (chunk: Chunk<V, T>) => C):\n  {\n    write: LookAhead<V, T>['_write'];\n    end: LookAhead<V, T>['_final'];\n    getResult: () => A;\n  } {\n\n  let isString: boolean;\n  const lexerLa = new LookAhead<V, T>(parserName + ' lexer');\n  const tokenEmitter: TokenEmitter<V, T, C> = {\n    emit() {\n      if (lexerLa.currChunk == null)\n        return;\n      if (isString === undefined && lexerLa.currChunk.values != null)\n        isString = typeof lexerLa.currChunk.values[0] === 'string';\n      const token: C = chunkConverter ? chunkConverter(lexerLa.currChunk) :\n        (isString ?\n          strChunk2Token(lexerLa.currChunk as unknown as Chunk<string, T>) as unknown as C :\n          lexerLa.currChunk as C);\n      tokenLa._write([token]);\n      token.close(lexerLa.position);\n    },\n    end() {\n      tokenLa._final();\n    }\n  };\n  const tokenLa = new LookAhead<C, string>(parserName + ' grammar', function() {\n    lexer(lexerLa, tokenEmitter);\n  });\n  return {\n    write: lexerLa._write.bind(lexerLa) ,\n    end: lexerLa._final.bind(lexerLa) ,\n    getResult() {\n      return grammar(tokenLa);\n    }\n  };\n}\n\n\nexport class LookAhead<V, T> {\n  static WAIT_ERROR: 'WAIT_ERROR';\n  cached: Array<V | null>;\n  line = 1;\n  column = 1;\n  lastConsumed: V | undefined;\n  currChunk: Chunk<V, T> | undefined;\n\n  private currPos = 0;\n  private cacheStartPos = 0;\n\n  constructor(protected name: string, private onDrain?: (this: LookAhead<V, T>) => void) {\n    this.cached = [];\n  }\n\n  _write(values: Iterable<V | null>) {\n    for (const v of values)\n      this.cached.push(v);\n  }\n\n  _final() {\n    this._write([null]);\n  }\n\n  get position(): number {\n    return this.currPos;\n  }\n\n  /**\n\t * look ahead for 1 character\n\t * @param num default is 1\n\t * @return null if EOF is reached\n\t */\n  la(num = 1): V | null {\n    const readPos = this.currPos + num - 1;\n    return this.read(readPos);\n  }\n\n  advance(count = 1): V {\n    // return new Promise(resolve => {\n    let currValue: V;\n    let i = 0;\n    while (i++ < count) {\n      const value = this.la(1);\n      if (value == null) {\n        this.throwError('Unexpect EOF'); // , stack);\n        break;\n      }\n      this.currPos++;\n      this.column++;\n      if ((value as any) === '\\n') {\n        this.line++;\n        this.column = 1;\n      }\n      if (this.currPos - this.cacheStartPos > 0x100000) {\n        this.cached.splice(0, 0x100000);\n        this.cacheStartPos += 0x100000;\n      }\n      if (this.currChunk && !this.currChunk.isClosed && this.currChunk.trackValue) {\n        this.currChunk.values!.push(value);\n      }\n      currValue = value;\n    }\n    this.lastConsumed = currValue!;\n    return currValue!;\n  }\n\n  isNext(...values: V[]) {\n    return this.isNextWith(values);\n  }\n  /**\n\t * Same as `return la(1) === values[0] && la(2) === values[1]...`\n\t * @param values lookahead string or tokens\n\t */\n  isNextWith<C>(values: C[], isEqual = (a: V, b: C) => a as any === b): boolean {\n    let compareTo: C[] | string;\n    let compareFn: (...arg: any[]) => boolean;\n    compareTo = values;\n    compareFn = isEqual;\n    let i = 0;\n    const l = compareTo.length;\n    while (true) {\n      if (i === l)\n        return true;\n      const next = this.la(i + 1);\n      if (next == null)\n        return false; // EOF\n      else if (!compareFn(next, compareTo[i]))\n        return false;\n      i++;\n    }\n  }\n\n  assertAdvance(...values: V[]) {\n    return this.assertAdvanceWith(values);\n  }\n\n  assertAdvanceWith<C>(values: C[], isEqual = (a: V, b: C) => a as any === b) {\n    let compareTo: C[] | string;\n    let compareFn: (...arg: any[]) => boolean;\n    compareTo = values;\n    compareFn = isEqual;\n    let i = 0;\n    const l = compareTo.length;\n    while (true) {\n      if (i === l)\n        return true;\n      const next = this.advance(i + 1);\n      if (next == null)\n        this.throwError('EOF', new Error().stack); // EOF\n      else if (!compareFn(next, compareTo[i]))\n        this.throwError(util.inspect(next), new Error().stack, compareTo[i] + '');\n      i++;\n    }\n  }\n\n  throwError(unexpected = 'End-of-stream', stack?: any, expect?: string) {\n    // eslint-disable-next-line max-len\n    throw new Error(`In ${this.name} unexpected ${JSON.stringify(unexpected)}` +\n    (expect ? `(expecting \"${expect}\")` : '') +\n    `at ${this.getCurrentPosInfo()}, ${stack ? 'previous stack:' + stack : ''}`);\n  }\n\n  getCurrentPosInfo(): string {\n    return `offset ${this.currPos} [${this.line}:${this.column}]`;\n  }\n\n  startChunk(type: T, trackValue = true) {\n    if (this.currChunk && !this.currChunk.isClosed)\n      this.currChunk.close(this.currPos);\n    this.currChunk = new Chunk<V, T>(this.currPos, this.line, this.column);\n    this.currChunk.trackValue = trackValue;\n    this.currChunk.type = type;\n    return this.currChunk;\n  }\n\n  protected closeChunk() {\n    return this.currChunk!.close(this.currPos);\n  }\n\n  /**\n\t * Do not read postion less than 0\n\t * @param pos \n\t */\n  private read(pos: number): V | null {\n    const cacheOffset = pos - this.cacheStartPos;\n    if (cacheOffset < 0) {\n      throw new Error(`Can not read behind stream cache, at position: ${pos}`);\n    }\n    while (true) {\n      if (cacheOffset < this.cached.length) {\n        return this.cached[cacheOffset];\n      } else {\n        if (this.onDrain) {\n          this.onDrain();\n          continue;\n        }\n        throw new Error(`The internal buffer is drained early at ${pos}`);\n        // this.waitForPos = pos;\n        // const err = new WaitError();\n        // throw err;\n        // return new Promise(resolve => {\n        //   this.readResolve = resolve;\n        // });\n      }\n    }\n  }\n}\n\nfunction strChunk2Token<T>(chunk: Chunk<string, T>) {\n  if (chunk.values) {\n    (chunk as Token<T>).text = chunk.values.join('');\n    delete chunk.values;\n  }\n  return chunk as Token<T>;\n}\n\n/**\n * Convenient function for creating a text based parser,\n * you only need to define Token types, lexer function, grammar function\n */\nexport function createTextParser() {\n\n}\n"]}