{"version":3,"file":"base-LLn-parser.js","sourceRoot":"","sources":["../src/base-LLn-parser.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-return */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/**\n * @deprecated use LLn-parser instead\n */\nimport sortedIndex from 'lodash/sortedIndex';\n\nexport class Token<T> {\n  text: string;\n  end: number;\n  lineColumn: [number, number];\n\n  constructor(public type: T, lexer: BaseLexer<T>,\n    public start: number) {\n    this.text = lexer.getText(start);\n    this.end = lexer.position;\n    this.lineColumn = lexer.getLineColumn(start);\n  }\n}\n\nexport abstract class LookAhead<T> {\n  cached: T[];\n  // channels: {[channel: string]: T[]} = {};\n  // channelPos: {[channel: string]: number} = {};\n  sourceIterator: Iterator<T>;\n  isString: boolean;\n  protected currPos = -1;\n\n  constructor(source: Iterable<T>) {\n    this.isString = typeof source === 'string';\n    this.cached = [];\n    this.sourceIterator = source[Symbol.iterator]();\n  }\n\n  get position(): number {\n    return this.currPos + 1;\n  }\n\n  /**\n\t * look ahead for 1 character\n\t * @param num default is 1\n\t * @return null if EOF is reached\n\t */\n  la(num = 1): T | null {\n    const readPos = this.currPos + num;\n    return this.read(readPos);\n  }\n\n  lb(num = 1): T | null {\n    const pos = this.currPos - (num - 1);\n    if (pos < 0)\n      return null;\n    return this.read(pos);\n  }\n\n  advance(count = 1): T | null {\n    let current = null;\n    for (let i = 0; i < count; i++) {\n      current = this.la(1);\n      if (current == null)\n        this.throwError();\n      this.currPos++;\n    }\n    return current;\n  }\n\n  /**\n\t * Same as `return la(1) === values[0] && la(2) === values[1]...`\n\t * @param values lookahead string or tokens\n\t */\n  isNext(...values: T[]): boolean {\n    return this._isNext<T>(values);\n  }\n\n  _isNext<C>(values: C[], isEqual = (a: T, b: C) => a as any === b): boolean {\n    let compareTo: C[]| string;\n    let compareFn: (...arg: any[]) => boolean;\n    if (this.isString) {\n      compareTo = values.join('');\n      compareFn = (a: string, b: string) => a === b;\n    } else {\n      compareTo = values;\n      compareFn = isEqual;\n    }\n    let i = 0;\n    const l = compareTo.length;\n    let next = this.la(i + 1);\n    while (true) {\n      if (i === l)\n        return true;\n      next = this.la(i + 1);\n      if (next == null)\n        return false; // EOF\n      else if (!compareFn(next, compareTo[i]))\n        return false;\n      i++;\n    }\n  }\n\n  throwError(unexpected = 'End-of-file') {\n    throw new Error(`Unexpected ${JSON.stringify(unexpected)} at ` + this.getCurrentPosInfo());\n  }\n\n  abstract getCurrentPosInfo(): string;\n\n  /**\n\t * Do not read postion less than 0\n\t * @param pos \n\t */\n  protected read(pos: number): T | null {\n    const cached = this.cached;\n    while (cached.length <= pos) {\n      const next = this.sourceIterator.next();\n      if (next.done)\n        return null;\n      cached.push(next.value);\n    }\n    return cached[pos];\n  }\n}\n\n/**\n * 1. Define a \"TokenType\" enum\n * 2. Implement your own \"Lexer\" which extends \"BaseLexer\" with type paremeter of your enum \"TokenType\"\n * 3. Implement `[Symbol.interator]()` function in your Lexer:\n```ts\n\t*[Symbol.iterator](): Iterator<Token<TokenType>> {\n\t\twhile (this.la() != null) {\n\t\t\tconst start = this.position;\n\t\t\tif (this.la() === '\\n') {\n\t\t\t\tthis.advance();\n\t\t\t\tyield new Token(TokenType.EOL, this, start);\n\t\t\t}\n\t\t\t...\n\t\t}\n\t}\n```\n */\nexport abstract class BaseLexer<T> extends LookAhead<string> implements Iterable<Token<T>> {\n  lineBeginPositions: number[] = [-1];\n\n  constructor(protected source: string) {\n    super(source);\n    const originNext = this.sourceIterator.next;\n    const it = this.sourceIterator;\n    // - Monkey patch iterator's next() method to track beginning position of each line\n    let nextCount = 0;\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    this.sourceIterator.next = function() {\n      const nextRes = originNext.call(it);\n      const chr = nextRes.value;\n      if (!nextRes.done && chr === '\\n')\n        self.lineBeginPositions.push(nextCount);\n      nextCount++;\n      return nextRes;\n    };\n  }\n\n  abstract [Symbol.iterator](): Iterator<Token<T>>;\n\n  getText(startPos: number) {\n    return this.source.slice(startPos, this.position);\n  }\n\n  getCurrentPosInfo(): string {\n    const [line, col] = this.getLineColumn(this.currPos);\n    // eslint-disable-next-line max-len\n    return `get ${JSON.stringify(this.la())}, at line ${line + 1}, column ${col + 1}, after ${JSON.stringify(this.lb())}`;\n  }\n\n  /**\n\t * @return zero-based [line, column] value\n\t * */\n  getLineColumn(pos: number): [number, number] {\n    const lineIndex = sortedIndex(this.lineBeginPositions, pos) - 1;\n    const linePos = this.lineBeginPositions[lineIndex];\n    return [lineIndex, pos - (linePos + 1)];\n  }\n}\n\nexport class TokenFilter<T> extends LookAhead<Token<T>> implements Iterable<Token<T>> {\n  constructor(lexer: Iterable<Token<T>>, public skipType: T) {\n    super(lexer);\n  }\n\n  *[Symbol.iterator](): Iterator<Token<T>> {\n    while (this.la() != null) {\n      if (this.la()!.type === this.skipType) {\n        this.advance();\n      } else {\n        yield this.la()!;\n        this.advance();\n      }\n    }\n  }\n\n  getCurrentPosInfo(): string {\n    const start = this.la();\n    if (start == null)\n      return 'EOF';\n    return `line ${start.lineColumn[0] + 1} column ${start.lineColumn[1] + 1}`;\n  }\n}\n/**\n * TT - token type\n */\nexport abstract class BaseParser<T> extends LookAhead<Token<T>> {\n  constructor(protected lexer: Iterable<Token<T>>) {\n    super(lexer);\n  }\n\n  getCurrentPosInfo(): string {\n    const start = this.la();\n    if (start == null)\n      return 'EOF';\n    return `line ${start.lineColumn[0] + 1} column ${start.lineColumn[1] + 1}`;\n  }\n\n  isNextTypes(...types: T[]): boolean {\n    const comparator = (a: Token<T>, b: T) => {\n      if (a == null)\n        return false;\n      return a.type === b;\n    };\n    return this._isNext<T>(types, comparator);\n  }\n\n  isNextTokenText(...text: string[]): boolean {\n    const comparator = (a: Token<T>, b: string) => {\n      if (a == null)\n        return false;\n      return a.text === b;\n    };\n    return this._isNext<string>(text, comparator);\n  }\n}\n"]}