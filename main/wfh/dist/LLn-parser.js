"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTextParser = exports.LookAhead = exports.parser = exports.Token = exports.Chunk = exports.listTokens = exports.createStringParser = void 0;
const util_1 = __importDefault(require("util"));
/**
 * T - Token Types
 * AST - type of returned AST object
 */
function createStringParser(parserName, lexer, grammar) {
    return function (input) {
        const p = parser(parserName, lexer, grammar);
        p.write(input);
        p.end();
        return p.getResult();
    };
}
exports.createStringParser = createStringParser;
/**
 * Help for testing result of lexer function
 * @param lexer
 */
function listTokens(debugName, input, lexer) {
    const lexerLa = new LookAhead(debugName, () => {
        lexerLa._write(input);
        lexerLa._final();
    });
    const tokens = [];
    lexer(lexerLa, {
        emit() {
            if (lexerLa.currChunk == null)
                return;
            const token = strChunk2Token(lexerLa.currChunk);
            token.close(lexerLa.position);
            tokens.push(token);
        },
        end() { }
    });
    return tokens;
}
exports.listTokens = listTokens;
class Chunk {
    constructor(pos, line, col) {
        this.pos = pos;
        this.line = line;
        this.col = col;
        this.values = [];
        this.isClosed = false;
        this.trackValue = true;
    }
    close(position) {
        this.isClosed = true;
        this.end = position;
        return this;
    }
}
exports.Chunk = Chunk;
class Token extends Chunk {
}
exports.Token = Token;
function parser(parserName, lexer, grammar, chunkConverter) {
    let isString;
    const lexerLa = new LookAhead(parserName + ' lexer');
    const tokenEmitter = {
        emit() {
            if (lexerLa.currChunk == null)
                return;
            if (isString === undefined && lexerLa.currChunk.values != null)
                isString = typeof lexerLa.currChunk.values[0] === 'string';
            const token = chunkConverter ? chunkConverter(lexerLa.currChunk) :
                (isString ?
                    strChunk2Token(lexerLa.currChunk) :
                    lexerLa.currChunk);
            tokenLa._write([token]);
            token.close(lexerLa.position);
        },
        end() {
            tokenLa._final();
        }
    };
    const tokenLa = new LookAhead(parserName + ' grammar', function () {
        lexer(lexerLa, tokenEmitter);
    });
    return {
        write: lexerLa._write.bind(lexerLa),
        end: lexerLa._final.bind(lexerLa),
        getResult() {
            return grammar(tokenLa);
        }
    };
}
exports.parser = parser;
class LookAhead {
    constructor(name, onDrain) {
        this.name = name;
        this.onDrain = onDrain;
        this.line = 1;
        this.column = 1;
        this.currPos = 0;
        this.cacheStartPos = 0;
        this.cached = [];
    }
    _write(values) {
        for (const v of values)
            this.cached.push(v);
    }
    _final() {
        this._write([null]);
    }
    get position() {
        return this.currPos;
    }
    /**
       * look ahead for 1 character
       * @param num default is 1
       * @return null if EOF is reached
       */
    la(num = 1) {
        const readPos = this.currPos + num - 1;
        return this.read(readPos);
    }
    advance(count = 1) {
        // return new Promise(resolve => {
        let currValue;
        let i = 0;
        while (i++ < count) {
            const value = this.la(1);
            if (value == null) {
                this.throwError('Unexpect EOF'); // , stack);
                break;
            }
            this.currPos++;
            this.column++;
            if (value === '\n') {
                this.line++;
                this.column = 1;
            }
            if (this.currPos - this.cacheStartPos > 0x100000) {
                this.cached.splice(0, 0x100000);
                this.cacheStartPos += 0x100000;
            }
            if (this.currChunk && !this.currChunk.isClosed && this.currChunk.trackValue) {
                this.currChunk.values.push(value);
            }
            currValue = value;
        }
        this.lastConsumed = currValue;
        return currValue;
    }
    isNext(...values) {
        return this.isNextWith(values);
    }
    /**
       * Same as `return la(1) === values[0] && la(2) === values[1]...`
       * @param values lookahead string or tokens
       */
    isNextWith(values, isEqual = (a, b) => a === b) {
        let compareTo;
        let compareFn;
        compareTo = values;
        compareFn = isEqual;
        let i = 0;
        const l = compareTo.length;
        while (true) {
            if (i === l)
                return true;
            const next = this.la(i + 1);
            if (next == null)
                return false; // EOF
            else if (!compareFn(next, compareTo[i]))
                return false;
            i++;
        }
    }
    assertAdvance(...values) {
        return this.assertAdvanceWith(values);
    }
    assertAdvanceWith(values, isEqual = (a, b) => a === b) {
        let compareTo;
        let compareFn;
        compareTo = values;
        compareFn = isEqual;
        let i = 0;
        const l = compareTo.length;
        while (true) {
            if (i === l)
                return true;
            const next = this.advance(i + 1);
            if (next == null)
                this.throwError('EOF', new Error().stack); // EOF
            else if (!compareFn(next, compareTo[i]))
                this.throwError(util_1.default.inspect(next), new Error().stack, compareTo[i] + '');
            i++;
        }
    }
    throwError(unexpected = 'End-of-stream', stack, expect) {
        // eslint-disable-next-line max-len
        throw new Error(`In ${this.name} unexpected ${JSON.stringify(unexpected)}` +
            (expect ? `(expecting "${expect}")` : '') +
            `at ${this.getCurrentPosInfo()}, ${stack ? 'previous stack:' + stack : ''}`);
    }
    getCurrentPosInfo() {
        return `offset ${this.currPos} [${this.line}:${this.column}]`;
    }
    startChunk(type, trackValue = true) {
        if (this.currChunk && !this.currChunk.isClosed)
            this.currChunk.close(this.currPos);
        this.currChunk = new Chunk(this.currPos, this.line, this.column);
        this.currChunk.trackValue = trackValue;
        this.currChunk.type = type;
        return this.currChunk;
    }
    closeChunk() {
        return this.currChunk.close(this.currPos);
    }
    /**
       * Do not read postion less than 0
       * @param pos
       */
    read(pos) {
        const cacheOffset = pos - this.cacheStartPos;
        if (cacheOffset < 0) {
            throw new Error(`Can not read behind stream cache, at position: ${pos}`);
        }
        while (true) {
            if (cacheOffset < this.cached.length) {
                return this.cached[cacheOffset];
            }
            else {
                if (this.onDrain) {
                    this.onDrain();
                    continue;
                }
                throw new Error(`The internal buffer is drained early at ${pos}`);
                // this.waitForPos = pos;
                // const err = new WaitError();
                // throw err;
                // return new Promise(resolve => {
                //   this.readResolve = resolve;
                // });
            }
        }
    }
}
exports.LookAhead = LookAhead;
function strChunk2Token(chunk) {
    if (chunk.values) {
        chunk.text = chunk.values.join('');
        delete chunk.values;
    }
    return chunk;
}
/**
 * Convenient function for creating a text based parser,
 * you only need to define Token types, lexer function, grammar function
 */
function createTextParser() {
}
exports.createTextParser = createTextParser;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTExuLXBhcnNlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3RzL0xMbi1wYXJzZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsZ0RBQXdCO0FBRXhCOzs7R0FHRztBQUNILFNBQWdCLGtCQUFrQixDQUFTLFVBQWtCLEVBQUUsS0FBaUMsRUFDOUYsT0FBK0I7SUFFL0IsT0FBTyxVQUFTLEtBQWE7UUFDM0IsTUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFDLFVBQVUsRUFBRSxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDN0MsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNmLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNSLE9BQU8sQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDO0lBQ3ZCLENBQUMsQ0FBQztBQUNKLENBQUM7QUFURCxnREFTQztBQUVEOzs7R0FHRztBQUNILFNBQWdCLFVBQVUsQ0FBSSxTQUFpQixFQUFFLEtBQWEsRUFBRSxLQUF1QjtJQUNyRixNQUFNLE9BQU8sR0FBRyxJQUFJLFNBQVMsQ0FBWSxTQUFTLEVBQUUsR0FBRyxFQUFFO1FBQ3ZELE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDdEIsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQ25CLENBQUMsQ0FBQyxDQUFDO0lBRUgsTUFBTSxNQUFNLEdBQUcsRUFBZ0IsQ0FBQztJQUNoQyxLQUFLLENBQUMsT0FBTyxFQUFFO1FBQ2IsSUFBSTtZQUNGLElBQUksT0FBTyxDQUFDLFNBQVMsSUFBSSxJQUFJO2dCQUMzQixPQUFPO1lBQ1QsTUFBTSxLQUFLLEdBQUcsY0FBYyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUNoRCxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUM5QixNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3JCLENB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ICogVCAtIFRva2VuIFR5cGVzXG4gKiBBU1QgLSB0eXBlIG9mIHJldHVybmVkIEFTVCBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0cmluZ1BhcnNlcjxULCBBU1Q+KHBhcnNlck5hbWU6IHN0cmluZywgbGV4ZXI6IExleGVyPHN0cmluZywgVCwgVG9rZW48VD4+LFxuICBncmFtbWFyOiBHcmFtbWFyPFRva2VuPFQ+LCBBU1Q+KSB7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGlucHV0OiBzdHJpbmcpIHtcbiAgICBjb25zdCBwID0gcGFyc2VyKHBhcnNlck5hbWUsIGxleGVyLCBncmFtbWFyKTtcbiAgICBwLndyaXRlKGlucHV0KTtcbiAgICBwLmVuZCgpO1xuICAgIHJldHVybiBwLmdldFJlc3VsdCgpO1xuICB9O1xufVxuXG4vKipcbiAqIEhlbHAgZm9yIHRlc3RpbmcgcmVzdWx0IG9mIGxleGVyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbGV4ZXIgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0VG9rZW5zPFQ+KGRlYnVnTmFtZTogc3RyaW5nLCBpbnB1dDogc3RyaW5nLCBsZXhlcjogTGV4ZXI8c3RyaW5nLCBUPik6IFRva2VuPFQ+W10ge1xuICBjb25zdCBsZXhlckxhID0gbmV3IExvb2tBaGVhZDxzdHJpbmcsIFQ+KGRlYnVnTmFtZSwgKCkgPT4ge1xuICAgIGxleGVyTGEuX3dyaXRlKGlucHV0KTtcbiAgICBsZXhlckxhLl9maW5hbCgpO1xuICB9KTtcblxuICBjb25zdCB0b2tlbnMgPSBbXSBhcyBUb2tlbjxUPltdO1xuICBsZXhlcihsZXhlckxhLCB7XG4gICAgZW1pdCgpIHtcbiAgICAgIGlmIChsZXhlckxhLmN1cnJDaHVuayA9PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB0b2tlbiA9IHN0ckNodW5rMlRva2VuKGxleGVyTGEuY3VyckNodW5rKTtcbiAgICAgIHRva2VuLmNsb3NlKGxleGVyTGEucG9zaXRpb24pO1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgIH0sXG4gICAgZW5kKCkge31cbiAgfSk7XG5cbiAgcmV0dXJuIHRva2Vucztcbn1cbmV4cG9ydCBjbGFzcyBDaHVuazxWLCBUPiB7XG4gIHR5cGU6IFQgfCB1bmRlZmluZWQ7XG4gIHZhbHVlcz86IFZbXSA9IFtdO1xuICBlbmQhOiBudW1iZXI7XG4gIGlzQ2xvc2VkID0gZmFsc2U7XG4gIHRyYWNrVmFsdWUgPSB0cnVlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBwb3M6IG51bWJlciwgcHVibGljIGxpbmU6IG51bWJlciwgcHVibGljIGNvbDogbnVtYmVyXG4gICkge31cblxuICBjbG9zZShwb3NpdGlvbjogbnVtYmVyKSB7XG4gICAgdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG4gICAgdGhpcy5lbmQgPSBwb3NpdGlvbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVG9rZW48VD4gZXh0ZW5kcyBDaHVuazxzdHJpbmcsIFQ+IHtcbiAgdGV4dCE6IHN0cmluZztcbn1cblxuLyoqXG4gKiAgViBpcyB0eXBlIG9mIGVhY2ggYGNoYXJhY3RlcmAsIGUuZy4gc3RyaW5nLCBudW1iZXJcbiAqICBUIGlzIFRva2VuIFR5cGUsIGUuZy4gc3RyaW5nIG9yIGEgZW51bVxuICogIEMgY291bGQgYmUgb21pdFxuICovXG5leHBvcnQgdHlwZSBMZXhlcjxWLCBULCBDIGV4dGVuZHMgQ2h1bms8ViwgVD4gPSBDaHVuazxWLCBUPj4gPVxuICAobGE6IExvb2tBaGVhZDxWLCBUPiwgZW1pdHRlcjogVG9rZW5FbWl0dGVyPFYsIFQsIEM+KSA9PiB2b2lkO1xuZXhwb3J0IHR5cGUgR3JhbW1hcjxDLCBBPiA9ICh0b2tlbkxhOiBMb29rQWhlYWQ8Qywgc3RyaW5nPikgPT4gQTtcblxuaW50ZXJmYWNlIFRva2VuRW1pdHRlcjxWLCBULCBDPiB7XG4gIGVtaXQoKTogdm9pZDtcbiAgZW5kKCk6IHZvaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZXI8ViwgVCwgQyBleHRlbmRzIENodW5rPFYsIFQ+LCBBPihwYXJzZXJOYW1lOiBzdHJpbmcsXG4gIGxleGVyOiBMZXhlcjxWLCBULCBDPixcbiAgZ3JhbW1hcjogR3JhbW1hcjxDLCBBPixcbiAgY2h1bmtDb252ZXJ0ZXI/OiAoY2h1bms6IENodW5rPFYsIFQ+KSA9PiBDKTpcbiAge1xuICAgIHdyaXRlOiBMb29rQWhlYWQ8ViwgVD5bJ193cml0ZSddO1xuICAgIGVuZDogTG9va0FoZWFkPFYsIFQ+WydfZmluYWwnXTtcbiAgICBnZXRSZXN1bHQ6ICgpID0+IEE7XG4gIH0ge1xuXG4gIGxldCBpc1N0cmluZzogYm9vbGVhbjtcbiAgY29uc3QgbGV4ZXJMYSA9IG5ldyBMb29rQWhlYWQ8ViwgVD4ocGFyc2VyTmFtZSArICcgbGV4ZXInKTtcbiAgY29uc3QgdG9rZW5FbWl0dGVyOiBUb2tlbkVtaXR0ZXI8ViwgVCwgQz4gPSB7XG4gICAgZW1pdCgpIHtcbiAgICAgIGlmIChsZXhlckxhLmN1cnJDaHVuayA9PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoaXNTdHJpbmcgPT09IHVuZGVmaW5lZCAmJiBsZXhlckxhLmN1cnJDaHVuay52YWx1ZXMgIT0gbnVsbClcbiAgICAgICAgaXNTdHJpbmcgPSB0eXBlb2YgbGV4ZXJMYS5jdXJyQ2h1bmsudmFsdWVzWzBdID09PSAnc3RyaW5nJztcbiAgICAgIGNvbnN0IHRva2VuOiBDID0gY2h1bmtDb252ZXJ0ZXIgPyBjaHVua0NvbnZlcnRlcihsZXhlckxhLmN1cnJDaHVuaykgOlxuICAgICAgICAoaXNTdHJpbmcgP1xuICAgICAgICAgIHN0ckNodW5rMlRva2VuKGxleGVyTGEuY3VyckNodW5rIGFzIHVua25vd24gYXMgQ2h1bms8c3RyaW5nLCBUPikgYXMgdW5rbm93biBhcyBDIDpcbiAgICAgICAgICBsZXhlckxhLmN1cnJDaHVuayBhcyBDKTtcbiAgICAgIHRva2VuTGEuX3dyaXRlKFt0b2tlbl0pO1xuICAgICAgdG9rZW4uY2xvc2UobGV4ZXJMYS5wb3NpdGlvbik7XG4gICAgfSxcbiAgICBlbmQoKSB7XG4gICAgICB0b2tlbkxhLl9maW5hbCgpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdG9rZW5MYSA9IG5ldyBMb29rQWhlYWQ8Qywgc3RyaW5nPihwYXJzZXJOYW1lICsgJyBncmFtbWFyJywgZnVuY3Rpb24oKSB7XG4gICAgbGV4ZXIobGV4ZXJMYSwgdG9rZW5FbWl0dGVyKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgd3JpdGU6IGxleGVyTGEuX3dyaXRlLmJpbmQobGV4ZXJMYSkgLFxuICAgIGVuZDogbGV4ZXJMYS5fZmluYWwuYmluZChsZXhlckxhKSAsXG4gICAgZ2V0UmVzdWx0KCkge1xuICAgICAgcmV0dXJuIGdyYW1tYXIodG9rZW5MYSk7XG4gICAgfVxuICB9O1xufVxuXG5cbmV4cG9ydCBjbGFzcyBMb29rQWhlYWQ8ViwgVD4ge1xuICBzdGF0aWMgV0FJVF9FUlJPUjogJ1dBSVRfRVJST1InO1xuICBjYWNoZWQ6IEFycmF5PFYgfCBudWxsPjtcbiAgbGluZSA9IDE7XG4gIGNvbHVtbiA9IDE7XG4gIGxhc3RDb25zdW1lZDogViB8IHVuZGVmaW5lZDtcbiAgY3VyckNodW5rOiBDaHVuazxWLCBUPiB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIGN1cnJQb3MgPSAwO1xuICBwcml2YXRlIGNhY2hlU3RhcnRQb3MgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBuYW1lOiBzdHJpbmcsIHByaXZhdGUgb25EcmFpbj86ICh0aGlzOiBMb29rQWhlYWQ8ViwgVD4pID0+IHZvaWQpIHtcbiAgICB0aGlzLmNhY2hlZCA9IFtdO1xuICB9XG5cbiAgX3dyaXRlKHZhbHVlczogSXRlcmFibGU8ViB8IG51bGw+KSB7XG4gICAgZm9yIChjb25zdCB2IG9mIHZhbHVlcylcbiAgICAgIHRoaXMuY2FjaGVkLnB1c2godik7XG4gIH1cblxuICBfZmluYWwoKSB7XG4gICAgdGhpcy5fd3JpdGUoW251bGxdKTtcbiAgfVxuXG4gIGdldCBwb3NpdGlvbigpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmN1cnJQb3M7XG4gIH1cblxuICAvKipcblx0ICogbG9vayBhaGVhZCBmb3IgMSBjaGFyYWN0ZXJcblx0ICogQHBhcmFtIG51bSBkZWZhdWx0IGlzIDFcblx0ICogQHJldHVybiBudWxsIGlmIEVPRiBpcyByZWFjaGVkXG5cdCAqL1xuICBsYShudW0gPSAxKTogViB8IG51bGwge1xuICAgIGNvbnN0IHJlYWRQb3MgPSB0aGlzLmN1cnJQb3MgKyBudW0gLSAxO1xuICAgIHJldHVybiB0aGlzLnJlYWQocmVhZFBvcyk7XG4gIH1cblxuICBhZHZhbmNlKGNvdW50ID0gMSk6IFYge1xuICAgIC8vIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBsZXQgY3VyclZhbHVlOiBWO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSsrIDwgY291bnQpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5sYSgxKTtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMudGhyb3dFcnJvcignVW5leHBlY3QgRU9GJyk7IC8vICwgc3RhY2spO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRoaXMuY3VyclBvcysrO1xuICAgICAgdGhpcy5jb2x1bW4rKztcbiAgICAgIGlmICgodmFsdWUgYXMgYW55KSA9PT0gJ1xcbicpIHtcbiAgICAgICAgdGhpcy5saW5lKys7XG4gICAgICAgIHRoaXMuY29sdW1uID0gMTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmN1cnJQb3MgLSB0aGlzLmNhY2hlU3RhcnRQb3MgPiAweDEwMDAwMCkge1xuICAgICAgICB0aGlzLmNhY2hlZC5zcGxpY2UoMCwgMHgxMDAwMDApO1xuICAgICAgICB0aGlzLmNhY2hlU3RhcnRQb3MgKz0gMHgxMDAwMDA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jdXJyQ2h1bmsgJiYgIXRoaXMuY3VyckNodW5rLmlzQ2xvc2VkICYmIHRoaXMuY3VyckNodW5rLnRyYWNrVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jdXJyQ2h1bmsudmFsdWVzIS5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGN1cnJWYWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICB0aGlzLmxhc3RDb25zdW1lZCA9IGN1cnJWYWx1ZSE7XG4gICAgcmV0dXJuIGN1cnJWYWx1ZSE7XG4gIH1cblxuICBpc05leHQoLi4udmFsdWVzOiBWW10pIHtcbiAgICByZXR1cm4gdGhpcy5pc05leHRXaXRoKHZhbHVlcyk7XG4gIH1cbiAgLyoqXG5cdCAqIFNhbWUgYXMgYHJldHVybiBsYSgxKSA9PT0gdmFsdWVzWzBdICYmIGxhKDIpID09PSB2YWx1ZXNbMV0uLi5gXG5cdCAqIEBwYXJhbSB2YWx1ZXMgbG9va2FoZWFkIHN0cmluZyBvciB0b2tlbnNcblx0ICovXG4gIGlzTmV4dFdpdGg8Qz4odmFsdWVzOiBDW10sIGlzRXF1YWwgPSAoYTogViwgYjogQykgPT4gYSBhcyBhbnkgPT09IGIpOiBib29sZWFuIHtcbiAgICBsZXQgY29tcGFyZVRvOiBDW10gfCBzdHJpbmc7XG4gICAgbGV0IGNvbXBhcmVGbjogKC4uLmFyZzogYW55W10pID0+IGJvb2xlYW47XG4gICAgY29tcGFyZVRvID0gdmFsdWVzO1xuICAgIGNvbXBhcmVGbiA9IGlzRXF1YWw7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IGwgPSBjb21wYXJlVG8ubGVuZ3RoO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoaSA9PT0gbClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjb25zdCBuZXh0ID0gdGhpcy5sYShpICsgMSk7XG4gICAgICBpZiAobmV4dCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEVPRlxuICAgICAgZWxzZSBpZiAoIWNvbXBhcmVGbihuZXh0LCBjb21wYXJlVG9baV0pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG5cbiAgYXNzZXJ0QWR2YW5jZSguLi52YWx1ZXM6IFZbXSkge1xuICAgIHJldHVybiB0aGlzLmFzc2VydEFkdmFuY2VXaXRoKHZhbHVlcyk7XG4gIH1cblxuICBhc3NlcnRBZHZhbmNlV2l0aDxDPih2YWx1ZXM6IENbXSwgaXNFcXVhbCA9IChhOiBWLCBiOiBDKSA9PiBhIGFzIGFueSA9PT0gYikge1xuICAgIGxldCBjb21wYXJlVG86IENbXSB8IHN0cmluZztcbiAgICBsZXQgY29tcGFyZUZuOiAoLi4uYXJnOiBhbnlbXSkgPT4gYm9vbGVhbjtcbiAgICBjb21wYXJlVG8gPSB2YWx1ZXM7XG4gICAgY29tcGFyZUZuID0gaXNFcXVhbDtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3QgbCA9IGNvbXBhcmVUby5sZW5ndGg7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChpID09PSBsKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmFkdmFuY2UoaSArIDEpO1xuICAgICAgaWYgKG5leHQgPT0gbnVsbClcbiAgICAgICAgdGhpcy50aHJvd0Vycm9yKCdFT0YnLCBuZXcgRXJyb3IoKS5zdGFjayk7IC8vIEVPRlxuICAgICAgZWxzZSBpZiAoIWNvbXBhcmVGbihuZXh0LCBjb21wYXJlVG9baV0pKVxuICAgICAgICB0aGlzLnRocm93RXJyb3IodXRpbC5pbnNwZWN0KG5leHQpLCBuZXcgRXJyb3IoKS5zdGFjaywgY29tcGFyZVRvW2ldICsgJycpO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3IodW5leHBlY3RlZCA9ICdFbmQtb2Ytc3RyZWFtJywgc3RhY2s/OiBhbnksIGV4cGVjdD86IHN0cmluZykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbiAke3RoaXMubmFtZX0gdW5leHBlY3RlZCAke0pTT04uc3RyaW5naWZ5KHVuZXhwZWN0ZWQpfWAgK1xuICAgIChleHBlY3QgPyBgKGV4cGVjdGluZyBcIiR7ZXhwZWN0fVwiKWAgOiAnJykgK1xuICAgIGBhdCAke3RoaXMuZ2V0Q3VycmVudFBvc0luZm8oKX0sICR7c3RhY2sgPyAncHJldmlvdXMgc3RhY2s6JyArIHN0YWNrIDogJyd9YCk7XG4gIH1cblxuICBnZXRDdXJyZW50UG9zSW5mbygpOiBzdHJpbmcge1xuICAgIHJldHVybiBgb2Zmc2V0ICR7dGhpcy5jdXJyUG9zfSBbJHt0aGlzLmxpbmV9OiR7dGhpcy5jb2x1bW59XWA7XG4gIH1cblxuICBzdGFydENodW5rKHR5cGU6IFQsIHRyYWNrVmFsdWUgPSB0cnVlKSB7XG4gICAgaWYgKHRoaXMuY3VyckNodW5rICYmICF0aGlzLmN1cnJDaHVuay5pc0Nsb3NlZClcbiAgICAgIHRoaXMuY3VyckNodW5rLmNsb3NlKHRoaXMuY3VyclBvcyk7XG4gICAgdGhpcy5jdXJyQ2h1bmsgPSBuZXcgQ2h1bms8ViwgVD4odGhpcy5jdXJyUG9zLCB0aGlzLmxpbmUsIHRoaXMuY29sdW1uKTtcbiAgICB0aGlzLmN1cnJDaHVuay50cmFja1ZhbHVlID0gdHJhY2tWYWx1ZTtcbiAgICB0aGlzLmN1cnJDaHVuay50eXBlID0gdHlwZTtcbiAgICByZXR1cm4gdGhpcy5jdXJyQ2h1bms7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2xvc2VDaHVuaygpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyQ2h1bmshLmNsb3NlKHRoaXMuY3VyclBvcyk7XG4gIH1cblxuICAvKipcblx0ICogRG8gbm90IHJlYWQgcG9zdGlvbiBsZXNzIHRoYW4gMFxuXHQgKiBAcGFyYW0gcG9zIFxuXHQgKi9cbiAgcHJpdmF0ZSByZWFkKHBvczogbnVtYmVyKTogViB8IG51bGwge1xuICAgIGNvbnN0IGNhY2hlT2Zmc2V0ID0gcG9zIC0gdGhpcy5jYWNoZVN0YXJ0UG9zO1xuICAgIGlmIChjYWNoZU9mZnNldCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuIG5vdCByZWFkIGJlaGluZCBzdHJlYW0gY2FjaGUsIGF0IHBvc2l0aW9uOiAke3Bvc31gKTtcbiAgICB9XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChjYWNoZU9mZnNldCA8IHRoaXMuY2FjaGVkLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWRbY2FjaGVPZmZzZXRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMub25EcmFpbikge1xuICAgICAgICAgIHRoaXMub25EcmFpbigpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGludGVybmFsIGJ1ZmZlciBpcyBkcmFpbmVkIGVhcmx5IGF0ICR7cG9zfWApO1xuICAgICAgICAvLyB0aGlzLndhaXRGb3JQb3MgPSBwb3M7XG4gICAgICAgIC8vIGNvbnN0IGVyciA9IG5ldyBXYWl0RXJyb3IoKTtcbiAgICAgICAgLy8gdGhyb3cgZXJyO1xuICAgICAgICAvLyByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIC8vICAgdGhpcy5yZWFkUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIC8vIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdHJDaHVuazJUb2tlbjxUPihjaHVuazogQ2h1bms8c3RyaW5nLCBUPikge1xuICBpZiAoY2h1bmsudmFsdWVzKSB7XG4gICAgKGNodW5rIGFzIFRva2VuPFQ+KS50ZXh0ID0gY2h1bmsudmFsdWVzLmpvaW4oJycpO1xuICAgIGRlbGV0ZSBjaHVuay52YWx1ZXM7XG4gIH1cbiAgcmV0dXJuIGNodW5rIGFzIFRva2VuPFQ+O1xufVxuXG4vKipcbiAqIENvbnZlbmllbnQgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgdGV4dCBiYXNlZCBwYXJzZXIsXG4gKiB5b3Ugb25seSBuZWVkIHRvIGRlZmluZSBUb2tlbiB0eXBlcywgbGV4ZXIgZnVuY3Rpb24sIGdyYW1tYXIgZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRleHRQYXJzZXIoKSB7XG5cbn1cbiJdfQ==