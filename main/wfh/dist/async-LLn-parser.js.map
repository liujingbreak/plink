{"version":3,"file":"async-LLn-parser.js","sourceRoot":"","sources":["../ts/async-LLn-parser.ts"],"names":[],"mappings":"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","sourcesContent":["import util from 'util';\nimport {lastValueFrom, Observable, Subscriber, from, OperatorFunction, queueScheduler} from 'rxjs';\nimport {map, observeOn} from 'rxjs/operators';\nexport class Chunk<V, T> {\n  type: T | undefined;\n  values?: V[] = [];\n  end?: number;\n  isClosed = false;\n  trackValue = true;\n\n  constructor(\n    public pos: number, public line: number, public col: number\n  ) {}\n\n  close(position: number) {\n    this.isClosed = true;\n    this.end = position;\n    return this;\n  }\n}\n\nexport class Token<T> extends Chunk<string, T> {\n  text!: string;\n}\n/**\n * You can define a lexer as a function\n */\nexport type ParseLex<I, T> = (la: LookAheadObservable<I, T>, sub: Subscriber<Chunk<I, T>>) => Promise<any>;\nexport type ParseGrammar<A, T> = (la: LookAhead<Token<T>, T>) => Promise<A>;\n/**\n * Parser\n * @param input string type\n * @param parseLex \n * @param parseGrammar \n */\nexport function parser<I, A, T>(\n  name: string,\n  input: Observable<Iterable<I>>,\n  parseLex: ParseLex<I, T>,\n  pipeOperators: Iterable<OperatorFunction<Token<T>, Token<T>>> | null,\n  parseGrammar: ParseGrammar<A, T>\n): Promise<A> {\n\n  const _parseGrammarObs = (la: LookAhead<Token<T>, T>) => {\n    return from(parseGrammar(la));\n  };\n\n  let tokens = input.pipe(\n    observeOn(queueScheduler),\n    mapChunks(name + '-lexer', parseLex),\n    map(chunk => {\n      (chunk as Token<T>).text = chunk.values!.join('');\n      delete chunk.values;\n      return chunk as Token<T>;\n    })\n  );\n  if (pipeOperators) {\n    for (const operator of pipeOperators)\n      tokens = tokens.pipe(operator);\n  }\n\n  return lastValueFrom(tokens.pipe(\n    map(token => [token]),\n    mapChunksObs(name + '-parser', _parseGrammarObs)\n  ));\n}\n\nexport function mapChunksObs<I, O>(name: string, parse: (la: LookAhead<I>) => Observable<O>):\n(input: Observable<Iterable<I>>) => Observable<O> {\n\n  return function(input: Observable<Iterable<I>>) {\n    return new Observable<O>(sub => {\n      const la = new LookAhead<I>(name);\n      input.subscribe(input => la._write(input),\n        err => sub.error(err),\n        () => la._final()\n      );\n      parse(la).subscribe(\n        ouput => sub.next(ouput),\n        err => sub.error(err),\n        () => sub.complete()\n      );\n    });\n  };\n}\n\nexport function mapChunks<I, T>(\n  name: string,\n  parse: ParseLex<I, T>\n): (input: Observable<Iterable<I>>) => Observable<Chunk<I, T>> {\n\n  return function(input: Observable<Iterable<I>>) {\n    return new Observable<Chunk<I, T>>(sub => {\n      const la = new LookAhead<I, T>(name);\n      input.subscribe(input => la._write(input),\n        err => sub.error(err),\n        () => la._final()\n      );\n      const la$ = la as LookAheadObservable<I, T>;\n\n      la$.startToken = la.startChunk;\n\n      la$.emitToken = function(this: LookAheadObservable<I, T>) {\n        const chunk = this.closeChunk();\n        sub.next(chunk);\n        return chunk;\n      };\n      parse(la$, sub)\n      .then(() => sub.complete())\n      .catch(err => sub.error(err));\n    });\n  };\n}\n\nexport class LookAhead<T, TT = any> {\n  cached: Array<T | null>;\n  lastConsumed: T | undefined | null;\n  // isString: boolean;\n  line = 1;\n  column = 1;\n  protected currPos = 0;\n  private cacheStartPos = 0; // Currently is always same as currPos\n  private readResolve: ((value: T | null) => void) | undefined;\n  private waitForPos: number | undefined;\n  private currChunk: Chunk<T, TT> | undefined;\n\n  constructor(protected name: string) {\n    this.cached = [];\n  }\n\n  _write(values: Iterable<T | null>) {\n    for (const v of values)\n      this.cached.push(v);\n    // console.log('_writeAndResolve resolve ', this.cached.length);\n\n    if (this.readResolve != null) {\n      const resolve = this.readResolve;\n      const cacheOffset = this.waitForPos! - this.cacheStartPos;\n      if (cacheOffset < this.cached.length) {\n        delete this.readResolve;\n        delete this.waitForPos;\n        resolve(this.cached[cacheOffset]);\n      }\n    }\n  }\n\n  _final() {\n    this._write([null]);\n  }\n\n  get position(): number {\n    return this.currPos;\n  }\n\n  /**\n\t * look ahead for 1 character\n\t * @param num default is 1\n\t * @return null if EOF is reached\n\t */\n  la(num = 1): Promise<T | null> {\n    const readPos = this.currPos + num - 1;\n    return this.read(readPos);\n  }\n\n  // lb(num = 1): T | null {\n  //   const pos = this.currPos - (num - 1);\n  //   if (pos < 0)\n  //     return null;\n  //   return this.read(pos);\n  // }\n\n  async advance(count = 1): Promise<T> {\n    let currValue: T;\n    let i = 0;\n    while (i++ < count) {\n      const value = await this.la(1);\n      if (value == null) {\n        this.throwError('Unexpect EOF'); // , stack);\n        break;\n      }\n      this.currPos++;\n      this.column++;\n      if ((value as any) === '\\n') {\n        this.line++;\n        this.column = 1;\n      }\n      if (this.currPos - this.cacheStartPos > 0x100000) {\n        this.cached.splice(0, 0x100000);\n        this.cacheStartPos += 0x100000;\n      }\n      if (this.currChunk && !this.currChunk.isClosed && this.currChunk.trackValue) {\n        this.currChunk.values!.push(value);\n      }\n      currValue = value;\n    }\n    this.lastConsumed = currValue!;\n    return currValue!;\n  }\n\n  isNext(...values: T[]) {\n    return this.isNextWith(values);\n  }\n  /**\n\t * Same as `return la(1) === values[0] && la(2) === values[1]...`\n\t * @param values lookahead string or tokens\n\t */\n  async isNextWith<C>(values: C[], isEqual = (a: T, b: C) => a as any === b): Promise<boolean> {\n    const compareTo = values;\n    const compareFn = isEqual;\n    let i = 0;\n    const l = compareTo.length;\n    for (;;) {\n      if (i === l)\n        return true;\n      const next = await this.la(i + 1);\n      if (next == null)\n        return false; // EOF\n      else if (!compareFn(next, compareTo[i]))\n        return false;\n      i++;\n    }\n  }\n\n  assertAdvance(...values: T[]) {\n    return this.assertAdvanceWith(values);\n  }\n\n  async assertAdvanceWith<C>(values: C[], isEqual = (a: T, b: C) => a as any === b) {\n    const compareTo = values;\n    const compareFn = isEqual;\n    let i = 0;\n    const l = compareTo.length;\n    for (;;) {\n      if (i === l)\n        return true;\n      const next = await this.advance(i + 1);\n      if (next == null)\n        this.throwError('EOF', new Error().stack); // EOF\n      else if (!compareFn(next, compareTo[i]))\n        this.throwError(util.inspect(next), new Error().stack, compareTo.join(','));\n      i++;\n    }\n  }\n\n  throwError(unexpected = 'End-of-stream', stack?: any, expect?: string) {\n    // eslint-disable-next-line max-len\n    throw new Error(`In ${this.name} unexpected ${JSON.stringify(unexpected)}` +\n    (expect ? `(expecting \"${expect}\")` : '') +\n    `at ${this.getCurrentPosInfo()}, ${stack ? 'previous stack:' + stack : ''}`);\n  }\n\n  getCurrentPosInfo(): string {\n    return `offset ${this.currPos} [${this.line}:${this.column}]`;\n  }\n\n  startChunk(type: TT, trackValue = true) {\n    if (this.currChunk && !this.currChunk.isClosed)\n      this.currChunk.close(this.currPos);\n    this.currChunk = new Chunk<T, TT>(this.currPos, this.line, this.column);\n    this.currChunk.trackValue = trackValue;\n    this.currChunk.type = type;\n    return this.currChunk;\n  }\n\n  closeChunk() {\n    return this.currChunk!.close(this.currPos);\n  }\n\n  /**\n\t * Do not read postion less than 0\n\t * @param pos \n\t */\n  protected read(pos: number): Promise<T | null> {\n    const cacheOffset = pos - this.cacheStartPos;\n    if (cacheOffset < 0) {\n      throw new Error(`Can not read behind stream cache, at position: ${pos}`);\n    }\n    if (cacheOffset < this.cached.length) {\n      return Promise.resolve(this.cached[cacheOffset]);\n    } else {\n      this.waitForPos = pos;\n      return new Promise(resolve => {\n        this.readResolve = resolve;\n      });\n    }\n  }\n}\n\nexport interface LookAheadObservable<V, T> extends LookAhead<V, T> {\n  startToken: LookAhead<V, T>['startChunk'];\n  emitToken(): Chunk<V, T>;\n}\n\n"]}