"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.forkFile = exports.workDirChangedByCli = exports.isWin32 = void 0;
const path_1 = __importDefault(require("path"));
const child_process_1 = require("child_process");
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const log4js_1 = __importDefault(require("log4js"));
const misc_1 = require("./utils/misc");
exports.isWin32 = os_1.default.platform().indexOf('win32') >= 0;
const log = log4js_1.default.getLogger('plink.fork-for-preserver-symlink');
function workDirChangedByCli() {
    let argv = process.argv.slice(2);
    const foundCmdOptIdx = argv.findIndex(arg => arg === '--cwd' || arg === '--space');
    const workdir = foundCmdOptIdx >= 0 ? path_1.default.resolve(misc_1.plinkEnv.rootDir, argv[foundCmdOptIdx + 1]) : null;
    if (workdir) {
        argv.splice(foundCmdOptIdx, 2);
        // process.env.PLINK_WORK_DIR = workdir;
    }
    return { workdir, argv };
}
exports.workDirChangedByCli = workDirChangedByCli;
async function forkFile(moduleName) {
    process.on('SIGINT', () => {
        // eslint-disable-next-line no-console
        log.info('bye');
        recoverNodeModuleSymlink();
        process.exit(0);
    });
    let recovered = false;
    const removed = await removeNodeModuleSymlink();
    process.on('beforeExit', () => {
        recoverNodeModuleSymlink();
    });
    const { workdir, argv } = workDirChangedByCli();
    process.execArgv.push('--preserve-symlinks-main', '--preserve-symlinks');
    const foundDebugOptIdx = argv.findIndex(arg => arg === '--inspect' || arg === '--inspect-brk');
    const env = Object.assign({}, process.env);
    if (foundDebugOptIdx >= 0) {
        env.NODE_OPTIONS = env.NODE_OPTIONS ? env.NODE_OPTIONS + ' ' + argv[foundDebugOptIdx] : argv[foundDebugOptIdx];
        argv.splice(foundDebugOptIdx, 1);
    }
    const debugOptIdx = argv.findIndex(arg => arg === '--debug');
    if (debugOptIdx >= 0) {
        env.NODE_OPTIONS = env.NODE_OPTIONS ? env.NODE_OPTIONS + ' --inspect-brk' : '--inspect-brk';
        argv.splice(debugOptIdx, 1);
    }
    env.__plink_fork_main = moduleName;
    // env.__plink_save_state = '1';
    if (workdir)
        env.PLINK_WORK_DIR = workdir;
    const cp = (0, child_process_1.fork)(path_1.default.resolve(__dirname, 'fork-preserve-symlink-main.js'), argv, {
        env,
        stdio: 'inherit'
    });
    cp.on('exit', code => {
        if (code != null && code !== 0) {
            process.exit(code);
        }
    });
    function recoverNodeModuleSymlink() {
        if (recovered)
            return;
        recovered = true;
        for (const { link, content } of removed) {
            if (!fs_1.default.existsSync(link)) {
                void fs_1.default.promises.symlink(content, link, exports.isWin32 ? 'junction' : 'dir');
                log.info('recover ' + link);
            }
        }
    }
}
exports.forkFile = forkFile;
/**
 * Temporarily rename <pkg>/node_modules to another name
 * @returns
 */
async function removeNodeModuleSymlink() {
    const { getState } = require('./editor-helper');
    const links = getState().nodeModuleSymlinks;
    if (links == null)
        return Promise.resolve([]);
    const dones = Array.from(links.values()).map(async (link) => {
        let stat;
        try {
            stat = await fs_1.default.promises.lstat(link);
            if (!stat.isSymbolicLink())
                return null;
        }
        catch (ex) {
            return null;
        }
        const content = fs_1.default.readlinkSync(link);
        log.info('backup symlink: ' + link);
        await fs_1.default.promises.unlink(link);
        return { link, content };
    });
    const res = await Promise.all(dones);
    return res.filter(item => item != null);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9yay1mb3ItcHJlc2VydmUtc3ltbGluay5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3RzL2ZvcmstZm9yLXByZXNlcnZlLXN5bWxpbmsudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsZ0RBQXdCO0FBQ3hCLGlEQUFtQztBQUNuQyw0Q0FBb0I7QUFDcEIsNENBQW9CO0FBQ3BCLG9EQUE0QjtBQUM1Qix1Q0FBc0M7QUFJekIsUUFBQSxPQUFPLEdBQUcsWUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDM0QsTUFBTSxHQUFHLEdBQUcsZ0JBQU0sQ0FBQyxTQUFTLENBQUMsa0NBQWtDLENBQUMsQ0FBQztBQUVqRSxTQUFnQixtQkFBbUI7SUFDakMsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDakMsTUFBTSxjQUFjLEdBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxPQUFPLElBQUksR0FBRyxLQUFLLFNBQVMsQ0FBQyxDQUFDO0lBQ3BGLE1BQU0sT0FBTyxHQUFHLGNBQWMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQUksQ0FBQyxPQUFPLENBQUMsZUFBUSxDQUFDLE9BQU8sRUFBRyxJQUFJLENBQUMsY0FBYyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztJQUN2RyxJQUFJLE9BQU8sRUFBRTtRQUNYLElBQUksQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQy9CLHdDQUF3QztLQUN6QztJQUNELE9BQU8sRUFBQyxPQUFPLEVBQUUsSUFBSSxFQUFDLENBQUM7QUFDekIsQ0FBQztBQVRELGtEQVNDO0FBRU0sS0FBSyxVQUFVLFFBQVEsQ0FBQyxVQUFrQjtJQUMvQyxPQUFPLENB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QUFHLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNyQyxPQUFPLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFzQyxDQUFDO0FBQy9FLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7Zm9ya30gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IG9zIGZyb20gJ29zJztcbmltcG9ydCBsb2c0anMgZnJvbSAnbG9nNGpzJztcbmltcG9ydCB7cGxpbmtFbnZ9IGZyb20gJy4vdXRpbHMvbWlzYyc7XG5pbXBvcnQgKiBhcyBfZWRpdG9ySGVscGVyIGZyb20gJy4vZWRpdG9yLWhlbHBlcic7XG5pbXBvcnQgKiBhcyBfc3RvcmUgZnJvbSAnLi9zdG9yZSc7XG5cbmV4cG9ydCBjb25zdCBpc1dpbjMyID0gb3MucGxhdGZvcm0oKS5pbmRleE9mKCd3aW4zMicpID49IDA7XG5jb25zdCBsb2cgPSBsb2c0anMuZ2V0TG9nZ2VyKCdwbGluay5mb3JrLWZvci1wcmVzZXJ2ZXItc3ltbGluaycpO1xuXG5leHBvcnQgZnVuY3Rpb24gd29ya0RpckNoYW5nZWRCeUNsaSgpIHtcbiAgbGV0IGFyZ3YgPSBwcm9jZXNzLmFyZ3Yuc2xpY2UoMik7XG4gIGNvbnN0IGZvdW5kQ21kT3B0SWR4ID0gIGFyZ3YuZmluZEluZGV4KGFyZyA9PiBhcmcgPT09ICctLWN3ZCcgfHwgYXJnID09PSAnLS1zcGFjZScpO1xuICBjb25zdCB3b3JrZGlyID0gZm91bmRDbWRPcHRJZHggPj0gMCA/IFBhdGgucmVzb2x2ZShwbGlua0Vudi5yb290RGlyLCAgYXJndltmb3VuZENtZE9wdElkeCArIDFdKSA6IG51bGw7XG4gIGlmICh3b3JrZGlyKSB7XG4gICAgYXJndi5zcGxpY2UoZm91bmRDbWRPcHRJZHgsIDIpO1xuICAgIC8vIHByb2Nlc3MuZW52LlBMSU5LX1dPUktfRElSID0gd29ya2RpcjtcbiAgfVxuICByZXR1cm4ge3dvcmtkaXIsIGFyZ3Z9O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZm9ya0ZpbGUobW9kdWxlTmFtZTogc3RyaW5nKSB7XG4gIHByb2Nlc3Mub24oJ1NJR0lOVCcsICgpID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGxvZy5pbmZvKCdieWUnKTtcbiAgICByZWNvdmVyTm9kZU1vZHVsZVN5bWxpbmsoKTtcbiAgICBwcm9jZXNzLmV4aXQoMCk7XG4gIH0pO1xuXG4gIGxldCByZWNvdmVyZWQgPSBmYWxzZTtcbiAgY29uc3QgcmVtb3ZlZCA9IGF3YWl0IHJlbW92ZU5vZGVNb2R1bGVTeW1saW5rKCk7XG5cbiAgcHJvY2Vzcy5vbignYmVmb3JlRXhpdCcsICgpID0+IHtcbiAgICByZWNvdmVyTm9kZU1vZHVsZVN5bWxpbmsoKTtcbiAgfSk7XG5cbiAgY29uc3Qge3dvcmtkaXIsIGFyZ3Z9ID0gd29ya0RpckNoYW5nZWRCeUNsaSgpO1xuXG4gIHByb2Nlc3MuZXhlY0FyZ3YucHVzaCgnLS1wcmVzZXJ2ZS1zeW1saW5rcy1tYWluJywgJy0tcHJlc2VydmUtc3ltbGlua3MnKTtcbiAgY29uc3QgZm91bmREZWJ1Z09wdElkeCA9IGFyZ3YuZmluZEluZGV4KGFyZyA9PiBhcmcgPT09ICctLWluc3BlY3QnIHx8IGFyZyA9PT0gJy0taW5zcGVjdC1icmsnKTtcblxuICBjb25zdCBlbnY6IHtba2V5OiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWR9ID0gey4uLnByb2Nlc3MuZW52fTtcbiAgaWYgKGZvdW5kRGVidWdPcHRJZHggPj0gMCkge1xuICAgIGVudi5OT0RFX09QVElPTlMgPSBlbnYuTk9ERV9PUFRJT05TID8gZW52Lk5PREVfT1BUSU9OUyArICcgJyArIGFyZ3ZbZm91bmREZWJ1Z09wdElkeF0gOiBhcmd2W2ZvdW5kRGVidWdPcHRJZHhdO1xuICAgIGFyZ3Yuc3BsaWNlKGZvdW5kRGVidWdPcHRJZHgsIDEpO1xuICB9XG4gIGNvbnN0IGRlYnVnT3B0SWR4ID0gYXJndi5maW5kSW5kZXgoYXJnID0+IGFyZyA9PT0gJy0tZGVidWcnKTtcbiAgaWYgKGRlYnVnT3B0SWR4ID49IDApIHtcbiAgICBlbnYuTk9ERV9PUFRJT05TID0gZW52Lk5PREVfT1BUSU9OUyA/IGVudi5OT0RFX09QVElPTlMgKyAnIC0taW5zcGVjdC1icmsnIDogJy0taW5zcGVjdC1icmsnO1xuICAgIGFyZ3Yuc3BsaWNlKGRlYnVnT3B0SWR4LCAxKTtcbiAgfVxuXG4gIGVudi5fX3BsaW5rX2ZvcmtfbWFpbiA9IG1vZHVsZU5hbWU7XG4gIC8vIGVudi5fX3BsaW5rX3NhdmVfc3RhdGUgPSAnMSc7XG5cbiAgaWYgKHdvcmtkaXIpXG4gICAgZW52LlBMSU5LX1dPUktfRElSID0gd29ya2RpcjtcblxuICBjb25zdCBjcCA9IGZvcmsoUGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJ2ZvcmstcHJlc2VydmUtc3ltbGluay1tYWluLmpzJyksIGFyZ3YsIHtcbiAgICBlbnYsXG4gICAgc3RkaW86ICdpbmhlcml0J1xuICB9KTtcblxuICBjcC5vbignZXhpdCcsIGNvZGUgPT4ge1xuICAgIGlmIChjb2RlICE9IG51bGwgJiYgY29kZSAhPT0gMCkge1xuICAgICAgcHJvY2Vzcy5leGl0KGNvZGUpO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gcmVjb3Zlck5vZGVNb2R1bGVTeW1saW5rKCkge1xuICAgIGlmIChyZWNvdmVyZWQpXG4gICAgICByZXR1cm47XG4gICAgcmVjb3ZlcmVkID0gdHJ1ZTtcblxuICAgIGZvciAoY29uc3Qge2xpbmssIGNvbnRlbnR9IG9mIHJlbW92ZWQpIHtcbiAgICAgIGlmICghZnMuZXhpc3RzU3luYyhsaW5rKSkge1xuICAgICAgICB2b2lkIGZzLnByb21pc2VzLnN5bWxpbmsoY29udGVudCwgbGluaywgaXNXaW4zMiA/ICdqdW5jdGlvbicgOiAnZGlyJyk7XG4gICAgICAgIGxvZy5pbmZvKCdyZWNvdmVyICcgKyBsaW5rKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUZW1wb3JhcmlseSByZW5hbWUgPHBrZz4vbm9kZV9tb2R1bGVzIHRvIGFub3RoZXIgbmFtZVxuICogQHJldHVybnMgXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlbW92ZU5vZGVNb2R1bGVTeW1saW5rKCkge1xuICBjb25zdCB7Z2V0U3RhdGV9ID0gcmVxdWlyZSgnLi9lZGl0b3ItaGVscGVyJykgYXMgdHlwZW9mIF9lZGl0b3JIZWxwZXI7XG4gIGNvbnN0IGxpbmtzID0gZ2V0U3RhdGUoKS5ub2RlTW9kdWxlU3ltbGlua3M7XG5cbiAgaWYgKGxpbmtzID09IG51bGwpXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG5cbiAgY29uc3QgZG9uZXMgPSBBcnJheS5mcm9tKGxpbmtzLnZhbHVlcygpKS5tYXAoYXN5bmMgbGluayA9PiB7XG4gICAgbGV0IHN0YXQ6IGZzLlN0YXRzIHwgdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICBzdGF0ID0gYXdhaXQgZnMucHJvbWlzZXMubHN0YXQobGluayk7XG4gICAgaWYgKCFzdGF0LmlzU3ltYm9saWNMaW5rKCkpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgY29udGVudCA9IGZzLnJlYWRsaW5rU3luYyhsaW5rKTtcbiAgICBsb2cuaW5mbygnYmFja3VwIHN5bWxpbms6ICcgKyBsaW5rKTtcbiAgICBhd2FpdCBmcy5wcm9taXNlcy51bmxpbmsobGluayk7XG4gICAgcmV0dXJuIHtsaW5rLCBjb250ZW50fTtcbiAgfSk7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IFByb21pc2UuYWxsKGRvbmVzKTtcbiAgcmV0dXJuIHJlcy5maWx0ZXIoaXRlbSA9PiBpdGVtICE9IG51bGwpIGFzIHtsaW5rOiBzdHJpbmc7IGNvbnRlbnQ6IHN0cmluZ31bXTtcbn1cblxuIl19