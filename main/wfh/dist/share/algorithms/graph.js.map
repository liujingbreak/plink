{"version":3,"file":"graph.js","sourceRoot":"","sources":["../../../ts/share/algorithms/graph.ts"],"names":[],"mappings":"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","sourcesContent":["export enum Color {\n  /** unvisisted */\n  white = 0,\n  /** visiting */\n  gray,\n  /** visisted */\n  black\n}\n\nexport class Vertex<T> {\n  /** discovery time */\n  d: number = Number.MAX_VALUE;\n  /** finishing time, used to calculate \"Strongly connected components\" and \"Topological sort\" */\n  f: number | undefined;\n  /** parent vertices */\n  p?: Vertex<T>[];\n\n  constructor(public data: T, public color = Color.white) {\n  }\n}\n\nexport function getPathTo<T>(v: Vertex<T>, temp = [] as Vertex<T>[]) {\n  if (v.p) {\n    getPathTo(v.p[0], temp);\n  }\n  temp.push(v);\n}\n\nabstract class BaseGraph<T> {\n  protected vertexMap = new Map<T, Vertex<T>>();\n\n  visit(g: Iterable<T>) {\n    for (const data of g) {\n      const u = this.vertexOf(data);\n      if (u.color === Color.white) {\n        this.visitVertex(u);\n      }\n    }\n  }\n\n  protected abstract visitVertex(u: Vertex<T>): void;\n\n  protected vertexOf(data: T) {\n    if (this.vertexMap.has(data)) {\n      return this.vertexMap.get(data)!;\n    } else {\n      const v = new Vertex(data);\n      this.vertexMap.set(data, v);\n      return v;\n    }\n  }\n}\n\nexport class DFS<T> extends BaseGraph<T> {\n  backEdges: [Vertex<T>, Vertex<T>][] = [];\n\n  private time = 0;\n  private level = -1;\n  // private vertexMap = new Map<T, Vertex<T>>();\n\n  constructor(private adjacencyOf: (u: T, vertex: Vertex<T>, level: number) => Iterable<T>, private onFinish?: (vertex: Vertex<T>, level: number) => any) {\n    super();\n  }\n\n  visit(g: Iterable<T>) {\n    this.time = 0;\n    super.visit(g);\n  }\n\n  printCyclicBackEdge(edge: Vertex<T>, edgeTo: Vertex<T>): string[] {\n    return [...this._printParentUntil(edge, edgeTo), edgeTo.data + ''];\n  }\n\n  _printParentUntil(edge: Vertex<T>, edgeAncestor: Vertex<T>): string[] {\n    if (edge == null) {\n      return [];\n    }\n    if (edge === edgeAncestor) {\n      return [edgeAncestor.data + ''];\n    }\n    if (edge.p)\n      return [...this._printParentUntil(edge.p[0], edgeAncestor), edge.data + ''];\n    else\n      return ['? -> ', edge.data + ''];\n  }\n\n  protected visitVertex(u: Vertex<T>) {\n    u.d = ++this.time;\n    u.color = Color.gray;\n    this.level++;\n    for (const vData of this.adjacencyOf(u.data, u, this.level)) {\n      const v = this.vertexOf(vData);\n      if (v.color === Color.white) {\n        v.p = [u];\n        this.visitVertex(v);\n      } else if (v.color === Color.gray) {\n        this.backEdges.push([u, v]);\n      } else {\n        if (v.p == null)\n          v.p = [];\n        v.p.push(u);\n      }\n    }\n    u.color = Color.black;\n    u.f = ++this.time;\n    this.level--;\n    if (this.onFinish)\n      this.onFinish(u, this.level);\n  }\n}\n\nexport class BFS<T> extends BaseGraph<T> {\n  constructor(private adjacencyOf: (u: T, vertex: Vertex<T>) => Iterable<T>) {\n    super();\n  }\n\n  protected visitVertex(s: Vertex<T>) {\n    s.color = Color.gray;\n    s.d = 0;\n    const q: Vertex<T>[] = [s];\n    while (q.length > 0) {\n      const u = q.shift()!;\n      for (const vData of this.adjacencyOf(u.data, u)) {\n        const v = this.vertexOf(vData);\n        if (v.color === Color.white) {\n          v.color = Color.gray;\n          v.d = u.d + 1;\n          if (v.p == null)\n            v.p = [];\n          v.p.push(u);\n          q.push(v);\n        }\n      }\n      u.color = Color.black;\n    }\n  }\n}\n"]}