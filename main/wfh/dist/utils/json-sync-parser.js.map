{"version":3,"file":"json-sync-parser.js","sourceRoot":"","sources":["../../src/utils/json-sync-parser.ts"],"names":[],"mappings":"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","sourcesContent":["\nimport { Chunk, Grammar, Lexer, parser } from '../LLn-parser';\n\nexport type Token = Chunk<string, string> & {/** string literal contains \"\" or '' */text: string};\n\nconst lexer: Lexer<string, string, Token> = function(\n  strLookAhead, emitter) {\n  let char = strLookAhead.la();\n  if (char == null) {\n    emitter.end();\n    return;\n  }\n  if (/[{}\\[\\],:]/.test(char)) {\n    strLookAhead.startChunk(char);\n    strLookAhead.advance();\n    emitter.emit();\n  } else if (/\\s/.test(char)) {\n    do {\n      strLookAhead.advance();\n      char = strLookAhead.la();\n    } while (char && /\\s/.test(char));\n  } else if (/[\"']/.test(char)) {\n    strLookAhead.startChunk('stringLiteral');\n    const openChar = strLookAhead.advance();\n    while (true) {\n      const la = strLookAhead.la();\n      if (la == null) {\n        return strLookAhead.throwError();\n      }\n      if (la === '\\\\') {\n        strLookAhead.advance(2);\n      } else if (la === openChar) {\n        strLookAhead.advance();\n        emitter.emit();\n        return;\n      } else {\n        strLookAhead.advance();\n      }\n    }\n  } else {\n    strLookAhead.startChunk('other');\n    let next: string | null;\n    do {\n      strLookAhead.advance();\n      next = strLookAhead.la();\n    } while (next != null && !/[{}\\[\\],:\\s'\"]/.test(next));\n    emitter.emit();\n  }\n  char = strLookAhead.la();\n};\n\nenum AstType {\n  object = 0,\n  array,\n  property,\n  value\n}\n\nexport interface Ast {\n  type: AstType;\n  start: number;\n  end: number;\n}\n\nexport interface ObjectAst extends Ast {\n  properties: {name: Token; value: Ast|Token}[];\n}\n\nexport interface ArrayAst extends Ast {\n  items: Array<Ast | Token>;\n}\n\nexport function isObjectAst(ast: Ast | Token): ast is ObjectAst {\n  return ast.type === AstType.object;\n}\n\nexport function isArrayAst(ast: Ast | Token): ast is ArrayAst {\n  return ast.type === AstType.array;\n}\n\nexport function isToken(ast: Ast | Token): ast is Token {\n  return (ast as Token).text != null;\n}\n\nconst grammar: Grammar<Token, ObjectAst> = function(tokenLa) {\n  return doObject(tokenLa);\n};\n\nfunction doObject(lexer: Parameters<Grammar<Token, ObjectAst>>[0]): ObjectAst {\n  const ast: Partial<ObjectAst> = {\n    type: AstType.object,\n    properties: []\n  };\n  const lp = lexer.advance();\n  ast.start = lp.pos;\n  let next = lexer.la();\n  while (next != null && next.type !== '}') {\n    const propToken = lexer.advance();\n    const colon = lexer.advance();\n    if (colon.type !== ':') {\n      throw new Error(`Expect ':' but recieve '${colon.text}' at ${colon.line}:${colon.col}`);\n    }\n\n    ast.properties!.push({name: propToken, value: doValue(lexer)});\n    next = lexer.la();\n    if (next && next.type === ',')\n      lexer.advance();\n    next = lexer.la();\n  }\n  const rp = lexer.advance(); // }\n  ast.end = rp.end;\n  return ast as ObjectAst;\n}\n\nfunction doArray(lexer: Parameters<Grammar<Token, ObjectAst>>[0]): ArrayAst {\n  const ast: Partial<ArrayAst> = {\n    type: AstType.array,\n    items: []\n  };\n  const lp = lexer.advance();\n  ast.start = lp.pos;\n  let next = lexer.la();\n  while (next != null && next.type !== ']') {\n\n    if (next.type !== ',') {\n      ast.items!.push(doValue(lexer));\n    } else {\n      lexer.advance();\n    }\n    next = lexer.la();\n  }\n  if (next && next.type === ']') {\n    ast.end = lexer.advance().end; // ]\n\n  } else if (next == null)\n    throw new Error('Unexpect EOF after ' + lexer.lastConsumed?.text);\n  else\n    throw new Error(`Unexpect ${next.text} at ${next.line}:${next.col}`);\n  return ast as ArrayAst;\n}\n\nfunction doValue(lexer: Parameters<Grammar<Token, ObjectAst>>[0]) {\n  const next = lexer.la();\n  if (next === null) {\n    throw new Error('Unexpect EOF');\n  }\n  if (next.type === '{') {\n    return doObject(lexer);\n  } else if (next.type === '[') {\n    return doArray(lexer);\n  } else if (next.type === 'stringLiteral' || next.type === 'other') {\n    return lexer.advance();\n  } else {\n    throw new Error(`Unexpect '${next.text}' at ${next.line}:${next.col}`);\n  }\n}\n\nexport default function parse(content: string) {\n  const jsonParser = parser<string, string, Token, ObjectAst>(\n    'JSON', lexer, grammar);\n  jsonParser.write(content);\n  jsonParser.end();\n  return jsonParser.getResult();\n}\n"]}