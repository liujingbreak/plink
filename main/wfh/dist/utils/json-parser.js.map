{"version":3,"file":"json-parser.js","sourceRoot":"","sources":["../../src/utils/json-parser.ts"],"names":[],"mappings":"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","sourcesContent":["\nimport {parser, LookAhead, LookAheadObservable, Chunk, Token} from '../async-LLn-parser';\nimport {Observable, Subscriber} from 'rxjs';\nimport {tap} from 'rxjs/operators';\nimport {Readable} from 'stream';\n\nexport default function parse(reader: Readable, onToken?: (token: Token<string>) => void) {\n  const input = new Observable<string[]>(sub => {\n    reader.on('data', (buf: string) => sub.next(buf.split('')));\n    reader.on('end', () => sub.complete());\n  });\n\n  const operators = onToken ? [tap(onToken)] : null;\n\n  return parser('JSON', input, parseLex, operators, parseGrammar);\n}\n\nexport {Token};\n\nasync function parseLex(\n  strLookAhead: LookAheadObservable<string, string>,\n  tokenSub: Subscriber<Chunk<string, string>>) {\n  let char = await strLookAhead.la();\n  while (char != null) {\n    if (/[{}\\[\\],:]/.test(char)) {\n      strLookAhead.startToken(char);\n      await strLookAhead.advance();\n      strLookAhead.emitToken();\n    } else if (/\\s/.test(char)) {\n      do {\n        await strLookAhead.advance();\n        char = await strLookAhead.la();\n      } while (char && /\\s/.test(char));\n    } else if (/[\"']/.test(char)) {\n      strLookAhead.startToken('stringLiteral');\n      const openChar = await strLookAhead.advance();\n      while (true) {\n        const la = await strLookAhead.la();\n        if (la == null) {\n          return strLookAhead.throwError();\n        }\n        if (la === '\\\\') {\n          await strLookAhead.advance(2);\n        } else if (la === openChar) {\n          await strLookAhead.advance();\n          strLookAhead.emitToken();\n          break;\n        } else {\n          await strLookAhead.advance();\n        }\n      }\n    } else {\n      strLookAhead.startToken('other');\n      let next: string | null;\n      do {\n        await strLookAhead.advance();\n        next = await strLookAhead.la();\n      } while (next != null && !/[{}\\[\\],:\\s'\"]/.test(next));\n      strLookAhead.emitToken();\n    }\n    char = await strLookAhead.la();\n  }\n}\n\ntype Lexer = LookAhead<Token<string>, string>;\n\nenum AstType {\n  object = 0,\n  array,\n  property,\n  value\n}\n\nexport interface Ast {\n  type: AstType;\n}\n\nexport interface ObjectAst extends Ast {\n  properties: {name: Token<string>; value: Ast|Token<string>}[];\n}\n\nexport interface ArrayAst extends Ast {\n  items: Array<Ast | Token<string>>;\n}\n\nexport interface ValueAst extends Ast {\n  value: Token<string>;\n}\n\nasync function parseGrammar(tokenLa: Lexer) {\n  return doObject(tokenLa);\n}\n\nasync function doObject(lexer: Lexer): Promise<ObjectAst> {\n  const ast: ObjectAst = {\n    type: AstType.object,\n    properties: []\n  };\n  await lexer.advance();\n  let next = await lexer.la();\n  while (next != null && next.type !== '}') {\n    const propToken = await lexer.advance();\n    const colon = await lexer.advance();\n    if (colon.type !== ':') {\n      throw new Error(`Expect ':' but recieve '${colon.text}' at ${colon.line}:${colon.col}`);\n    }\n\n    ast.properties.push({name: propToken, value: await doValue(lexer)});\n    next = await lexer.la();\n    if (next && next.type === ',')\n      await lexer.advance();\n    next = await lexer.la();\n  }\n  await lexer.advance(); // }\n  return ast;\n}\n\nasync function doArray(lexer: Lexer): Promise<ArrayAst> {\n  const ast: ArrayAst = {\n    type: AstType.array,\n    items: []\n  };\n  await lexer.advance();\n  let next = await lexer.la();\n  while (next != null && next.type !== ']') {\n    if (next.type !== ',') {\n      ast.items.push(await doValue(lexer));\n    }\n    next = await lexer.la();\n  }\n  if (next && next.type === ']')\n    await lexer.advance(); // ]\n  else if (next == null)\n    throw new Error('Unexpect EOF after ' + lexer.lastConsumed!.text);\n  else\n    throw new Error(`Unexpect ${next.text} at ${next.line}:${next.col}`);\n  return ast;\n}\n\nasync function doValue(lexer: Lexer) {\n  const next = await lexer.la();\n  if (next === null) {\n    throw new Error('Unexpect EOF');\n  }\n  if (next.type === '{') {\n    return doObject(lexer);\n  } else if (next.type === '[') {\n    return doArray(lexer);\n  } else if (next.type === 'stringLiteral' || next.type === 'other') {\n    return lexer.advance();\n  } else {\n    throw new Error(`Unexpect '${next.text}' at ${next.line}:${next.col}`);\n  }\n}\n"]}