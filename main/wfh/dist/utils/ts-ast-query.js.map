{"version":3,"file":"ts-ast-query.js","sourceRoot":"","sources":["../../ts/utils/ts-ast-query.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from 'fs';\n// import keysIn from 'lodash/keysIn';\nimport isRegExp from 'lodash/isRegExp';\nimport uniq from 'lodash/uniq';\nimport _ from 'lodash';\nimport ts, { SyntaxKind as sk} from 'typescript';\nimport chalk from 'chalk';\nexport {ts as typescript};\n\nexport let astSchemaCache: {[kind: string]: string[]} = {};\n// let fileCounting = 0;\n// let lastFile: string;\n\nexport function saveAstPropertyCache(file: string): void {\n  fs.writeFileSync(file, JSON.stringify(astSchemaCache, null, '  '));\n}\n\nexport function setAstPropertyCache(cache: typeof astSchemaCache): void {\n  astSchemaCache = cache;\n}\n\nexport type AstHandler<T> = (ast: ts.Node, path: string[], parents: ts.Node[], isLeaf: boolean) => T;\n\n/**\n * @returns true - make iteration stops, `SKIP` - to skip interating child nodes (move on to next sibling node) \n */\n// eslint-disable-next-line max-len\nexport type traverseCbType = (ast: ts.Node, path: string[], parents: ts.Node[], isLeaf: boolean, comment?: string) => 'SKIP' | boolean | void;\n\nexport function printFile(file: string, query?: string | null, withType = true): void {\n  if (query) {\n    const selector = new Selector(fs.readFileSync(file, 'utf8'), file);\n    selector.findMapTo(query, (ast, path, parents) => {\n      // eslint-disable-next-line no-console\n      console.log(chalk.cyan(\n        withType ? path.join(' > ') : path.map(el => el.slice(0, el.indexOf(':'))).join(' > ')\n      ));\n      selector.traverse(ast, createPrintNodeCb(withType));\n    });\n  } else {\n    if (withType)\n      new Selector(fs.readFileSync(file, 'utf8'), file).printAll();\n    else\n      new Selector(fs.readFileSync(file, 'utf8'), file).printAllNoType();\n  }\n  // console.log(astSchemaCache);\n}\nfunction createPrintNodeCb(withType: boolean) {\n  const printNode: traverseCbType = (child, path, parents, isLeaf, comment) => {\n    if (comment) {\n      // eslint-disable-next-line no-console\n      console.log(\n        (withType ? path.join(' > ') : path.map(pathExp).join('')) +\n          ` ${chalk.yellow(comment)}`\n      );\n    }\n    if (!isLeaf)\n      return;\n    // eslint-disable-next-line no-console\n    console.log(\n      (withType ? path.join(' > ') : path.map(pathExp).join('')) +\n        ` ${chalk.greenBright(child.getText())}`\n    );\n  };\n\n  function pathExp(pathEl: string, idx: number, path: string[]): string {\n    const [exp, type] = pathEl.split(':');\n    if (type === 'SourceFile') {\n      return '';\n    } else {\n      return idx > 0 && path[idx - 1] === ':SourceFile' ? '^' + exp : ' > ' + exp;\n    }\n  }\n  return printNode;\n}\n\n\nexport interface WalkCallback {\n  query: string;\n  callback: (ast: ts.Node, path: string[], parents?: ts.Node[]) => true | void;\n}\n// type Callback = (ast: ts.Node, path: string[]) => boolean | void;\nexport default class Selector {\n  src: ts.SourceFile;\n\n  constructor(src: string, file: string);\n  constructor(src: ts.SourceFile);\n  constructor(src: ts.SourceFile | string, file?: string) {\n    if (typeof src === 'string') {\n      this.src = ts.createSourceFile(file || 'unknown', src, ts.ScriptTarget.ESNext,\n        true, ts.ScriptKind.TSX);\n    } else {\n      this.src = src;\n    }\n  }\n\n  /**\n\t * \n\t * @param ast root AST node\n\t * @param query Like CSS select := [\"^\"] <selector element> (\" \" | \">\") <selector element>\n\t *   where <selector element> := \".\" <property name> <index>? | \":\" <Typescript Syntax kind name> | *\n\t *   where <index> := \"[\" \"0\"-\"9\" \"]\"\n\t * e.g.\n\t *  - .elements:ImportSpecifier > .name\n\t *  - .elements[2] > .name\n\t *  - .statements[0] :ImportSpecifier > :Identifier\n   * @param cb return true to skip rest nodes\n   */\n  some(ast?: ts.Node | null, query?: string | null, cb?: traverseCbType | null): boolean {\n    const q = query ? new Query(query) : null;\n    return !!this.traverse(ast || this.src, (ast, path, ...rest) => {\n      if (q == null || q.matches(path)) {\n        if (cb) {\n          return cb(ast, path, ...rest);\n        }\n        return true;\n      }\n    });\n  }\n\n  walkAst(handlers: WalkCallback[]): void;\n  walkAst(ast: ts.Node, handlers: WalkCallback[]): void;\n  walkAst(ast: ts.Node|WalkCallback[] , handlers?: WalkCallback[]): void {\n    if (Array.isArray(ast)) {\n      handlers = ast;\n      ast = this.src;\n    }\n\n    const queryMap: {[str: string]: Query} = {};\n    if (!handlers)\n      return;\n    handlers.forEach(h => queryMap[h.query] = new Query(h.query));\n\n    this.traverse(ast, (ast, path, parents) => {\n      const skip = false;\n      handlers?.some(h => {\n        if (queryMap[h.query].matches(path)) {\n          h.callback(ast, path, parents);\n          return true;\n        }\n        return false;\n      });\n      if (skip)\n        return true;\n    });\n  }\n\n  /**\n\t * \n\t * @param query Like CSS select := [\"^\"] <selector element> (\" \" | \">\") <selector element>\n\t *   where <selector element> := \".\" <property name> <index>? | \":\" <Typescript Syntax kind name> | *\n\t *   where <index> := \"[\" \"0\"-\"9\" \"]\"\n   * \n\t * e.g.\n\t *  - .elements:ImportSpecifier > .name\n\t *  - .elements[2] > .name\n\t *  - ^.statements[0] :ImportSpecifier > :Identifier\n   * Begining with \"^\" meaning strictly matching starts with root node\n\t * @param callback \n\t */\n  findMapTo<T>(query: string, callback: AstHandler<T>): T | null;\n  findMapTo<T>(ast: ts.Node, query: string, callback: AstHandler<T>): T | null;\n  // eslint-disable-next-line max-len\n  findMapTo<T>(...arg: [queryOrAst: string | ts.Node, callBackOrQuery: AstHandler<T>|string, callback?: AstHandler<T>]): T | null {\n    let query: string;\n    let ast: ts.Node;\n    let callback: AstHandler<T>;\n    if (typeof arg[0] === 'string') {\n      ast = this.src;\n      query = arg[0];\n      callback = arg[1] as AstHandler<T>;\n    } else {\n      ast = arg[0];\n      query = arg[1] as string;\n      callback = arg[2] as AstHandler<T>;\n    }\n    let res: T | null = null;\n    const q = new Query(query!);\n\n    this.traverse(ast, (ast, path, parents, isLeaf) => {\n      if (res != null)\n        return true;\n      if (q.matches(path)) {\n        res = callback(ast, path, parents, isLeaf);\n        if (res != null)\n          return true;\n      }\n    });\n    return res;\n  }\n\n  /**\n\t * \n\t * @param ast root AST node\n\t * @param query Like CSS select := [\"^\"] <selector element> (\" \" | \">\") <selector element>\n\t *   where <selector element> := \".\" <property name> <index>? | \":\" <Typescript Syntax kind name> | *\n\t *   where <index> := \"[\" \"0\"-\"9\" \"]\"\n\t * e.g.\n\t *  - .elements:ImportSpecifier > .name\n\t *  - .elements[2] > .name\n\t *  - .statements[0] :ImportSpecifier > :Identifier\n\t */\n  findAll(query: string): ts.Node[];\n  findAll(ast: ts.Node, query: string): ts.Node[];\n  findAll(ast: ts.Node | string, query?: string): ts.Node[] {\n    let q: Query;\n    if (typeof ast === 'string') {\n      query = ast;\n      q = new Query(ast);\n      ast = this.src;\n    } else {\n      q = new Query(query!);\n    }\n\n    const res: ts.Node[] = [];\n    this.traverse(ast, (ast, path, _parents, _isLeaf) => {\n      if (q.matches(path)) {\n        res.push(ast);\n      }\n    });\n    return res;\n  }\n  /**\n\t * \n\t * @param ast root AST node\n\t * @param query Like CSS select := [\"^\"] <selector element> (\" \" | \">\") <selector element>\n\t *   where <selector element> := \".\" <property name> <index>? | \":\" <Typescript Syntax kind name> | *\n\t *   where <index> := \"[\" \"0\"-\"9\" \"]\"\n\t * e.g.\n\t *  - .elements:ImportSpecifier > .name\n\t *  - .elements[2] > .name\n\t *  - .statements[0] :ImportSpecifier > :Identifier\n\t */\n  findFirst(query: string): ts.Node | undefined;\n  findFirst(ast: ts.Node, query: string): ts.Node | undefined;\n  findFirst(ast: ts.Node | string, query?: string): ts.Node | undefined {\n    let q: Query;\n    if (typeof ast === 'string') {\n      query = ast;\n      q = new Query(query);\n      ast = this.src;\n    } else {\n      q = new Query(query!);\n    }\n    let res: ts.Node | undefined;\n    this.traverse(ast, (ast, path) => {\n      if (res)\n        return true;\n      if (q.matches(path)) {\n        res = ast;\n        return true;\n      }\n    });\n    return res;\n  }\n\n  list(ast: ts.Node = this.src) {\n    let out = '';\n    this.traverse(ast, (node, path, _parents, noChild) => {\n      if (noChild) {\n        out += path.join('>') + ' ' + node.getText(this.src);\n        out += '\\n';\n      }\n    });\n    return out;\n  }\n\n  printAll(ast: ts.Node = this.src): void {\n    this.traverse(ast, createPrintNodeCb(true));\n  }\n\n  printAllNoType(ast: ts.Node = this.src): void {\n    this.traverse(ast, createPrintNodeCb(false));\n  }\n  /**\n\t * \n\t * @param ast \n\t * @param cb return true to skip traversing child node and remaining sibling nodes\n\t * @param level default 0\n   * @returns true - stop traverse remaining nodes\n\t */\n  traverse(ast: ts.Node,\n    cb: traverseCbType,\n    propName = '', parents: ts.Node[] = [], pathEls: string[] = []): boolean {\n\n    let needPopPathEl = false;\n\n    // if (ast.kind !== ts.SyntaxKind.SourceFile) {\n      // let propName = parents[parents.length - 1] === this.src ? '' : this._findParentPropName(ast, parents);\n    let pathEl = ':' + sk[ast.kind];\n    if (propName)\n      pathEl = '.' + propName + pathEl;\n    pathEls.push(pathEl);\n\n    // const jsdoc = ts.getJSDocTags(ast);\n    // const comments = jsdoc ? jsdoc.map(t => t.comment).join() : '';\n    const comments = this.src.getFullText().slice(ast.getStart(undefined, true), ast.getStart());\n    needPopPathEl = true;\n    // }\n\n    const res = cb(ast, pathEls, parents, ast.getChildCount(this.src) <= 0, comments.trim());\n\n    if (res !== 'SKIP' && res !== true) {\n      parents.push(ast);\n      const _value2key = new Map<any, string>();\n\n      createValue2KeyMap(ast, _value2key);\n\n      /**\n       * ts.forEachChild (or `Node.forEachChild()`) just can't list all the children like pure sytax tokens,\n       * so I use Node.getChildrend() to get all child nodes.\n       * \n       * But ts.forEachChild is the only function which can get embedded array children node in form of NodeArray,\n       * so I still need it here.\n       */\n      ts.forEachChild(ast, child => {\n        let propName = _value2key.get(child);\n        if (propName == null) {\n          createValue2KeyMap(ast, _value2key, true);\n          propName = _value2key.get(child);\n        }\n        const isStop = this.traverse(child, cb, propName, parents, pathEls);\n        return isStop;\n          // return undefined;\n      },\n        subArray => {\n          let propName = _value2key.get(subArray);\n          if (propName == null) {\n            createValue2KeyMap(ast, _value2key, true);\n            propName = _value2key.get(subArray);\n          }\n          return this.traverseArray(subArray, cb, propName, parents, pathEls);\n        }\n      );\n      parents.pop();\n    }\n    if (needPopPathEl)\n      pathEls.pop();\n    return res === true;\n  }\n\n  pathForAst(ast: ts.Node, withType = true): string {\n    const pathEls: string[] = [];\n    let p = ast;\n    while (p) {\n      const propExp = this.propNameForAst(p);\n      pathEls.push((propExp ? '.' + propExp : '') + (withType ? ':' + sk[p.kind] : ''));\n      if (p === this.src)\n        break;\n      p = p.parent;\n    }\n    return pathEls.reverse().join('>');\n  }\n\n  protected propNameForAst(ast: ts.Node): string | null {\n    const p = ast.parent;\n    if (p == null)\n      return null;\n\n    const cachedProperties = astSchemaCache[p.kind];\n\n    let properties = cachedProperties;\n    if (properties == null) {\n      astSchemaCache[p.kind] = properties = Object.keys(p);\n    }\n\n    for (const prop of properties) {\n      const value = p[prop] as unknown;\n      if (['parent', 'kind', '_children', 'pos', 'end'].includes(prop))\n        continue;\n      if (Array.isArray(value)) {\n        const idx = (value as ts.Node[]).indexOf(ast);\n        if (idx >= 0) {\n          return prop + `[${idx}]`;\n        }\n      }\n      if (value === ast) {\n        return prop;\n      }\n    }\n    return '';\n  }\n\n  protected traverseArray(nodes: ts.NodeArray<ts.Node> | ts.Node[],\n    cb: traverseCbType,\n    propName = '', parents: ts.Node[] = [], pathEls: string[] = []): boolean {\n\n    let i = 0;\n    for (const ast of nodes) {\n      const isStop = this.traverse(ast, cb, propName + `[${i++}]`, parents, pathEls);\n      if (isStop)\n        return true;\n    }\n    return false;\n  }\n}\n\nfunction createValue2KeyMap(ast: ts.Node, value2KeyMap: Map<any, string>, rebuild = false): string[] {\n  // const props = keysIn(ast)\n  let props: string[];\n  const cached = astSchemaCache[ast.kind];\n\n  if (rebuild || cached == null) {\n    props = Object.keys(ast)\n      .filter(prop => typeof ast[prop] !== 'function' && !['parent', 'kind', '_children', 'pos', 'end'].includes(prop));\n    if (cached == null) {\n      astSchemaCache[ast.kind] = props;\n    } else {\n      const schema = cached;\n      schema.push(...props);\n      uniq(schema);\n      props = schema;\n    }\n  } else {\n    props = cached;\n  }\n  for (const key of props!) {\n    value2KeyMap.set(ast[key], key);\n  }\n  return props!;\n}\n\nexport interface AstCharacter {\n  propertyName?: string;\n  propIndex?: number;\n  kind?: string;\n}\n\nexport interface AstQuery extends AstCharacter {\n  text?: RegExp;\n}\n\nexport class Query {\n  queryPaths: AstCharacter[][]; // in reversed order\n  private fromRoot = false;\n\n  constructor(query: string) {\n    query = query.trim();\n    if (query.startsWith('^')) {\n      query = query.slice(1);\n      this.fromRoot = true;\n    }\n    this.queryPaths = query.trim()\n      .replace(/\\s*>\\s*/g, '>')\n      .split(/\\s+/)\n      .map(paths => paths.split('>')\n        .map(singleAstDesc => this._parseDesc(singleAstDesc)).reverse())\n      .reverse();\n  }\n\n  matches(path: string[]): boolean {\n    let testPos = path.length - 1;\n    const startTestPos = testPos;\n    for (const consecutiveNodes of this.queryPaths.slice(0)) {\n      while (true) {\n        if (this.matchesConsecutiveNodes(consecutiveNodes, path, testPos)) {\n          testPos -= consecutiveNodes.length;\n          break;\n        } else if (testPos === startTestPos) {\n          return false;\n        } else {\n          testPos--;\n        }\n        if (consecutiveNodes.length > testPos + 1)\n          return false;\n      }\n    }\n    return this.fromRoot ? testPos === 0 : true;\n  }\n\n  protected _parseDesc(singleAstDesc: string): AstQuery {\n    const astChar: AstQuery = {};\n      // eslint-disable-next-line\n\t\t\tlet m = /^(?:\\.([a-zA-Z0-9_$]+)(?:\\[([0-9]*)\\])?)?(?:\\:([a-zA-Z0-9_$]+))?$|^\\*$/.exec(singleAstDesc);\n    if (m == null) {\n      throw new Error(`Invalid query string \"${chalk.yellow(singleAstDesc)}\"`);\n    }\n    if (m[1]) {\n      astChar.propertyName = m[1];\n      if (m[2])\n        astChar.propIndex = parseInt(m[2], 10);\n    }\n    if (m[3])\n      astChar.kind = m[3];\n    return astChar;\n  }\n\n  private matchesAst(query: AstQuery, target: AstCharacter): boolean {\n    for (const key of Object.keys(query)) {\n      const value = query[key] as unknown;\n      if (isRegExp(value)) {\n        if (!value.test(target[key]))\n          return false;\n      } else if (target[key] !== value)\n        return false;\n    }\n    return true;\n  }\n\n  /**\n   * predicte if it matches \">\" connected path expression \n   * @param queryNodes all items in reversed order\n   * @param path \n   * @param testPos starts with path.length - 1\n   */\n  private matchesConsecutiveNodes(queryNodes: AstCharacter[], path: string[], testPos: number) {\n    if (queryNodes.length > testPos + 1)\n      return false;\n    for (const query of queryNodes.slice(0)) {\n      const target = this._parseDesc(path[testPos--]);\n      if (!this.matchesAst(query, target))\n        return false;\n    }\n    return true;\n  }\n}\n"]}